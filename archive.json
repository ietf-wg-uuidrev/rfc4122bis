{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-05-30T01:21:02.058001+00:00",
  "repo": "ietf-wg-uuidrev/rfc4122bis",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    },
    {
      "name": "Grammar",
      "description": "",
      "color": "c2e0c6"
    },
    {
      "name": "Technical",
      "description": "",
      "color": "FCEDC5"
    },
    {
      "name": "Consensus Requested",
      "description": "",
      "color": "F0E743"
    },
    {
      "name": "Consensus Acheived",
      "description": "",
      "color": "5AFF00"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "I_kwDOH6Ln3M5TLLGk",
      "title": "Errata: Fix uuid_create_md5_from_name() | 1352",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/2",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [1352](https://www.rfc-editor.org/errata/eid1352)\r\n- Status: Verified\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Frank Ellermann\r\n- Date Reported: 2008-03-08\r\n- Verifier Name: Alexey Melnikov\r\n- Date Verified: 2009-12-04\r\n\r\n### Errata\r\nIn Appendix B, it says:\r\n\r\n`uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f`\r\n\r\nIt should say:\r\n\r\n`uuid_create_md5_from_name(): 3d813cbb-47fb-32ba-91df-831e1593ac29`\r\n\r\n### Notes:\r\n\r\nThe given value e902... etc. is based on a calculation swapping the eight octets 0..3, 4..5, 6..7 twice, for the name space UUID, and for the MD5 output, as foreseen for little endian input, but the example values were already big endian. I can reproduce the example and the proposed fix, see <http://omniplex.blogspot.com/2008/03/md5-16-pop3-and-uuid.html>.\r\n\r\nThe blog entry contains links to an identical older error report, and two (different) examples from third parties also agreeing with that theory.",
      "createdAt": "2022-10-03T23:02:24Z",
      "updatedAt": "2023-01-20T15:26:49Z",
      "closedAt": "2023-01-20T15:26:49Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Swapping to `www.example.com` in #6 should render this Errata as fixed.",
          "createdAt": "2022-10-04T22:40:51Z",
          "updatedAt": "2022-10-04T22:40:51Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "I_kwDOH6Ln3M5TLLwz",
      "title": "Errata: Lexicographically Sorting Paragraph Fix | 1428",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/3",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [1428](https://www.rfc-editor.org/errata/eid1428)\r\n- Status: Verified\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Russ Housley\r\n- Date Reported: 2008-05-22\r\n- Verifier Name: Alexey Melnikov\r\n- Date Verified: 2009-12-04\r\n\r\n### Errata\r\nSection 3 says:\r\n\r\n```\r\nUUIDs, as defined in this document, can also be ordered lexicographically.\r\nFor a pair of UUIDs, the first one follows the second if the most significant\r\nfield in which the UUIDs differ is greater for the first UUID.  The second\r\nprecedes the first if the most significant field in which the UUIDs differ\r\nis greater for the second UUID.\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nUUIDs, as defined in this document, can also be ordered lexicographically.\r\nFor a pair of UUIDs, the first one follows the second if the most significant\r\nfield in which the UUIDs differ is greater for the first UUID.  The second\r\nfollows the first if the most significant field in which the UUIDs differ\r\nis greater for the second UUID.\r\n```\r\n\r\n### Notes:\r\n\r\nThe second and third sentences in the paragraph as originally written are\r\ninconsistent. I have proposed one of the possible fixes. There are others\r\nthat will make them consistent.",
      "createdAt": "2022-10-03T23:05:03Z",
      "updatedAt": "2023-01-20T15:26:50Z",
      "closedAt": "2023-01-20T15:26:50Z",
      "comments": []
    },
    {
      "number": 4,
      "id": "I_kwDOH6Ln3M5TLMJN",
      "title": "Errata: Bad Reference to RFC1750 | 3641",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/4",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [3641](https://www.rfc-editor.org/errata/eid3641)\r\n- Status: Verified\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Douglas Ray\r\n- Date Reported: 2013-06-06\r\n- Verifier Name: Barry Leiba\r\n- Date Verified: 2013-06-06\r\n\r\n### Errata\r\nThroughout the document, when it says:\r\n\r\n```\r\nAdvice on generating cryptographic-quality random numbers can be\r\n   found in RFC1750 [5].\r\n```\r\nIt should say:\r\n\r\n```\r\nAdvice on generating cryptographic-quality random numbers can be\r\n   found in RFC4086 [5].\r\n```\r\n\r\n### Notes:\r\n\r\n(Above sample is from section 4.5).\r\nReferences to RFC 1750 should currently refer to RFC 4086.\r\n(Likewise in Appendix A.)\r\nThe note [5] actually references RFC4086, but this is the only\r\npoint that is updated, ie, the document is inconsistent in its references.\r\nThe references in Appendix A are not cross-referenced to note [5].\r\n\r\n### Verifier notes\r\nThis is correct: reference [5] was updated to point to 4086, but the text in the\r\ndocument body was not changed accordingly.",
      "createdAt": "2022-10-03T23:06:39Z",
      "updatedAt": "2023-01-20T15:26:50Z",
      "closedAt": "2023-01-20T15:26:50Z",
      "comments": []
    },
    {
      "number": 5,
      "id": "I_kwDOH6Ln3M5TLMlZ",
      "title": "Errata: Incorrect Parenthesis usage Section 4.3 | 184",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/5",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [184](https://www.rfc-editor.org/errata/eid184)\r\n- Status: Verified\r\n- Type: Editorial\r\n- Publication Format(s) : TEXT\r\n- Reported By: Tim Wilson-Brown\r\n- Date Reported: 2006-05-03\r\n- Verifier Name: Alexey Melnikov\r\n- Date Verified: 2009-12-04\r\n\r\n### Errata\r\nSection 4.3 says:\r\n\r\n```\r\nThe UUIDs generated from the same name in two different namespaces\r\n       should be different with (very high probability).\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nThe UUIDs generated from the same name in two different namespaces\r\n       should be different (with very high probability).\r\n```\r\n\r\n### Notes:\r\n\r\nThe brackets should be set similarly to the other points.",
      "createdAt": "2022-10-03T23:08:49Z",
      "updatedAt": "2023-01-20T15:26:51Z",
      "closedAt": "2023-01-20T15:26:51Z",
      "comments": []
    },
    {
      "number": 6,
      "id": "I_kwDOH6Ln3M5TLM4S",
      "title": "Errata: Change MD5 website to example.com | 3476",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/6",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [3476](https://www.rfc-editor.org/errata/eid3476)\r\n- Status: Verified\r\n- Type: Editorial\r\n- Publication Format(s) : TEXT\r\n- Reported By: Simon Kissane\r\n- Date Reported: 2013-02-02\r\n- Verifier Name: Barry Leiba\r\n- Date Verified: 2013-02-03\r\n\r\n### Errata\r\nSection Appendix A,B says:\r\n\r\n```\r\nIn Appendix A, the line:\r\n    uuid_create_md5_from_name(&u, NameSpace_DNS, \"www.widgets.com\", 15);\r\nIn Appendix B, the line:\r\n     uuid_create_md5_from_name(): e902893a-9d22-3c7e-a7b8-d6e313b71d9f\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nIn Appendix A, the line:\r\n    uuid_create_md5_from_name(&u, NameSpace_DNS, \"www.example.com\", 15);\r\nIn Appendix B, the line:\r\n     uuid_create_md5_from_name(): 5df41881-3aed-3515-88a7-2f4a814cf09e\r\n```\r\n\r\n### Notes:\r\n\r\nPer RFC2606 section 5, it is best practice for standards and other documentation (including RFCs) to use the reserved example domains (e.g. example.com) rather than domains which could be in actual use. Indeed, the domain in question (www.widgets.com) is in actual use at the time of writing. So this proposed change uses \"www.example.com\" instead, and changes the example output accordingly. (Note that original output was wrong for the original input, as already noted in verified errata 1352.)",
      "createdAt": "2022-10-03T23:10:18Z",
      "updatedAt": "2023-01-20T15:26:51Z",
      "closedAt": "2023-01-20T15:26:51Z",
      "comments": []
    },
    {
      "number": 7,
      "id": "I_kwDOH6Ln3M5TLNJG",
      "title": "Errata: Fix reference to variant in octet 8 | 4975",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/7",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [4975](https://www.rfc-editor.org/errata/eid4975)\r\n- Status: Reported\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Joseph Boon\r\n- Date Reported: 2017-03-22\r\n\r\n### Errata\r\nSection 4.1 says:\r\n\r\n```\r\nThe UUID format is 16 octets; some bits of the eight octet variant \r\nfield specified below determine finer structure.\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nThe UUID format is 16 octets; some bits of the variant \r\nfield specified below determine finer structure.\r\n```\r\n\r\n### Notes:\r\n\r\nThe original wording implies the variant field is 8 octets long. It is between 1 and 3 bits long. An alternative correction would be:\r\n\r\n\"The UUID format is 16 octets; some bits of the variant\r\nfield in octet 8 specified below determine finer structure.\"",
      "createdAt": "2022-10-03T23:11:39Z",
      "updatedAt": "2023-01-20T15:27:15Z",
      "closedAt": "2023-01-20T15:27:15Z",
      "comments": []
    },
    {
      "number": 8,
      "id": "I_kwDOH6Ln3M5TLNnj",
      "title": "Errata: Further clarify 3rd/last bit of Variant for spec | 5560",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/8",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [5560](https://www.rfc-editor.org/errata/eid5560)\r\n- Status: Reported\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: GLOBAL UUID DATABASE\r\n- Date Reported: 2018-11-25\r\n\r\n\r\n### Errata\r\nSection 4.1.1 says:\r\n\r\n\r\n```\r\n   The following table lists the contents of the variant field, where\r\n   the letter \"x\" indicates a \"don't-care\" value.\r\n\r\n   Msb0  Msb1  Msb2  Description\r\n    0     x     x    Reserved, NCS backward compatibility.\r\n    1     0     x    The variant specified in this document.\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\n   The following table lists the contents of the variant field, where\r\n   the letter \"x\" indicates a \"don't-care\" value.\r\n\r\n   Msb0  Msb1  Msb2  Description\r\n\r\n    0     x     x    Reserved, NCS backward compatibility.\r\n\r\n    1     0     0    The variant specified in this document.\r\n```\r\n\r\n### Notes:\r\n\r\nIf Msb2 is a \u00ab don't-care \u00bb value, this means it's not wrong to set the bit to 0 or 1.\r\nIn the case of UUIDv3 and UUIDv5, this does not specify if the bit from the hash output should be left untouched or not.\r\nIt's not stated that it's illegal to reset it to 0 when setting Msb0 and Msb1 altogether (as libuuid does), since it's a \u00ab don't-care \u00bb value.\r\nBut letting it untouched whenever it's set to 1 by the hash output (as the Python stdlib does) causes two UUIDv{3,5} to be different for the same input namespaces and data. (Example: NS=Nil UUID, data = 0x44 (\u00abD\u00bb).\r\n\r\nThe RFC should enforce the value of the bit to 0 or 1, or clarify if it should be left untouched depending on the context-dependent data (Clock ID {1,2}, hash output {3,5}, random input {4}). (Which would mean it's then just a libuuid bug to forcibly set Msb2 to 0 when it should be untouched.)\r\n\r\nSee also : https://uuid.pirate-server.com/blog/brother-uuids-or-why-uuids-are-not-unique.html",
      "createdAt": "2022-10-03T23:14:26Z",
      "updatedAt": "2023-01-20T15:27:16Z",
      "closedAt": "2023-01-20T15:27:15Z",
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOH6Ln3M5TLN1B",
      "title": "Errata: Fix BAD OID acronym | 6225",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/9",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [6225](https://www.rfc-editor.org/errata/eid6225)\r\n- Status: Reported\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Daniel Marschall\r\n- Date Reported: 2020-07-07\r\n\r\n### Errata\r\nSection 4.3 says:\r\n\r\n```\r\nISO Object IDs (OIDs)\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nObject Identifiers (OIDs)\r\n```\r\n\r\n### Notes:\r\n\r\nAn Object Identifier (OID) is an identification mechanism jointly developed by ITU-T and ISO/IEC.\r\n\r\nIt makes no sense saying that it is an \"ISO OID\". Actually, it can be very confusing, because people could think that \"ISO OID\" means an OID which is a descendant of { iso(1) }, which would exclude OIDs descending from { itu-t(0) } and { joint-iso-itu-t(2) }.\r\n\r\nAlso in Appendix C, \"Name string is an ISO OID\" should be changed to \"Name string is an OID\".\r\n\r\nMaybe it would also be good to mention how the OID should be formatted. I guess the intention of the author is the normal dot-notation \"2.999\" which is passed as ASCII text to the name-based UUID generation function.",
      "createdAt": "2022-10-03T23:15:35Z",
      "updatedAt": "2023-01-20T15:26:52Z",
      "closedAt": "2023-01-20T15:26:52Z",
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOH6Ln3M5TLOQT",
      "title": "Errata: Fix clock_seq_hi_and_reserved most-significant bit verbiage | 4976",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/10",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [4976](https://www.rfc-editor.org/errata/eid4976)\r\n- Status: Reported\r\n- Type: Editorial\r\n- Publication Format(s) : TEXT\r\n- Reported By: Joseph Boon\r\n- Date Reported: 2017-03-22\r\n\r\n\r\n### Errata\r\nThroughout the document, when it says:\r\n\r\n```\r\nSet the two most significant bits (bits 6 and 7) of the\r\nclock_seq_hi_and_reserved to zero and one, respectively.\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nSet the two most significant bits (bits 7 and 6) of the\r\nclock_seq_hi_and_reserved to one and zero, respectively.\r\n```\r\n\r\n### Notes:\r\n\r\nThe original wording appears in sections 4.2.2, 4.3, and 4.4. It can lead to confusion about which bit is most significant (6 or 7), and does not align neatly with the table of Variants in section 4.1.1 (which shows 1 followed by 0 for msb0 and msb1). The revised wording specifies the bits in msb order, which helps the reader more clearly correlate the bit values with section 4.1.1. It is noted that the revised wording would not match other parts of the document which give the lsb number first (e.g. \"bits 32 through 47\"), but this case is different because it is specifying fixed values for two bits, and the sentence starts with \"Set the two most significant bits\".",
      "createdAt": "2022-10-03T23:18:03Z",
      "updatedAt": "2023-01-20T15:27:16Z",
      "closedAt": "2023-01-20T15:27:16Z",
      "comments": []
    },
    {
      "number": 11,
      "id": "I_kwDOH6Ln3M5TLOfd",
      "title": "Errata: Typo in code comment | 6665",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/11",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Grammar"
      ],
      "body": "### Errata ID: [6665](https://www.rfc-editor.org/errata/eid6665)\r\n- Status: Reported\r\n- Type: Editorial\r\n- Publication Format(s) : TEXT\r\n- Reported By: Andrzej Koszela\r\n- Date Reported: 2021-08-25\r\n\r\n### Errata\r\nSection Appendix A says:\r\n\r\n```\r\nstatic unsigned16 true_random(void);\r\n\r\n/* uuid_create -- generator a UUID */\r\nint uuid_create(uuid_t *uuid)\r\n{\r\n     uuid_time_t timestamp, last_time;\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nstatic unsigned16 true_random(void);\r\n\r\n/* uuid_create -- generate a UUID */\r\nint uuid_create(uuid_t *uuid)\r\n{\r\n     uuid_time_t timestamp, last_time;\r\n```\r\n\r\n### Notes:\r\n\r\nThe comment above the declaration of uuid_create() uses \"generate a UUID\", so the comment above the definition is likely intended to be identical.",
      "createdAt": "2022-10-03T23:19:30Z",
      "updatedAt": "2023-01-20T15:26:52Z",
      "closedAt": "2023-01-20T15:26:52Z",
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOH6Ln3M5TLOwe",
      "title": "Errata: Better Clarify network byte order when referencing most significant bits | 3546",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/12",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [3546](https://www.rfc-editor.org/errata/eid3546)\r\n- Status: Held for Document Update\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Askar Safin\r\n- Date Reported: 2013-03-14\r\n- Held for Document Update by: Barry Leiba\r\n- Date Held: 2013-03-20\r\n\r\n### Errata\r\nSection 4.1.3 says:\r\n\r\n```\r\nThe version number is in the most significant 4 bits of the time\r\nstamp (bits 4 through 7 of the time_hi_and_version field).\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nThe version number is in the most significant 4 bits of the time\r\nstamp (bits 0 through 3 of the time_hi_and_version field).\r\n```\r\n\r\n### Notes:\r\n\r\nWe use network order (as far as I know, we use network order in this RFC both for bits and bytes). So, the most significant bits comes first and they are located in first bytes. So, 0 through 3.\r\n\r\n### VERIFIER NOTES\r\nThis erratum is correct as far as it goes, but, given other text in the RFC, so is erratum 1957. There is a pervasive problem in this RFC with inconsistent and unclear usage of bit numbering, which switches between several conventions. The diagram in Section 4.1.2 uses left-to-right bit numbering (the most significant bit is numbered 0), but much of the text (such as in Section 4.2.2) uses right-to-left bit numbering (the least significant bit is numbered 0). Most of the text uses big-ending byte order (network byte order), but some seems to assume little-ending, probably mistakes that come from the authors' familiarity with that convention.\r\n\r\nWith respect to the text in question, the first sentence of Section 4.1.3, we have the following situation:\r\n\r\n- The original text is correct if we assume right-to-left bit numbering and little-endian byte order.\r\n\r\n- Erratum 1957 is correct if we assume right-to-left bit numbering and big-endian byte order. This change also makes the first sentence of Section 4.1.3 consistent with the sixth bullet in Section 4.2.2.\r\n\r\n- Erratum 3546 is correct if we assume left-to-right bit numbering and big-endian byte order.\r\n\r\nIn the end, the real point is that this document needs a revision that carefully and thoroughly fixes every instance of byte numbering (or removes the byte numbering and refers only to \"most significant\" and \"least significant\"). Such a revision should also double-check the sample code in Appendix A to be sure it works in both big-ending and little-endian machines.\r\n\r\nHappily, it's not likely that misunderstandings here will cause actual interoperability problems: this isn't a situation where things need to be disassembled and reassembled. The algorithm merely turns a UUID into a URN, and the URN is thereafter a \"black box\", an unchanged identifier. The only issue would be whether different interpretations of the document would turn two different UUIDs into the same URN, and, given the number of bits involved, the likelihood of collisions in practice is small.",
      "createdAt": "2022-10-03T23:21:07Z",
      "updatedAt": "2023-01-25T20:12:11Z",
      "closedAt": "2023-01-25T20:12:11Z",
      "comments": [
        {
          "author": "safinaskar",
          "authorAssociation": "NONE",
          "body": "I'm author of errata [3546](https://www.rfc-editor.org/errata/eid3546). Just now I carefully have read relevant fragment of https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-00.txt , i. e. this paragraph:\r\n\r\n> The version number is in the most significant 4 bits of octet 6.\r\n   More specifically bits 48 through 51.  The remaining 4 bits of Octet\r\n   6 are dynamic.\r\n\r\nSo, I'm sure this errata (regarding this paragraph) is fixed. Thanks a lot.\r\n\r\nAlso, it seems bits and bytes numbers are zero-based. I don't see mentions of this starting from begin of this document through this paragraph",
          "createdAt": "2022-11-23T12:36:07Z",
          "updatedAt": "2022-11-23T12:36:07Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> So, I'm sure this errata (regarding this paragraph) is fixed. Thanks a lot.\r\n\r\nThanks for the confirmation @safinaskar \r\n\r\n> Also, it seems bits and bytes numbers are zero-based. I don't see mentions of this starting from begin of this document through this paragraph\r\n\r\nI have this paragraph in Section 5 (being moved to section 4). I believe when moved to the correct spot this should address your concern.\r\n\r\n```\r\nWhile discussing UUID field layouts, bit definitions start at 0 and end at 127 while octets definitions start at 0 and end at 15.\r\n```\r\nEdit, https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-01.html#name-uuid-format\r\n",
          "createdAt": "2023-01-20T15:30:17Z",
          "updatedAt": "2023-01-23T23:18:56Z"
        },
        {
          "author": "safinaskar",
          "authorAssociation": "NONE",
          "body": "> I believe when moved to the correct spot this should address your concern.\r\n\r\nYes, I see",
          "createdAt": "2023-01-24T14:56:56Z",
          "updatedAt": "2023-01-24T14:56:56Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "I_kwDOH6Ln3M5TLPBt",
      "title": "Errata: Fix 4.1.3 reference to the correct bits | 1957",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/13",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Technical"
      ],
      "body": "### Errata ID: [1957](https://www.rfc-editor.org/errata/eid1957)\r\n- Status: Held for Document Update\r\n- Type: Technical\r\n- Publication Format(s) : TEXT\r\n- Reported By: Sergey Shandar\r\n- Date Reported: 2009-12-03\r\n- Held for Document Update by: Barry Leiba\r\n- Date Held: 2013-03-20\r\n\r\n### Errata\r\nSection 4.1.3 says:\r\n\r\n```\r\nThe version number is in the most significant 4 bits of the time\r\nstamp (bits 4 through 7 of the time_hi_and_version field).\r\n```\r\n\r\nIt should say:\r\n\r\n```\r\nThe version number is in the most significant 4 bits of the time\r\nstamp (bits 12 through 15 of the time_hi_and_version field).\r\n```\r\n\r\n### Notes:\r\n\r\ntime_hi_and_version is defined as 16 bit field.\r\n\r\n### VERIFIER NOTES\r\nThis change does make the text in Section 4.1.3 consistent with the sixth\r\nbullet in Section 4.2.2. But the issue goes well beyond that: there is a real\r\nproblem with the bit numbering throughout the RFC. Please see erratum\r\n3546 for more details.",
      "createdAt": "2022-10-03T23:22:42Z",
      "updatedAt": "2023-01-20T15:27:16Z",
      "closedAt": "2023-01-20T15:27:16Z",
      "comments": []
    },
    {
      "number": 16,
      "id": "I_kwDOH6Ln3M5UioIX",
      "title": "Draft 02: Describe Nil/Max UUID in variant table",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/16",
      "state": "CLOSED",
      "author": "ben221199",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "At the moment, the Nil-UUID is part of variant 0 and by that definition reserved. Variant 0 uses `AF_UNSPEC` in that case.\r\n\r\nHowever, the range of the Omni-UUID isn't reserved yet. This issue suggests to reserve a variant of the Omni-UUID. I would suggest to only reserve the `0xFF` variant. Why? I will explain.\r\n\r\nIn the early days of UUID, there was no such thing as variants. There was only \"family\". This family field consisted of only one single byte, so it ranged from 0 to 255. In modern days, this is the same byte as where the variant byte is in. With this information, the new variant table will be this:\r\n| Msb0 | Msb1 | Msb2 | As Byte | Values | Description |\r\n| - | - | - | - | - | - |\r\n| 0 | * | * | `0b0*******` | From 0 to 127 | Reserved, NCS backward compatibility. |\r\n| 1 | 0 | * | `0b10******` | From 128 to 191 | The variant specified in this document. |\r\n| 1 | 1 | 0 | `0b110*****` | From 192 to 223 | Reserved, Microsoft Corporation backward compatibility |\r\n| 1 | 1 | 1 | `0b111*****`<br>---<br>`0b11111111` | From 224 to 254<br>---<br>Only 255 | Reserved for future definition.<br>---<br>Omni-UUID variant |\r\n\r\nHandling the variant/family like this, it has at least 2 advantages:\r\n - It reserves a variant for the Omni-UUID, so that there will be no conflicts when a new variant will be specificed.\r\n - You clearly see that there are 31 variant slots open for definition (32 including Omni-UUID variant).\r\n\r\nThis doesn't mean that Variant 255 always should have all bits set to 1. It only reserves the range the Omni-UUID is in. I also think it is important to add this variant in this specification, because this specification defines the Omni-UUID itself.",
      "createdAt": "2022-10-21T13:41:59Z",
      "updatedAt": "2023-02-16T22:14:22Z",
      "closedAt": "2023-02-16T22:14:22Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems logical enough to me. I will slate it for IETF 115 discussion in addition to cross posting to the mailing group.",
          "createdAt": "2022-10-21T20:05:59Z",
          "updatedAt": "2022-10-21T20:05:59Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Makes sense. I agree some clarification is necessary because Table 1 looks to conflict with Max UUID, but by the way, do we need to limit the variant field to one byte rather than the remaining 64 bits? Even after our great-great-grandchildren consume `0b1111_1110`, they can still define `0b1111_1111_0`. The variant field is variable-length by its nature, so perhaps it is more helpful to describe the `10` technique explicitly. I haven't come up with a good idea to do this, but how about something like this?\r\n\r\n| Msb0 | Msb1 | Msb2 | Msb3 | Description                                            |\r\n| ---- | ---- | ---- | ---- | ------------------------------------------------------ |\r\n| 0    | x    | x    | x    | Reserved, NCS backward compatibility.                  |\r\n| 1    | 0    | x    | x    | The variant specified in this document.                |\r\n| 1    | 1    | 0    | x    | Reserved, Microsoft Corporation backward compatibility |\r\n| 1    | 1    | 1    | 0    | Reserved for a future variant.                        |\r\n| 1    | 1    | 1    | 1    | Reserved for future variants and Max UUID.           |\r\n\r\nOr this?\r\n\r\n| Msb0 | Msb1 | Msb2 | Description                                            |\r\n| ---- | ---- | ---- | ------------------------------------------------------ |\r\n| 0    | x    | x    | Reserved, NCS backward compatibility.                  |\r\n| 1    | 0    | x    | The variant specified in this document.                |\r\n| 1    | 1    | 0    | Reserved, Microsoft Corporation backward compatibility |\r\n| 1    | 1    | 1    | Reserved for future variants and Max UUID.           |\r\n",
          "createdAt": "2022-11-02T12:41:29Z",
          "updatedAt": "2022-11-02T12:51:01Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We could also say \"Reserved for the next future variant.\" for `0b1110`.",
          "createdAt": "2022-11-02T12:58:19Z",
          "updatedAt": "2022-11-02T12:58:19Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "> The variant field is variable-length by its nature, so perhaps it is more helpful to describe the 10 technique explicitly.\r\n\r\nThis is not fully correct. Forget about how the table is in RFC 4122. In the good old Apollo Computer days, there was a `family` field that was exactly 8 bits. Because only 13 families where used back then, the makers of RFC 4122 decided when starting with a 0-bit, it was variant 0 and defined families, and when starting with a 1-bit, it was another variant.\r\n\r\nMaking the variant field variable length, doesn't make any sense. It was defined on the same location as the family field on purpose. I would almost rather say: the variant field IS the family field.\r\n\r\n---\r\n\r\nWhat I think should be done? Well, I would recommend to redefine all variants to their 8-bit format, where `x` is a \"don't care\", so variant `0` becomes `0xxxxxxx`, variant `10` becomes `10xxxxxx` and variant `110` becomes `110xxxxx`. Why is this useful? Because you can assign ranges to it (see column 'Values' in my table). Instead of checking seperate bits, you just read the `family` byte, check the ranges, and you know the variant. Using 8-bit notation is also easier to understand and better to use in some IANA registry.\r\n\r\n---\r\n\r\n> do we need to limit the variant field to one byte rather than the remaining 64 bits?\r\n\r\nLook at what happened to `10xxxxxx`. This variant supports multiple versions. If you are afraid of running out of variants in the future, just reserve one variant now using the 8-bit notation and write an RFC that defines how your subversioning works, just like variant 1 in RFC 4122. Problem solved.\r\n",
          "createdAt": "2022-11-02T15:31:10Z",
          "updatedAt": "2022-11-02T15:31:10Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "So this...\r\n\r\nMsb0 | Msb1 | Msb2 | Description\r\n-- | -- | -- | --\r\n0 | x | x | Reserved, NCS backward compatibility.\r\n1 | 0 | x | The variant specified in this document.\r\n1 | 1 | 0 | Reserved, Microsoft Corporation backward compatibility\r\n1 | 1 | 1 | Reserved for future variants and Max UUID.\r\n\r\n...should become this...\r\n\r\nMsb0 | Msb1 | Msb2 | Msb3 | Msb4 | Msb5 | Msb6 | Msb7 | Description | Range\r\n-- | -- | -- | -- | -- | -- | -- | -- | -- | --\r\n0 | x | x | x | x | x | x | x | Reserved, NCS backward compatibility. | From 0 to 127 \r\n1 | 0 | x | x | x | x | x | x | The variant specified in this document. | From 128 to 191\r\n1 | 1 | 0 | x | x | x | x | x | Reserved, Microsoft Corporation backward compatibility | From 192 to 223\r\n1 | 1 | 1 | x | x | x | x | x | This was `Reserved for future definition.` in RFC 4122. Now we can reserve variant 224 to 254 for new formats and reserve 255 for Omni-UUID. This gives us space for 31 new variants. If you are afraid of running out of these variants soon, define one now and write an RFC about it, just like how variant 128-191 works with `versions`. | From 224 to 255\r\n\r\n...in my opinion.",
          "createdAt": "2022-11-02T15:40:36Z",
          "updatedAt": "2022-11-02T15:40:36Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "We can just forget about the family field because, as long as Msb0 is set to 1, no ID will collide with `0b0` variant values. Technically, the `0b1` authors could have done whatever they liked using the remaining 63 bits, but they generously gave up Msb1 so the future authors could use `0b11`. We should pay it forward; those who claim `0b111` should stick to `0b1110` and reserve `0b1111` for future authors. Similarly, `0b1111` should reserve `0b1111_1`, `0b1111_1` should reserve `0b1111_11`, `0b1111_11` should reserve `0b1111_111`, and so on. Accordingly, the table should look like this in full:\r\n\r\n| Msb0 | Msb1 | Msb2 | Msb3 | Msb4 | Msb5 | Msb6 | ... | Msb63 | Msb64 | Description                                            |\r\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | --- | ----- | ----- | ------------------------------------------------------ |\r\n| 0    | x    | x    | x    | x    | x    | x    | ... | x     | x     | Reserved, NCS backward compatibility.                  |\r\n| 1    | 0    | x    | x    | x    | x    | x    | ... | x     | x     | The variant specified in this document.                |\r\n| 1    | 1    | 0    | x    | x    | x    | x    | ... | x     | x     | Reserved, Microsoft Corporation backward compatibility |\r\n| 1    | 1    | 1    | 0    | x    | x    | x    | ... | x     | x     | Reserved for the 1st future variant.                   |\r\n| 1    | 1    | 1    | 1    | 0    | x    | x    | ... | x     | x     | Reserved for the 2nd future variant.                   |\r\n| 1    | 1    | 1    | 1    | 1    | 0    | x    | ... | x     | x     | Reserved for the 3rd future variant.                   |\r\n| 1    | 1    | 1    | 1    | 1    | 1    | 0    | ... | x     | x     | Reserved for the 4th future variant.                   |\r\n| ...  | ...  | ...  | ...  | ...  | ...  | ...  | ... | ...   | ...   | ...                                                    |\r\n| 1    | 1    | 1    | 1    | 1    | 1    | 1    | ... | 1     | 0     | Reserved for the last future variant.                  |\r\n| 1    | 1    | 1    | 1    | 1    | 1    | 1    | ... | 1     | 1     | Reserved for Max UUID.                                 |\r\n",
          "createdAt": "2022-11-02T17:40:41Z",
          "updatedAt": "2022-11-02T17:40:41Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": " I don't think this is useful. First, we don't need 18446744073709551616 variants, or in this case 64 variants (what actually isn't very different from 32, so I don't see a reason for having 64), I think we could better use this amount of possibilities for identifying objects, not variants. Second, maybe someone don't want have subversioning on the bytes directly after the `family` field, maybe he wants is at the beginning of the UUID or somewhere else.",
          "createdAt": "2022-11-02T18:58:27Z",
          "updatedAt": "2022-11-02T18:58:27Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Perhaps, at this stage, we don't need to say in the RFC what the `0b111` taker should do. So, just keeping Table 1 as is or the following should be enough:\r\n\r\n| Msb0 | Msb1 | Msb2 | Description                                            |\r\n| ---- | ---- | ---- | ------------------------------------------------------ |\r\n| 0    | x    | x    | Reserved, NCS backward compatibility.                  |\r\n| 1    | 0    | x    | The variant specified in this document.                |\r\n| 1    | 1    | 0    | Reserved, Microsoft Corporation backward compatibility |\r\n| 1    | 1    | 1    | Reserved for future variants and Max UUID.             |\r\n\r\nIt doesn't really make sense to reserve one byte and order the next variant author to use `0b1110_0000`. It wastes precious five bits for forward compatibility, which is too costly in my opinion. A new variant will be rarely necessary; the `0b10` variant is sufficient unless there is a serious need to remove the `ver` field, so we don't need to declare a large `var` space right now. Let's just leave it to the `0b111` takers like: https://github.com/uuid6/uuid6-ietf-draft/issues/26\r\n",
          "createdAt": "2022-11-02T22:47:56Z",
          "updatedAt": "2022-11-02T22:47:56Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I think your last row in the table is a very bad thing to do. Also, you contradict yourself by saying that my way is too costly, but we also don't need many variants. Note that version can only hold 16 values, where half of it is already taken. Also, https://github.com/uuid6/uuid6-ietf-draft/issues/26 is out of scope.",
          "createdAt": "2022-11-03T20:15:40Z",
          "updatedAt": "2022-11-03T20:15:40Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I think your last row in the table is a very bad thing to do.\r\n\r\nCan you please elaborate on this point?\r\n\r\n> Also, you contradict yourself by saying that my way is too costly, but we also don't need many variants.\r\n\r\nNot contradictory. Because we don't need many variants, reserving one byte for `var` is too costly.\r\n\r\n> Note that version can only hold 16 values, where half of it is already taken. Also, https://github.com/uuid6/uuid6-ietf-draft/issues/26 is out of scope.\r\n\r\nI'm afraid you are confusing versions and variants. Versions are specific to the `0b10` variant and have nothing to do with the future variants. If the future `0b111` authors believe they need sub-variants, they will allocate another version bits somewhere in the 128-bit space. If not, the version field will simply go away and the four bits will be utilized differently. We should let them decide, as we can't foresee the future.\r\n\r\nOn the other hand, if the future authors are considerate enough of the future of UUID spec, they will likely take the `0b1110` variant so the next future authors can take `0b1111`, just as https://github.com/uuid6/uuid6-ietf-draft/issues/26 tried to. E variant is out of scope, but the discussion clearly demonstrates how the `var` field can be utilized in the future. Similarly, `0b1111` takers are likely to reserve `0b1111_1`, `0b1111_1` takers to reserve `0b1111_11`, and so on. In this way, the `var` field can be variable-length, which might grows over many decades. I don't mean we should reserve 64 variants right now.\r\n\r\nI now think it's a good idea to add one paragraph below Table 1 stating the above intention to guide future authors like:\r\n\r\n> Future RFC authors who consume the reserved \"111\" variant are encouraged to (or, simply, SHOULD) define the \"1110\" variant and reserve the \"1111\" variant so that the next future authors can extend the UUID specification using the \"1111\" variant as well as the new variant does not conflict with the Max UUID.\r\n\r\nWe can only encourage (but not enforce) this rule because, as long as `var` starts with `0b111`, the future authors can do whatever they want without conflicting with the old standards. We cannot enforce the \"one byte `var`\" rule either for the same reason.\r\n",
          "createdAt": "2022-11-04T00:23:17Z",
          "updatedAt": "2022-11-04T00:23:17Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Repeating my comment from The January IETF interim meeting:\r\nAre we over engineering a solution? \r\n\r\nThis reads like we just want to clarify within the table that Nil/Max (omni) are present in the variant ranges.\r\n\r\nCould we not update the table to say:\r\n`Reserved, NCS backward compatibility and includes Nil UUID <insert section reference>`\r\n`Reserved for future definition and includes Max UUID <insert section reference>`",
          "createdAt": "2023-01-20T15:33:19Z",
          "updatedAt": "2023-01-20T15:33:48Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Seems to me a reasonable solution for now. It reserves the range where Omni-UUID is in for later definition, but also already tells to take into account having a variant for it in the future.\r\n\r\nOne addition: It seems the RFC at the moment will only documentate variant 1 (and its subversions). Maybe it is also good to documentate variant 0 (and its subfamilies). Because variant 0 family 0 is `af_unspec`, it is compatible with old specifications to documentate variant 0 and also include Nil-UUID:\r\n![image](https://user-images.githubusercontent.com/12856904/213872412-1e3732f8-fe84-4f6b-82aa-63fc56adb639.png)\r\n```\r\n *\r\n * Internal structure of variant #0 UUIDs\r\n *\r\n * The first 6 octets are the number of 4 usec units of time that have\r\n * passed since 1/1/80 0000 GMT.  The next 2 octets are reserved for\r\n * future use.  The next octet is an address family.  The next 7 octets\r\n * are a host ID in the form allowed by the specified address family.\r\n *\r\n * Note that while the family field (octet 8) was originally conceived\r\n * of as being able to hold values in the range [0..255], only [0..13]\r\n * were ever used.  Thus, the 2 MSB of this field are always 0 and are\r\n * used to distinguish old and current UUID forms.\r\n *\r\n * +--------------------------------------------------------------+\r\n * |                    high 32 bits of time                      |  0-3  .time_high\r\n * +-------------------------------+-------------------------------\r\n * |     low 16 bits of time       |  4-5               .time_low\r\n * +-------+-----------------------+\r\n * |         reserved              |  6-7               .reserved\r\n * +---------------+---------------+\r\n * |    family     |   8                                .family\r\n * +---------------+----------...-----+\r\n * |            node ID               |  9-16           .node\r\n * +--------------------------...-----+\r\n *\r\n */\r\n```\r\nSource: https://opensource.apple.com/source/CF/CF-299.35/Base.subproj/uuid.c.auto.html\r\n\r\nSo, for Nil-UUID:\r\n - All `time` bits are zero\r\n - All `reserved` bits are zero by definition\r\n - All `family` bits are zero. The first bit tells us it is variant 0; in combination with the other 7 bits, we also know the family: `AF_UNSPEC`. Because the family is `UNSPEC`, we don't have to follow any family format rules.\r\n - All `node ID` bits are zero.\r\n\r\nThen, we can change the description text for variant zero to:\r\n`Apollo NCS format [Section x.x], including Nil-UUID [Section y.y].`",
          "createdAt": "2023-01-21T15:01:09Z",
          "updatedAt": "2023-01-21T15:01:09Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@ben221199, maybe I can sneak Variant 0 and its sub-families into an appendix or I could link that source exactly as a reference.\r\nI would hate to add technical information we are not fully in control of. Basically treat it like UUIDv2m \"out of our control go to this doc to read about it.\" and insert the source.",
          "createdAt": "2023-01-23T21:12:35Z",
          "updatedAt": "2023-01-23T21:12:35Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I think an appendix would be okay for now. In that case, at least the variant is included in the RFC, so no linking to sources that can disappear in the future, but not part of the main specification. I'm cool with that.",
          "createdAt": "2023-01-24T20:56:05Z",
          "updatedAt": "2023-01-24T20:56:05Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "I_kwDOH6Ln3M5UzWdv",
      "title": "Typo in UUIDv7 test vector?",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/17",
      "state": "CLOSED",
      "author": "oittaa",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis#appendix-C.6\r\n\r\nThere might be a typo in final UUIDv7 test vector.\r\n\r\n```\r\n   -------------------------------\r\n   field      bits    value\r\n   -------------------------------\r\n   unix_ts_ms   48    0x17F22E279B0\r\n   ver           4    0x7\r\n   rand_a       12    0xCC3\r\n   var           2    b10\r\n   rand_b       62    b01, 0x8C4DC0C0C07398F\r\n   -------------------------------\r\n   total       128\r\n   -------------------------------\r\n   final: 017F22E2-79B0-7CC3-98C4-DC0C0C07398F\r\n```\r\n\r\nI think it actually yields 017F22E2-79B0-7CC3-***8***8C4-DC0C0C07398F.\r\n\r\nHere's how I generated it simply from Python command line.\r\n\r\n```python\r\nhex(0x8C4DC0C0C07398F | 2 << 62 | 0xCC3 << 62 + 2 | 0x7 << 62 + 2 + 12 | 0x17F22E279B0 << 62 + 2 + 12 + 4)\r\n'0x17f22e279b07cc388c4dc0c0c07398f'\r\n```\r\n\r\nFor example the version 6 works as expected and matches the result `1EC9414C-232A-6B00-B3C8-9E6BDECED846`.\r\n\r\n```\r\n   -----------------------------------------------\r\n   field                 bits    value\r\n   -----------------------------------------------\r\n   time_high              32     0x1EC9414C\r\n   time_mid               16     0x232A\r\n   time_low_and_version   16     0x6B00\r\n   clk_seq_hi_res          8     0xB3\r\n   clock_seq_low           8     0xC8\r\n   node                   48     0x9E6BDECED846\r\n   -----------------------------------------------\r\n   total                 128\r\n   -----------------------------------------------\r\n   final_hex: 1EC9414C-232A-6B00-B3C8-9E6BDECED846\r\n```\r\n\r\n```python\r\nhex(0x9E6BDECED846 | 0xC8 << 48 | 0xB3 << 48 + 8 | 0x6B00 << 48 + 8 + 8 | 0x232A << 48 + 8 + 8 + 16 | 0x1EC9414C << 48 + 8 + 8 + 16 + 16)\r\n'0x1ec9414c232a6b00b3c89e6bdeced846'\r\n```",
      "createdAt": "2022-10-25T16:24:30Z",
      "updatedAt": "2022-10-25T16:42:47Z",
      "closedAt": "2022-10-25T16:42:46Z",
      "comments": [
        {
          "author": "oittaa",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh sorry, I didn't notice `b01` part for some reason. The following works as expected.\r\n\r\n```python\r\n>>> hex(0x8C4DC0C0C07398F | 1 << 60 | 2 << 62 | 0xCC3 << 62 + 2 | 0x7 << 62 + 2 + 12 | 0x17F22E279B0 << 62 + 2 + 12 + 4)\r\n'0x17f22e279b07cc398c4dc0c0c07398f'\r\n```",
          "createdAt": "2022-10-25T16:42:46Z",
          "updatedAt": "2022-10-25T16:42:46Z"
        }
      ]
    },
    {
      "number": 18,
      "id": "I_kwDOH6Ln3M5VbdTY",
      "title": "Draft 01: Mixed Case Spelling error",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/18",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "\"mixe case\" in text spelled wrong.",
      "createdAt": "2022-11-02T14:37:28Z",
      "updatedAt": "2023-01-20T17:12:30Z",
      "closedAt": "2023-01-20T17:12:30Z",
      "comments": []
    },
    {
      "number": 19,
      "id": "I_kwDOH6Ln3M5VbeF1",
      "title": "Draft 01: Add \"UUIDs that Do Not Identify the Host as well\" reference to security considerations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/19",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "> MAC addresses pose inherent security risks and SHOULD not be used within a UUID. Instead CSPRNG data SHOULD be selected from a source with sufficient entropy to ensure guaranteed uniqueness among UUID generation. See Section 6.8 for more information.\r\n\r\nAdd reference to 6.9.  UUIDs that Do Not Identify the Host as well",
      "createdAt": "2022-11-02T14:38:53Z",
      "updatedAt": "2023-01-20T17:12:31Z",
      "closedAt": "2023-01-20T17:12:31Z",
      "comments": []
    },
    {
      "number": 20,
      "id": "I_kwDOH6Ln3M5VbefG",
      "title": "Draft 01: Out of Place Distributed node text",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/20",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "> Distributed applications generating UUIDs at a variety of hosts must be willing to rely on the random number source at all hosts. If this is not feasible, the namespace variant should be used.\r\n\r\nCopied from RFC4122, needs moved to distributed node section vs Security considerations for better readability.",
      "createdAt": "2022-11-02T14:39:37Z",
      "updatedAt": "2023-01-20T17:12:31Z",
      "closedAt": "2023-01-20T17:12:31Z",
      "comments": []
    },
    {
      "number": 21,
      "id": "I_kwDOH6Ln3M5VlZ3O",
      "title": "Draft 01: v6 clock_seq and node usage ambiguity",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/21",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Section 5.6 says \"the 48 bit node SHOULD be set to a pseudo-random value\". Which does it mean:\r\n\r\n1. the node SHOULD be reset to a pseudo-random number every time a new UUIDv6 is generated; or,\r\n2. the node SHOULD be initialized at a pseudo-random number only once at the system boot?\r\n\r\nThe old RFC 4122 doesn't seem clear enough, or it is rather so permissive as to accept many kinds of spatially unique identifiers. It's okay for v1 to be ambiguous; we must anyway keep it as ambiguous as it has been. Since v6 should be compatible with v1, everything should also be permitted under v6, but questions arise on which method v6 should recommend as default. We don't need to be ambiguous here.\r\n\r\nIf the first option is the way to go, the following text in Section 5.6:\r\n\r\n> The clock sequence bits remain unchanged from their usage and position in Section 5.1.\r\n>\r\n> The 48 bit node SHOULD be set to a pseudo-random value however implementations MAY choose to retain the old MAC address behavior from Section 5.1 and Section 6.9. For more information on MAC address usage within UUIDs see the Section 9\r\n\r\ncan be reworded in a much simpler way as:\r\n\r\n> The clock sequence and node bits SHOULD be reset to a pseudo-random value for each new UUIDv6 generated; however, implementations MAY choose to retain the UUIDv1 behavior from Section 5.1.\r\n\r\nbecause the clock sequence bits are reset to a random number when the node ID changes. Refreshing `node` to a random number every time is equivalent to resetting both `clock_seq` and `node` to random numbers every time. This point seems clear from Section 4.2.1 and Appendix A of the old RFC 4122.\r\n\r\nIf the latter option is recommended, the RFC should state that explicitly.",
      "createdAt": "2022-11-04T10:36:29Z",
      "updatedAt": "2023-01-19T19:23:48Z",
      "closedAt": "2023-01-19T19:23:48Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Good points and brings up a discussion we had on the interim meeting and during IETF 115 today on the topic of \"when to initialize random\" your two numbered bullets describe the two scenarios and I need to add some security considerations around usage of number 1 which can potentially exhaust random entropy sources. \r\n\r\nI'll slate this for Draft 01 and see what verbiage I can come up with for the mailing list to sign off on. ",
          "createdAt": "2022-11-08T18:30:53Z",
          "updatedAt": "2022-11-08T18:30:53Z"
        }
      ]
    },
    {
      "number": 22,
      "id": "I_kwDOH6Ln3M5V31m4",
      "title": "Draft 01: Figure 2 and 3 Fix Title",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/22",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "`Figure 2: Example Hex UUID` -> `Figure 3: Example Binary UUID`\r\n`Figure 3: Example Hex UUID` -> `Figure 3: Example Integer UUID`\r\n\r\n",
      "createdAt": "2022-11-08T18:27:23Z",
      "updatedAt": "2023-01-20T17:12:32Z",
      "closedAt": "2023-01-20T17:12:32Z",
      "comments": []
    },
    {
      "number": 23,
      "id": "I_kwDOH6Ln3M5V34Xx",
      "title": "Draft 01: Move Namespace Registration Template to IANA Considerations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/23",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "As per IETF 115 discussion, moving this from appendix to IANA considerations + update to latest and greatest format as per RFC8141",
      "createdAt": "2022-11-08T18:36:46Z",
      "updatedAt": "2023-01-20T18:03:26Z",
      "closedAt": "2023-01-20T18:03:26Z",
      "comments": []
    },
    {
      "number": 24,
      "id": "I_kwDOH6Ln3M5V35Uv",
      "title": "Draft 01: Verify ABNF formatting against RFC5234",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/24",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Specifically should these be `4hexOctet` or `4*hexOctet` as per https://www.rfc-editor.org/rfc/rfc5234#section-3.6",
      "createdAt": "2022-11-08T18:40:09Z",
      "updatedAt": "2023-01-20T17:12:32Z",
      "closedAt": "2023-01-20T17:12:32Z",
      "comments": []
    },
    {
      "number": 25,
      "id": "I_kwDOH6Ln3M5V35gy",
      "title": "Draft 01: Bump ABNF reference to RFC 5234",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/25",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "https://www.rfc-editor.org/rfc/rfc5234",
      "createdAt": "2022-11-08T18:40:45Z",
      "updatedAt": "2023-01-20T17:12:33Z",
      "closedAt": "2023-01-20T17:12:33Z",
      "comments": []
    },
    {
      "number": 26,
      "id": "I_kwDOH6Ln3M5V35sh",
      "title": "Draft 02: More Security Considerations Randomness",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/26",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "As per Brendan Moran, notes on this will be delivered on the emailer to add to security considerations.",
      "createdAt": "2022-11-08T18:41:21Z",
      "updatedAt": "2023-02-16T22:14:22Z",
      "closedAt": "2023-02-16T22:14:22Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Possibly add reference that points too:\r\nhttps://github.com/peteroupc/peteroupc.github.io/blob/master/random.md",
          "createdAt": "2023-01-10T17:35:40Z",
          "updatedAt": "2023-01-10T17:35:40Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "Perhaps you could use this sentence structure:\r\n\r\n_Implementations MUST ${verb_phrase} unless explicitly stated otherwise._\r\n\r\nWe see this structure in some specifications like this paragraph in [RFC-4648](https://www.rfc-editor.org/rfc/rfc4648):\r\n\r\n>   Implementations MUST reject the encoded data if it contains\r\n>   characters outside the base alphabet when interpreting base-encoded\r\n>   data, unless the specification referring to this document explicitly\r\n>   states otherwise.\r\n\r\nIn this case, a possible instance of this structure is:\r\n\r\n_Implementations MUST use a cryptographically-secure PRNG unless the documentation explicitly states otherwise._\r\n\r\nIn other words, if the implementer uses a Xorshift generator, they MUST make that clear in the documentation.\r\n\r\nDoes that make sense to you?\r\n",
          "createdAt": "2023-02-05T07:38:07Z",
          "updatedAt": "2023-02-05T07:47:35Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@fabiolimace the problem with using a MUST is there is no alternative and by adding \"unless the documentation explicitly states otherwise\" it sort of goes against the defined MUST. \r\n\r\nSHOULD verbiage allows an alternative assuming you know the risks and have a good reason for doing so. e.g some old machine/library that can only do PRNG and not CSPRNG.\r\n\r\nI also don't see any reference to RFC 4648 in our doc? What made you look at that spec?",
          "createdAt": "2023-02-06T15:23:54Z",
          "updatedAt": "2023-02-06T15:24:29Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "I understand. The SHOULD modal allows for an alternative approach.\r\n\r\n<s>I think it would be nice if the user of the code could know when the implementation isn't using a PRNG as recommended by the spec, especially when the code is closed and it's not possible to verify this.</s> **EDIT**: sorry no one would do it.\r\n\r\nBy the way, I was reading this RFC-4648 and I randomly remembered this issue. Let's forget it. :)",
          "createdAt": "2023-02-08T01:47:00Z",
          "updatedAt": "2023-02-08T01:57:36Z"
        }
      ]
    },
    {
      "number": 27,
      "id": "I_kwDOH6Ln3M5V36Fy",
      "title": "Draft 01: Modify v8 SHOULD NOT to MUST NOT",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/27",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "`UUIDv8's uniqueness will be implementation-specific and SHOULD NOT be assumed`\r\n\r\nTO\r\n\r\n`UUIDv8's uniqueness will be implementation-specific and MUST NOT be assumed`\r\n\r\nfrom Murray K. IETF 115",
      "createdAt": "2022-11-08T18:42:41Z",
      "updatedAt": "2023-01-20T17:12:33Z",
      "closedAt": "2023-01-20T17:12:33Z",
      "comments": []
    },
    {
      "number": 28,
      "id": "I_kwDOH6Ln3M5V36p4",
      "title": "Draft 01: Review and possibly add OID items from X.667 ",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/28",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Specifically OID in integer format and hex-and-dash format. \r\nLikely section: UUID Format",
      "createdAt": "2022-11-08T18:44:35Z",
      "updatedAt": "2022-12-08T21:20:10Z",
      "closedAt": "2022-12-08T21:20:10Z",
      "comments": []
    },
    {
      "number": 29,
      "id": "I_kwDOH6Ln3M5V37px",
      "title": "Draft 01: Remove \"time-based\" constraint from version 8 UUID",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/29",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Source https://github.com/uuid6/uuid6-ietf-draft/issues/124",
      "createdAt": "2022-11-08T18:48:02Z",
      "updatedAt": "2023-01-20T17:12:34Z",
      "closedAt": "2023-01-20T17:12:34Z",
      "comments": []
    },
    {
      "number": 30,
      "id": "I_kwDOH6Ln3M5V37vf",
      "title": "Draft 01: Further clarify v7 field description #125",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/30",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Source: https://github.com/uuid6/uuid6-ietf-draft/issues/125",
      "createdAt": "2022-11-08T18:48:21Z",
      "updatedAt": "2023-01-20T17:12:34Z",
      "closedAt": "2023-01-20T17:12:34Z",
      "comments": []
    },
    {
      "number": 31,
      "id": "I_kwDOH6Ln3M5V3-KU",
      "title": "Draft 02: SHOULD vs MUST BCP 14 review everywhere",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/31",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As per IETF 115, Murray K.(?):\r\nLikely slated for Draft 02 but need to have somebody, non author/editor, review every SHOULD and answer if a defined alternative exists within the text and ultimately if that SHOULD:\r\n- Stays as is since there are clearly defined edge cases\r\n- Increases to a MUST since there is no reason not too / no alternative\r\n- Decreases further to a MAY ",
      "createdAt": "2022-11-08T18:56:38Z",
      "updatedAt": "2023-04-06T16:01:18Z",
      "closedAt": "2023-04-06T16:01:18Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Jim:\r\n> Section 5.7:  \"SHOULD utilize UUID version 7\": explain why, and under \r\n> what circumstances versions 1 and 6 are acceptable.",
          "createdAt": "2023-01-20T16:40:50Z",
          "updatedAt": "2023-01-20T16:40:50Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "I_kwDOH6Ln3M5YxaRm",
      "title": "Typo:  Section 4.2, Version Field, \"UUID from in this\"",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/33",
      "state": "CLOSED",
      "author": "broofa",
      "authorAssociation": "NONE",
      "assignees": [
        "kyzer-davis"
      ],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "\"The Gregorian time-based UUID ~~from~~ in this document\"",
      "createdAt": "2022-12-11T03:19:37Z",
      "updatedAt": "2023-01-20T17:12:49Z",
      "closedAt": "2023-01-20T17:12:49Z",
      "comments": []
    },
    {
      "number": 38,
      "id": "I_kwDOH6Ln3M5cYEMI",
      "title": "RFC 5234",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/38",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`The formal definition of the UUID string representation is provided by the following ABNF [[RFC4234](https://ietf-wg-uuidrev.github.io/rfc4122bis/draft-00/draft-ietf-uuidrev-rfc4122bis.html#RFC4234)]:`\r\n\r\nEtc. are wrong.\r\n",
      "createdAt": "2023-01-19T19:25:20Z",
      "updatedAt": "2023-01-20T16:38:10Z",
      "closedAt": "2023-01-20T16:38:09Z",
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "(idnits is a useful tool that quickly finds things like this.\r\nAvailable via <https://author-tools.ietf.org>.)",
          "createdAt": "2023-01-19T19:41:53Z",
          "updatedAt": "2023-01-19T19:41:53Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, covered under #25 for Draft 01",
          "createdAt": "2023-01-20T16:38:09Z",
          "updatedAt": "2023-01-20T16:38:09Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "I_kwDOH6Ln3M5cYFQq",
      "title": "Create better ABNF to represent Hex Digit",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/39",
      "state": "CLOSED",
      "author": "cabo",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Please use a more common form of identifying hexdigit in the IETF.\r\n\r\nCertainly\r\n\r\n```\r\nhexDigit =\r\n      \"0\" / \"1\" / \"2\" / \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\" /\r\n      \"a\" / \"b\" / \"c\" / \"d\" / \"e\" / \"f\" /\r\n      \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\r\n[\u00b6](https://ietf-wg-uuidrev.github.io/rfc4122bis/draft-00/draft-ietf-uuidrev-rfc4122bis.html#appendix-A-2.8.5)\r\n``` \r\n\r\nis suboptimal as both \"a\" and \"A\" identify a case-insensitive letter A.\r\n\r\nE.g.:\r\n``` \r\n   hexDigit = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\r\n``` \r\n\r\nOr use the % form:\r\n\r\n``` \r\n   DIGIT           = %x30-39\r\n   hexDigit      = DIGIT / %x61-66 / %x41-47\r\n```\r\n\r\n",
      "createdAt": "2023-01-19T19:28:27Z",
      "updatedAt": "2023-01-23T22:55:18Z",
      "closedAt": "2023-01-23T22:55:18Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@cabo, this looks to do the trick and condense it down nicely.\r\nIt looks like `%x41-47` should be `%x41-46` since it includes the uppercase G.\r\n\r\nNote, the `CRLF` below is just so `anbfgen` will output each on a new line else it outputs in a big jumbled mess. I will remove it. \r\n\r\nI am open to either however RFC5234 specifies HEXDIGIT and DIGIT in core rules so I say we use that over my second example.\r\nSource: https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\r\n\r\n### Test 1\r\n```\r\nkydavis@ubuntu-22:~/abnfgen/abnfgen-0.20$ cat abnf-new.txt\r\n   UUID     = 4hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              6hexOctet CRLF\r\n   hexOctet = HEXDIG HEXDIG\r\n   DIGIT    = %x30-39\r\n   HEXDIG   = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\"\r\n\r\nkydavis@ubuntu-22:~/abnfgen/abnfgen-0.20$ ./abnfgen abnf-new.txt -n 10\r\nABEfdbaF-ffAb-Aedb-CEe3-C0bDBE4Bdeed\r\n2DafADBE-a8DA-CCE6-bBFA-dBAdcaeDFDFa\r\nADEEdCAd-dAEE-DdeD-EbAD-cf68FeAAFeCc\r\n5fa7dEea-d4DF-3Ceb-FDAb-FEbFcCE6dbED\r\nefEEadeA-ACfE-fdCD-EBCF-b1ccF6dDc6F7\r\nBFFeDEcc-FDdd-1Fdf-FBf7-AfaCcdfcBEFB\r\nfC7ADE0A-ccdF-b9aC-FCaB-D31cDFAAbCee\r\n6dAAdb2F-dEDB-aFAB-Fad3-adDfceAEcCbD\r\ndFAFCBfc-EbBb-fdC2-Bb3F-CB5BAfCdBaAD\r\nFD2bb3eE-dba5-fEeA-eCDB-bb5ddeAFcaBF\r\n```\r\n\r\n### Test 2\r\n```\r\nkydavis@ubuntu-22:~/abnfgen/abnfgen-0.20$ cat abnf-new-2.txt\r\n   UUID     = 4hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              2hexOctet \"-\"\r\n              6hexOctet CRLF\r\n   hexOctet = hexDigit hexDigit\r\n   hexDigit = %x30-39 / %x61-66 / %x41-46\r\n              ; 0-9, a-f, A-F\r\n\r\nkydavis@ubuntu-22:~/abnfgen/abnfgen-0.20$ ./abnfgen abnf-new-2.txt -n 10\r\nAfEA4BFc-0BcB-DB63-9d3E-DF32bbb8BF1B\r\nc17aae0d-7c8f-11db-CF1E-EDA6eC8eF7e7\r\n3B7edB6C-5eac-A2d2-e6AD-c31416c1b74F\r\n29CD0f1C-F80F-ca4a-a7DB-ffAeffaEC84c\r\n0Ef606D4-4B30-C16c-Fdd3-Fbe3Ced1Ea2A\r\n6baAAfBc-FDbC-e1a7-ca81-2e55bfbcbCbb\r\n6F0F7ac7-bDbB-FCDD-1cEf-1F851cD95cff\r\n0AAaAeda-90aa-FE2D-3AEB-Bf75cfB3abDc\r\nFCe208c7-FAFc-B0aB-5DDB-cB9a08406EB3\r\nBCfeCaC8-f80c-D57f-91f5-6DbaBD46D1AC\r\n```",
          "createdAt": "2023-01-20T15:24:06Z",
          "updatedAt": "2023-01-20T15:24:06Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "I agree.\r\nYou probably should add a comment that ABNF strings are case-insensitive -- people are not used to that any more in 2023.\r\n",
          "createdAt": "2023-01-20T16:43:17Z",
          "updatedAt": "2023-01-20T16:43:17Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "I_kwDOH6Ln3M5ccWN3",
      "title": "Draft 01: Break Binary form of UUID into two lines.",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/40",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "From Jim\r\n> Section 4, figure 2: The binary UUID has been truncated because the \r\n> line is too long. Figure out how to split into two lines.\r\n\r\nFrom Kyzer\r\n> I wondered about that; it worked fine for HTML rendering but TXT it isn't good.\r\n> I can open an issue to use one of the methods in RFC8792 e.g `backslash` or `double backslash` techniques.",
      "createdAt": "2023-01-20T14:23:43Z",
      "updatedAt": "2023-01-20T17:12:50Z",
      "closedAt": "2023-01-20T17:12:50Z",
      "comments": []
    },
    {
      "number": 41,
      "id": "I_kwDOH6Ln3M5cdKtU",
      "title": "Move octet text from section 4 to section 5",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/41",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 4.1: \"octet 8\" is the first mention of an octet number. Should\r\nsomething be said about octet numbering first? For example, most significant octet first, starting with 0\r\n\r\nKyzer:\r\n> Yes, I noticed this myself, I have text in Section 5.0 start that defines the start of octet descriptors. I will open an issue to move this to section 4.0. ",
      "createdAt": "2023-01-20T16:39:35Z",
      "updatedAt": "2023-01-23T22:55:04Z",
      "closedAt": "2023-01-23T22:55:04Z",
      "comments": []
    },
    {
      "number": 42,
      "id": "I_kwDOH6Ln3M5cdK4L",
      "title": "Add forward reference to UUIDv1 and UUIDv4 in Section 2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/42",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n\r\n> Section 2: UUIDv4 (item 1) and UUIDv1 (item 2) references: Should \r\n> these be forward references to later sections of the document?\r\n\r\nKyzer:\r\n> Yes, that is likely a good thing to do. I used v1 and v4 for those Section 2 examples since they are \"very well known\" so I opted to use them to hammer home the finer UUID structure details. I will open an issue to track this.",
      "createdAt": "2023-01-20T16:40:16Z",
      "updatedAt": "2023-01-23T22:55:04Z",
      "closedAt": "2023-01-23T22:55:04Z",
      "comments": []
    },
    {
      "number": 43,
      "id": "I_kwDOH6Ln3M5cdL3X",
      "title": "Draft 02: Expand multiplexed fields within v1 and v6 bit definitions",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/43",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 5.1: Figure 6 (and also Figure 10) contain the \r\n> `time_hi_and_version` field. Why not make the version field separate, as it is for example in Figure 7? Make the \"var\" field separate as well.\r\n\r\nKyzer:\r\n> In UUIDv1 this is from the old document and kept for historical reasons (many libraries use this descriptor in the code or documentation) For UUIDv6 we kept it to better show the relationship between the two layouts. \r\n\r\nJan 22' Interim Meeting:\r\n> Consensus from the group was to modify these since they cause confusion. Same for `clk_seq_hi_res `\r\n\r\nKyzer:\r\n> This will cause lots of rippling changes to v1/v6 sections along with appendix examples for both. Need to be meticulous that this expansion is handled properly. Better for next draft to focus on just that change.",
      "createdAt": "2023-01-20T16:43:36Z",
      "updatedAt": "2023-02-16T22:14:23Z",
      "closedAt": "2023-02-16T22:14:23Z",
      "comments": []
    },
    {
      "number": 44,
      "id": "I_kwDOH6Ln3M5cdMNu",
      "title": "Draft 02: Expand upon why unix epoch rollover is not a problem",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/44",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 6.1: Length: Perhaps directly address why the Unix epoch \r\n> rollover is not a concern here.",
      "createdAt": "2023-01-20T16:44:29Z",
      "updatedAt": "2023-02-16T22:14:23Z",
      "closedAt": "2023-02-16T22:14:23Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Had to dig deep but I knew we discussed this. \r\nhttps://github.com/uuid6/uuid6-ietf-draft/issues/23#issuecomment-898939437\r\n\r\n10889 AD for v7 at 48 bits and MS resolution\r\n5623 AD for v1/v6 at 60 bits and 100-NS resolution",
          "createdAt": "2023-02-09T21:51:22Z",
          "updatedAt": "2023-02-09T21:51:22Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "I_kwDOH6Ln3M5cdMgA",
      "title": "Erronous reference to v1 in monotonicity",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/45",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 6.2: In paragraph 3, it refers to monotonicity of UUID version 1.\r\n> But version 1 is not monotonic at a high level because the byte order is wrong, so it will not be seen by applications not explicitly looking at the version field as monotonic. It might be good to point that out, especially since this is one of the motivations for the new UUID versions.\r\n\r\nKyzer:\r\n> Yes, I will open a tracker item to remove version 1 from that sentence.",
      "createdAt": "2023-01-20T16:45:20Z",
      "updatedAt": "2023-01-23T22:55:05Z",
      "closedAt": "2023-01-23T22:55:05Z",
      "comments": []
    },
    {
      "number": 46,
      "id": "I_kwDOH6Ln3M5cdMpZ",
      "title": "Add Label for \"Monotonic Error Checking\" paragraph to frame the topic",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/46",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim\r\n> Section 6.2, last sentence: I don't understand this.\r\n\r\nKyzer:\r\n> General guidance on error checking e.g. \"is our current UUID larger than the previous\". If it makes more sense, I can open an issue to give it a label of \"Monotonic Error Checking\" like we have with the rest of the items in that section.",
      "createdAt": "2023-01-20T16:45:50Z",
      "updatedAt": "2023-01-23T22:55:05Z",
      "closedAt": "2023-01-23T22:55:05Z",
      "comments": []
    },
    {
      "number": 47,
      "id": "I_kwDOH6Ln3M5cdM8P",
      "title": "Draft 02: Revise UUID Generator States section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/47",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 6.3, paragraph 2: \"it can always say that the values were\r\nunavailable\" It says this in what way? For example, does it return an exception? Should there be normative language for this?\r\n\r\nKyzer\r\n> This entire section of text is from \"4.2.1.1.  Reading Stable Storage\", \"4.2.1.3.  Writing Stable Storage\", and \"Sharing State Across Processes\"\r\nI agree, the text in this section needs some massaging. \r\nFurther, when I was porting RFC4122 into the new layout this text was somewhat out of place, but I didn't want to drop any text without first consulting the working group.\r\nI will create a tracker to go over that section and make sure it meshes well with the rest of the doc or remove that section completely if it no longer is relevant.",
      "createdAt": "2023-01-20T16:46:50Z",
      "updatedAt": "2023-02-16T22:14:24Z",
      "closedAt": "2023-02-16T22:14:24Z",
      "comments": []
    },
    {
      "number": 48,
      "id": "I_kwDOH6Ln3M5cdNhb",
      "title": "Remove IEEE paragraph from \"uuids that do not identify the host\"",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/48",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "As per Jim not required in this document since we are discouraging centralized registries and IEEE mac addresses.\r\n> One approach is to contact the IEEE and get a separate block of addresses. At the time of writing, the application could be found at https://standards.ieee.org/products-programs/regauth/.",
      "createdAt": "2023-01-20T16:48:31Z",
      "updatedAt": "2023-01-23T22:55:05Z",
      "closedAt": "2023-01-23T22:55:05Z",
      "comments": []
    },
    {
      "number": 49,
      "id": "I_kwDOH6Ln3M5cdNsz",
      "title": "Draft 02: Further Clarify that non-descript node IDs are the preferred method in distributed UUID Generation",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/49",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Jim:\r\n> Section 6.4, last paragraph: \"two aforementioned\": please name them.\r\n\r\nKyzer:\r\n> This sentence should go or at least point to non-descript node identifiers vs both methods. (Another Tracker item)",
      "createdAt": "2023-01-20T16:49:03Z",
      "updatedAt": "2023-02-16T22:14:24Z",
      "closedAt": "2023-02-16T22:14:24Z",
      "comments": []
    },
    {
      "number": 50,
      "id": "I_kwDOH6Ln3M5cdQUr",
      "title": "Discussion: SHA256 UUID Generation",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/50",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "### Topic from Interim:\r\n- How does one create a Name-based UUID if MD5 or SHA1 are deprecated from a library/implementation, not available or otherwise deemed unsecure and cannot be utilized?\r\n\r\n### Restrictions:\r\n- Can't modify v5 to be SHA256. It must remain untouched.\r\n\r\n### Ideas\r\n#### UUIDv9 (SHA256 Based UUID) \r\n- Totally Feasible as per https://github.com/ietf-wg-uuidrev/rfc4122bis/blob/main/editor-files/UUIDv3-\r\nv5-Testing.md?plain=1#L132\r\n- Ties up a new version in a type of UUID that is:\r\n  - \"Not widely utilized or even implemented in many libraries.\" - Kyzer/Brad\r\n  - \"Studies showed name-based UUIDs made up something like 1% of use cases\" - Robert\r\n  - \"Energy in previous draft was on time-based UUIDs and there was little to no discussion on name-based other than the original documents descriptions around these particular UUIDs is confusing\" - Kyzer\r\n\r\n#### Add Text and steer towards v8 as a use case\r\n- Paragraph or sentence that says if SHA256 is desired for any reason then the UUIDv5 steps can be utilized but the version must be incremented to v8 to utilize the experimental, vendor-specific implementation space\r\n- Consensus achieved on this proposal for steering text. Slated for Draft 02",
      "createdAt": "2023-01-20T16:56:40Z",
      "updatedAt": "2023-02-16T22:14:24Z",
      "closedAt": "2023-02-16T22:14:24Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Add Text and steer towards v8 as a use case\r\n\r\n+1",
          "createdAt": "2023-01-20T23:04:08Z",
          "updatedAt": "2023-01-20T23:04:08Z"
        },
        {
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The problem I have using v8 for this is some of the use cases that were discussed for SHA1 and MD5: the desire for two nodes with the same object to be hashed to arrive at the same UUID. While it's possible to do this with v8 by prior arrangement, there must be a reason to have v3 and v5 specify the hash algorithm they use. One reason I can think of is if there is a future transition away from SHA256 to something else and it's important during a transition to know what UUIDs are generated with SHA256 and which with the newer algorithm.",
          "createdAt": "2023-02-01T04:50:10Z",
          "updatedAt": "2023-02-01T04:50:10Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was wondering if we can/should pick some new vX, allocate 4 -bits to hash type, and put SHA256 there.\r\n(I also wonder if there is a way to wedge that into v3 or v5, but there probably isn't)\r\n",
          "createdAt": "2023-02-01T19:41:56Z",
          "updatedAt": "2023-02-01T19:41:56Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcr, @jimfenton: I thought about this a bit over the weekend and here are my thoughts summarized nicely.\r\n\r\n### Deprecate SHA1 and replace it with SHA256 as the \"new\" v5\r\n**Pro**: Avoids new version, removes security considerations around SHA1.\r\n**Cons**: Forces legacy implementations to 'not RFC compliant' if they are old, lack compute. Furthermore, who the application using an existing v5 name may not be able to update the name across the application context very easily. \r\n**Other**: We opted to not replace v1 when we made v6, so I would be hesitant to replace v5 like this.\r\n\r\n### Cram SHA256 into v5\r\n**Pro**: Avoids new version, removes security considerations around SHA1.\r\n**Cons**:  Muddies v5 and can lead to some confusing scenarios where two peers calculate different outputs where one assumed SHA1v5 and one assumed SHA256v5.\r\n**Other**: To clarify, one such hypothetical scenario could be where Alice uses raw inputs to calculate a UUIDv5 and produced sha256-based output as an input to feed into some other application logic for further output computation. (Think some identity-name-based style HMAC like HTTP/SIP use). Then the Bob uses the same inputs, calculates a v5 sha1-based UUIDv5, feeds it into the same algo to further the process. The result is two outputs that differ and who knows what problem that causes. This is all assuming there are no out of band method to say \"use sha256 and not sha1\" etc.\r\n\r\n### Leverage SHA256 with v8\r\n**Pro**: Leaves SHA1 UUIDs and implementations to operate how they have for the past 20 years.\r\n**Cons**: Possibly cause issues when SHA256 v8 co-exist with other UUIDv8s? Personally I don't think that is an issue; if we are doing name-based UUIDs in v8 there is likely some application logic shared between systems to know what algo to use in the first place (sha256 or some other like sha384 or even some next-gen quantum crypto hash algos). \r\n**Other**: To further clarify, the overlap of some other specific v8 time-based algo, some name-based algo or even that one guy who creates UUIDs that only contain readable words are not a problem. This is because in the grand scheme of the application context this use case for v8 likely wouldn't overlap or really inhibit another v8 implementations using them in some other manner. Basically UUIDv8 are really good within your application but are not guaranteed to the greater world by their design.\r\n\r\n### Allocate v9 for SHA256\r\n**Pro**: Removes security considerations around SHA1 (can discourage v5 use and point v3 and v5 at v9). No ambiguity about usage.\r\n**Cons**: Likely to not be implemented very widespread, ties up a version (0 and 10-15 would be the only ones left). What do we do when somebody wants to use SHA384 or some some next-gen quantum crypto hash algos? Seems like a slippery slope I would like to avoid.",
          "createdAt": "2023-02-06T15:19:44Z",
          "updatedAt": "2023-02-06T15:19:44Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Kyzer Davis ***@***.***> wrote:\n    > ### Allocate v9 for SHA256\n\nAllocate v9 for all-future hashes, with a hash-subtype.\n\n",
          "createdAt": "2023-02-06T17:41:22Z",
          "updatedAt": "2023-02-06T17:41:22Z"
        },
        {
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@mcr That's also the direction I was thinking, although I don't have any first-hand knowledge on how these UUID versions are used.",
          "createdAt": "2023-02-06T17:48:31Z",
          "updatedAt": "2023-02-06T17:48:31Z"
        },
        {
          "author": "ramsey",
          "authorAssociation": "NONE",
          "body": "@mcr @jimfenton I came here to say the same thing. Perhaps some set of bits can be allocated as a hash ID. We would need to create a registry of hash IDs, and depending on the number of bits allocated for the hash ID, we'd be limiting the number of future hashes that could be added to the registry. In practice, this might never become an issue.",
          "createdAt": "2023-02-06T20:19:35Z",
          "updatedAt": "2023-02-06T20:19:35Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "One possible approach I'd suggest:\r\n\r\n### Predefine hash algorithm UUIDs and prepend one to name space ID and name\r\n\r\n```python\r\nimport hashlib\r\nimport uuid\r\n\r\n\r\n# predefined by RFC 4122\r\nNAMESPACE_DNS = uuid.UUID(\"6ba7b810-9dad-11d1-80b4-00c04fd430c8\")\r\n\r\n# predefined by new RFC (UUIDv4s I just made up for example)\r\nALGORITHM_SHA256 = uuid.UUID(\"3fb32780-953c-4464-9cfd-e85dbbe9843d\")\r\nALGORITHM_SHA512 = uuid.UUID(\"e6800581-f333-484b-8778-601ff2b58da8\")\r\n\r\n\r\n# concatenate hash_algorithm_uuid + namespace_uuid + name; then hash\r\nsha256 = hashlib.new(\"sha256\")\r\nsha256.update(ALGORITHM_SHA256.bytes)\r\nsha256.update(NAMESPACE_DNS.bytes)\r\nsha256.update(b\"example.com.\")\r\nprint(\"SHA-256:\", sha256.hexdigest()[0:32], \"(truncated)\")\r\n\r\n# ditto\r\nsha512 = hashlib.new(\"sha512\")\r\nsha512.update(ALGORITHM_SHA512.bytes)\r\nsha512.update(NAMESPACE_DNS.bytes)\r\nsha512.update(b\"example.com.\")\r\nprint(\"SHA-512:\", sha512.hexdigest()[0:32], \"(truncated)\")\r\n\r\n# output:\r\n# SHA-256: 564315c658dc181edb907cfa7d55605b (truncated)\r\n# SHA-512: b096e1610da091aa73cdfe4d1132a5aa (truncated)\r\n```\r\n\r\nThis approach ensures that the inputs to hash algorithms are unique per algorithm no matter what the namespace and name are, though such consideration could be meaningless for collision resistance because different hash algorithms are expected to produce very different sequences of bytes.\r\n\r\nThis approach doesn't allow us to identify the hash algorithm used by a given name-based UUID, but I'm not convinced that such reverse engineering is really necessary. It is anyway not possible to reproduce a name-based UUID without knowledge of the namespace ID and the original name, and with such knowledge, it is quite easy to determine the hash algorithm by trying all the few common algorithms. For the same reason, I am skeptical about allocating dedicated hash ID bits in the precious 128-bit space, especially when we have a different idea to guarantee uniqueness.\r\n",
          "createdAt": "2023-02-07T00:20:02Z",
          "updatedAt": "2023-02-07T00:20:02Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "What @LiosK works for me.  I just think that we will get pushback if we don't provide a way to use newer hashes in a deterministic way.  I'm unclear what version would be used for the above approach.",
          "createdAt": "2023-02-07T10:06:53Z",
          "updatedAt": "2023-02-07T10:06:53Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Although I don't have a strong opinion here, I believe a new name-based scheme is not worth a new version and should stay in the v8 because I'd totally agree with the points quoted by Kyzer:\r\n\r\n> - \"Not widely utilized or even implemented in many libraries.\" - Kyzer/Brad\r\n> - \"Studies showed name-based UUIDs made up something like 1% of use cases\" - Robert\r\n> - \"Energy in previous draft was on time-based UUIDs and there was little to no discussion on name-based other than the original documents descriptions around these particular UUIDs is confusing\" - Kyzer\r\n\r\nA standard makes sense only when it coordinates multiple implementations to interoperate with each other. It might logically look flawed to define deprecated algorithm-based v3 and v5 only, but, if there are few people wishing for an updated name-based scheme, it wouldn't be really helpful to introduce a new standard just to fix the _flaw_.\r\n\r\nPlus, v3 and v5 used to be the only mechanisms that could incorporate application-specific ID (name) schemes into the UUID space, but now we have v8 and can include whatever application-specific information in a UUID. I'd anticipate fewer use cases of v3 and v5 after the introduction of v8.\r\n\r\nI'm also concerned about the inactive discussion so far over name-based schemes. I'm not even sure if truncating hash digests is a safe, secure, and valid approach to produce a universally unique identifier.\r\n\r\nAnyway, we can perhaps add the discussion here to the best practice section and see if new name-based practices emerge.",
          "createdAt": "2023-02-07T12:44:57Z",
          "updatedAt": "2023-02-07T12:44:57Z"
        },
        {
          "author": "ramsey",
          "authorAssociation": "NONE",
          "body": "> I'm not even sure if truncating hash digests is a safe, secure, and valid approach to produce a universally unique identifier.\r\n\r\nI've often wondered this about v5. Introducing even longer hashes probably stands a greater chance of seeing repeating characters at the beginning of the hash, especially with the truncation involved to fit within 128 bits, though I'm no expert on hashing algorithms.",
          "createdAt": "2023-02-07T15:14:42Z",
          "updatedAt": "2023-02-07T15:14:42Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't object to v3/v5: they were in rfc4122, and were current at the time.\r\nBut, we need to be clear that there is a way to use newer hashes in a deterministic way.  @LiosK 's suggestion, as a v8 method works for me.. Please just add two paragraphs somewhere about how to do that.  Not sure we need python code, but I don't object to it.",
          "createdAt": "2023-02-07T17:25:45Z",
          "updatedAt": "2023-02-07T17:25:45Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Just caught up on the thread. \r\n\r\nLet me take a pass tomorrow at implementing some text around what @LiosK discussed so we can add some \"best practice\" logic to future hash based UUIDs in v8 bit space.\r\n\r\nAlso, @ramsey, totally agree. SRTP went with an approach back in the day of truncating the SHA to 32 or 80 length for the early SRTP Crypto Suites and they updated that when they added new algos: https://www.rfc-editor.org/rfc/rfc7714#section-13.2\r\nSomewhat unrelated to the context but just one such example that comes to mind. \r\n\r\nPerhaps when I get back to `UUID Long` we can provide an alternative which do not need to be truncated:\r\nhttps://uuid6.github.io/new-uuid-encoding-techniques-ietf-draft/draft-00/#name-uuid-long",
          "createdAt": "2023-02-07T19:20:05Z",
          "updatedAt": "2023-02-07T19:24:05Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "By the way, it's interesting that [FIPS 180-4](https://csrc.nist.gov/publications/detail/fips/180/4/final) (SHA-1 and SHA-2 standard) explicitly permits to take leftmost bits of a message digest:\r\n\r\n> Some application may require a hash function with a message digest length different than those provided by the hash functions in this Standard. In such cases, a truncated message digest may be used, whereby a hash function with a larger message digest length is applied to the data to be hashed, and the resulting message digest is truncated by selecting an appropriate number of the leftmost bits. For guidelines on choosing the length of the truncated message digest and information about its security implications for the cryptographic application that uses it, see SP 800-107 [SP 800-107].\r\n\r\nI'm not sure if the same discussion applies to SHA-3 as well. Plus, [FIPS 180-4 is currently under review for revision](https://csrc.nist.gov/News/2022/proposal-to-revise-fips-180-4-secure-hash-standard), and [some public comments expressed concern about truncation](https://csrc.nist.gov/csrc/media/projects/crypto-publication-review-project/documents/initial-comments/fips180-4-initial-public-comments-2022.pdf). So, this section of FIPS 180-4 might not survive in FIPS 180-5, but probably we can find some useful discussion about digest truncation around FIPS 180-4 resources.\r\n\r\nEdit: Perhaps, we should also take a look at [SP 800-90A](https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final) to deep dive into name-based schemes. If we can derive 122-bit random (statistically independent and unbiased) data from a name in a deterministic manner, then we can construct a UUID from the random bits. SP 800-90A discusses deterministic random bit generators (DRBGs) and SHA-1/2 functions as building blocks of DRBGs.",
          "createdAt": "2023-02-08T11:28:21Z",
          "updatedAt": "2023-02-08T13:04:09Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "My preference: Cite that NIST [SP 800-90A](https://csrc.nist.gov/publications/detail/sp/800-90a/rev-1/final) document as another resource for using random in applications properly in our later sections.\r\n\r\n---\r\n\r\nOn the FIPS180-4 comment: We could cite at least FIPS 180-4 as something that allows truncation at least in those versions. If they don't want to truncate guide towards v8 (which also covers us if they disallow truncating down the road.) ",
          "createdAt": "2023-02-08T15:33:50Z",
          "updatedAt": "2023-02-08T15:33:50Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Oh, I didn't mean the RFC should reference SP 800-90A. I was just like saying: if we were to develop a new name-based scheme seriously, we would have to prove that the new scheme guaranteed the universal uniqueness of the outputs, and the NIST doc would be helpful for that.\r\n\r\nAt a glance, SP 800-90A seems to rely on truncated hash digests as a source of random (i.e., statistically independent and unbiased) sequences of bits. If so (I mean, if each SHA function produces leading 122 bits in a statistically independent and unbiased manner), the approach I suggested previously will produce universally unique IDs even if it truncates digests and mixes the results from multiple SHA functions in one 128-bit ID space.",
          "createdAt": "2023-02-08T18:50:51Z",
          "updatedAt": "2023-02-08T18:50:51Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I pushed up https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/83d95da3418a92a13dfa5222c30795244f24f565\r\n\r\nThis contains:\r\n- Forward reference to best practices section on how to actually create one of these values\r\n- A quick comment on name space best practice to hit #53 topic to allow implementers to allow custom input rather than just the ones we put have in the appendix.\r\n- A section on how to create a v8 UUID with hashspace+namespace+name and desired hash of choice.\r\n- An appendix with every modern SHA2/SHA3/SHAKE algo with a random v4 UUID allocated as a hashspace  (md5 and sha1 omitted)\r\n- A name-based v8 test vector for SHA2-256 hashspace + DNS namespace +  www.example.com\r\n- Renamed old v8 test vector to be time-based to better distinguish these two.\r\n\r\nTesting:\r\n- Used my awful bash script.\r\n- A delta of @LiosK python code to use input of `www.example.com` rather than `example.com.` to be consistent with the MD5 and SHA1 test vectors. \r\n  - I also changed the `bytes(\"www.example.com\", \"utf-8\")` since that is what the official [python library](https://github.com/python/cpython/blob/main/Lib/uuid.py#L728) does although I saw not observable difference.\r\n- Those tests are in the `UUIDv3-v5-Testing.md` file also in the commit.\r\n- Both output the same starting sha256 which is the only item I was trying to verify.",
          "createdAt": "2023-02-09T20:56:20Z",
          "updatedAt": "2023-02-09T20:56:20Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks awesome!\r\n\r\nCould sound obvious, but I think we should add some clarifying text to the Some Hash Space IDs section saying like when using SHAKE_128 or SHAKE_256, implementations must extract at least 128 bits for a digest, because these variable length algorithms may technically produce a digest shorter than 128 bits.",
          "createdAt": "2023-02-10T00:26:46Z",
          "updatedAt": "2023-02-10T00:26:46Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK, \r\n\r\nUnderstood, I was not aware they are variable rate!\r\nI totally missed that last night looking at the SHA table here:\r\nhttps://en.wikipedia.org/wiki/Secure_Hash_Algorithms\r\n\r\nEdit, updated as per https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/60/commits/b094dfc0f75f53d8f3d63f9daccb8a3e3614959f",
          "createdAt": "2023-02-10T14:34:06Z",
          "updatedAt": "2023-02-10T14:55:48Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Question from @jimfenton on Interim: \r\n> Should we remove \"or larger?\" \r\n> Does SHAKE-128 output of 128 differ from SHAKE-128 with output of 256\"\r\n\r\nDraft 02 Proposed Text:\r\n> An important note for secure hashing algorithms that produce variable rate outputs, such as those found in SHAKE, the output hash MUST be 128 bits or larger.\r\n\r\n### Testing\r\nThe first 128 bits that we are about are always the same and do not change even if you request an output of more bits. \r\nSo it can be at or larger and be okay\r\nTested using online tool, with openSSL+bash and cited from the original doc below.\r\nSo we should be okay to keep the text \"the output hash MUST be 128 bits or larger.\"\r\n\r\n### SHAKE-128\r\nhttps://emn178.github.io/online-tools/shake_128.html\r\n```\r\nInput: Hello World\r\n128: 1227c5f882f9c57bf2e3e48d2c87eb20\r\n256: 1227c5f882f9c57bf2e3e48d2c87eb20f382a4b639b54d26f6d595ff3db9064d\r\n```\r\n\r\n```\r\nkydavis@ubuntu-22:~$ echo -n \"Hello World\" | openssl dgst -SHAKE128\r\nSHAKE-128(stdin)= 1227c5f882f9c57bf2e3e48d2c87eb20\r\n```\r\n\r\n### SHAKE-256\r\nhttps://emn178.github.io/online-tools/shake_256.html\r\n```\r\nInput: Hello World\r\n128: 840d1ce81a4327840b54cb1d419907fd\r\n256: 840d1ce81a4327840b54cb1d419907fd1f62359bad33656e058653d2e4172a43\r\n```\r\n\r\n```\r\nkydavis@ubuntu-22:~$ echo -n \"Hello World\" | openssl dgst -SHAKE256\r\nSHAKE-256(stdin)= 840d1ce81a4327840b54cb1d419907fd1f62359bad33656e058653d2e4172a43\r\n```\r\n\r\n### Source:\r\nhttps://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf\r\nA.2 Additional Consideration for Extendable-Output Functions\r\n\r\n> By design, the output length for an XOF does not affect the bits that it produces\r\n\r\n> Consequently, when two different output lengths are\r\nchosen for a common message, the two outputs are closely related: the longer output is an\r\nextension of the shorter output.",
          "createdAt": "2023-02-16T21:24:29Z",
          "updatedAt": "2023-02-16T21:24:29Z"
        }
      ]
    },
    {
      "number": 51,
      "id": "I_kwDOH6Ln3M5cdWNz",
      "title": "Draft 01: Change SHA references in v5 to SHA1",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/51",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "As per Interim Meeting consensus on:\r\nWhere SHA_SOME_FIELD_DESCRIPTOR change to SHA1_SOME_FIELD_DESCRIPTOR\r\n\r\n",
      "createdAt": "2023-01-20T17:14:33Z",
      "updatedAt": "2023-01-20T18:29:02Z",
      "closedAt": "2023-01-20T18:29:02Z",
      "comments": []
    },
    {
      "number": 52,
      "id": "I_kwDOH6Ln3M5cdrEn",
      "title": "Draft 01: Grammar Review",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/52",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Jim provided many changes for grammatical issues.\r\nTracking them via this Issue.",
      "createdAt": "2023-01-20T18:30:00Z",
      "updatedAt": "2023-01-20T18:40:21Z",
      "closedAt": "2023-01-20T18:40:21Z",
      "comments": []
    },
    {
      "number": 53,
      "id": "I_kwDOH6Ln3M5cdzj6",
      "title": "Discussion: Alternative Namespaces for Name-Based UUID",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/53",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "We have DNS, URL, OID, and X500 as per RFC4122: https://www.rfc-editor.org/rfc/rfc4122#appendix-C\r\n\r\n```\r\nDNS  = 6ba7b810-9dad-11d1-80b4-00c04fd430c8\r\nURL  = 6ba7b811-9dad-11d1-80b4-00c04fd430c8\r\nOID  = 6ba7b812-9dad-11d1-80b4-00c04fd430c8\r\nX500 = 6ba7b814-9dad-11d1-80b4-00c04fd430c8\r\n```\r\n\r\nThese are basically \"special case\" UUIDv1 values incremented at the last octet of the `time_low`.\r\nSee: https://stackoverflow.com/questions/7724903/where-do-uuid-namespaces-come-from\r\n\r\nFrom what I can see UUIDv3 and UUIDv5 Libraries will only implement what we define in the spec and do not allow for any inputs other than these four.\r\n\r\nSome common use cases that come to mind for UUIDs where a \"namespace\" may need to be defined are:\r\n- IOT applications\r\n- Database applications\r\n\r\nDoes it make sense to add the following by incrementing to `6ba7b814` to `6ba7b815` and `6ba7b816`\r\n```\r\nIOT = 6ba7b815-9dad-11d1-80b4-00c04fd430c8\r\nDB  = 6ba7b816-9dad-11d1-80b4-00c04fd430c8\r\n```",
      "createdAt": "2023-01-20T19:05:39Z",
      "updatedAt": "2023-02-16T22:14:25Z",
      "closedAt": "2023-02-16T22:14:25Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A little bit confused because IOT or DB doesn't look like a \"namespace\" (neither does X500 though). I think each IOT/DB/whatever application should generate a UUID and use it as its own application-specific namespace ID. For example:\r\n\r\n```python\r\nDB_APP_A_USER_ID_SPACE = \"c8158cdd-8ad5-477c-ab51-57703a54d286\"  # v4 I made up just now\r\nDB_APP_B_USER_ID_SPACE = \"a79c6917-619f-4e8c-abcf-170a6116878d\"  # ditto\r\n\r\nuuidv5_a = gen_uuidv5(name_space_id=DB_APP_A_USER_ID_SPACE, name=\"LiosK\")\r\nuuidv5_b = gen_uuidv5(name_space_id=DB_APP_B_USER_ID_SPACE, name=\"LiosK\")\r\n```\r\n\r\nA predefined namespace ID that might be shared by multiple applications/namespaces doesn't seem useful here.",
          "createdAt": "2023-01-21T01:28:20Z",
          "updatedAt": "2023-01-21T01:28:20Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK, while that should be true, the point I was making is that almost no library implements a \"generic enter your own namespace\" option. Where most are hardcoded to whatever is in RFC4122.\r\n\r\nThis at least gives a few more options, although probably not needed at all. I just wanted to at least bring it up while revising the spec.",
          "createdAt": "2023-01-23T21:09:15Z",
          "updatedAt": "2023-01-23T21:09:15Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I opted to add some text around the topic of allowing custom inputs for namespace rather than JUST what is in the document without adding any new items.",
          "createdAt": "2023-02-09T20:57:33Z",
          "updatedAt": "2023-02-09T20:57:33Z"
        }
      ]
    },
    {
      "number": 55,
      "id": "I_kwDOH6Ln3M5coA9o",
      "title": "Draft 02: Appendix B, consistent naming",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/55",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Need to change to \"Example of a UUIDvX Value\" some are missing an A\r\n```\r\nAppendix B.  Test Vectors\r\nB.1.  Example of UUIDv1 Value\r\nB.2.  Example of UUIDv3 Value\r\nB.3.  Example of UUIDv4 Value\r\nB.4.  Example of UUIDv5 Value\r\nB.5.  Example of a UUIDv6 Value\r\nB.6.  Example of a UUIDv7 Value\r\nB.7.  Example of a UUIDv8 Value\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2023-01-23T23:25:49Z",
      "updatedAt": "2023-02-16T22:14:25Z",
      "closedAt": "2023-02-16T22:14:25Z",
      "comments": []
    },
    {
      "number": 56,
      "id": "I_kwDOH6Ln3M5coBUM",
      "title": "Draft 02: Remove duplicate ABNF from IANA considerations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/56",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "I thought I did this in Draft 01 but I believe I stashed my changes while fixing some merge conflicts. \r\nIANA ABNF should just refer to section 4 ABNF and we can reduce some verbiage in that template as per January Interim meeting.",
      "createdAt": "2023-01-23T23:27:45Z",
      "updatedAt": "2023-02-16T22:14:25Z",
      "closedAt": "2023-02-16T22:14:25Z",
      "comments": []
    },
    {
      "number": 57,
      "id": "I_kwDOH6Ln3M5coCjC",
      "title": "Draft 02: Monotonic Error Checking missing newline",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/57",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Markdown template is wrong, newline is missing to match the other min-sections styled in a specific way within this section.",
      "createdAt": "2023-01-23T23:34:47Z",
      "updatedAt": "2023-02-16T22:14:26Z",
      "closedAt": "2023-02-16T22:14:26Z",
      "comments": []
    },
    {
      "number": 59,
      "id": "I_kwDOH6Ln3M5dAc6p",
      "title": "Draft 02: Change md5_high in SHA1 section to sha1_mid",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/59",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "```\r\nsha1_mid:\r\n12 more bits of the layout consisting of the least significant, right-most 12 bits of 16 bits immediately following md5_high from the computed SHA1 value.\r\n```\r\n\r\n```\r\nsha1_mid:\r\n12 more bits of the layout consisting of the least significant, right-most 12 bits of 16 bits immediately following sha1_high from the computed SHA1 value.\r\n```",
      "createdAt": "2023-01-27T20:34:19Z",
      "updatedAt": "2023-01-31T23:05:26Z",
      "closedAt": "2023-01-31T23:05:26Z",
      "comments": [
        {
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "WG rough consensus isn't needed to correct an obvious cut-and-paste error like this. Go ahead and fix.",
          "createdAt": "2023-01-27T20:39:33Z",
          "updatedAt": "2023-01-27T20:39:33Z"
        }
      ]
    },
    {
      "number": 61,
      "id": "I_kwDOH6Ln3M5eF87D",
      "title": "Draft 02: Clean up text in UUIDs that Do Not Identify the Host",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/61",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "Just needs a bit ironed out, the current text is a copy from 4122 similar to #47 \r\n\r\nMaybe cite a reference to the Multicast bit too?",
      "createdAt": "2023-02-09T21:04:40Z",
      "updatedAt": "2023-02-16T22:14:26Z",
      "closedAt": "2023-02-16T22:14:26Z",
      "comments": []
    },
    {
      "number": 62,
      "id": "I_kwDOH6Ln3M5eqzGF",
      "title": "Delete Sample Code Appendix",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/62",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "As per Interim not required and changing v1-5 to decouple from multiplexed fields is a fair ammount of work opening us to potential errata.\r\n\r\nTest Vectors will remain.",
      "createdAt": "2023-02-16T19:54:20Z",
      "updatedAt": "2023-02-16T22:14:27Z",
      "closedAt": "2023-02-16T22:14:27Z",
      "comments": []
    },
    {
      "number": 64,
      "id": "I_kwDOH6Ln3M5hCKuX",
      "title": "Draft 03: Fix idnits errors and warnings",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/64",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "- 5 Errors\r\n- 10 Warnings\r\n\r\nhttps://author-tools.ietf.org/",
      "createdAt": "2023-03-16T17:28:40Z",
      "updatedAt": "2023-04-11T13:53:57Z",
      "closedAt": "2023-04-11T13:53:57Z",
      "comments": []
    },
    {
      "number": 65,
      "id": "I_kwDOH6Ln3M5hCMeS",
      "title": "Draft 03: Add other Hash Abbreviations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/65",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Jim:\r\n\r\n> Section 3.2 defines MD5 and SHA1, but not any of the other hashes referenced in the document.",
      "createdAt": "2023-03-16T17:32:45Z",
      "updatedAt": "2023-04-11T13:53:57Z",
      "closedAt": "2023-04-11T13:53:57Z",
      "comments": []
    },
    {
      "number": 66,
      "id": "I_kwDOH6Ln3M5hCOVF",
      "title": "Draft 03: Normalize SHA abbreviation formats",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/66",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "With or without dash:\r\n- SHA1\r\n- SHA-1\r\n\r\nFIPS documents use dash, will normalize our document to the same.",
      "createdAt": "2023-03-16T17:36:24Z",
      "updatedAt": "2023-04-11T13:53:58Z",
      "closedAt": "2023-04-11T13:53:58Z",
      "comments": []
    },
    {
      "number": 67,
      "id": "I_kwDOH6Ln3M5hCQEN",
      "title": "Draft 03: Fix \"integral numbers of octets\" verbiage",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/67",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Before: \r\n> To minimize confusion about bit assignments within octets and among differing versions, the UUID record definition is defined only in terms of fields that are integral numbers of octets. \r\n\r\nAfter:\r\n> To minimize confusion about bit assignments within octets and among differing versions, the UUID record definition is provided as a a grouping of fields within bit layout consisting four octets to a row.\r\n\r\nEdit: Updated grammar as per @cbandy comment.",
      "createdAt": "2023-03-16T17:41:34Z",
      "updatedAt": "2023-04-11T13:53:58Z",
      "closedAt": "2023-04-11T13:53:58Z",
      "comments": [
        {
          "author": "cbandy",
          "authorAssociation": "NONE",
          "body": "\"is provides as a a grouping\" \u2192 \"is provided as a grouping\", perhaps?\r\n\r\n\"consisting four octets octets\" \u2192 \"consisting of four octets\", perhaps?",
          "createdAt": "2023-03-18T16:01:00Z",
          "updatedAt": "2023-03-18T16:01:00Z"
        }
      ]
    },
    {
      "number": 68,
      "id": "I_kwDOH6Ln3M5hCSZR",
      "title": "Draft 03: Move Community Considerations to Introduction",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/68",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Fits nicely in between first and second paragraph to remove this non-standard section.",
      "createdAt": "2023-03-16T17:48:25Z",
      "updatedAt": "2023-04-11T13:53:59Z",
      "closedAt": "2023-04-11T13:53:59Z",
      "comments": []
    },
    {
      "number": 69,
      "id": "I_kwDOH6Ln3M5hCTZQ",
      "title": "Draft 03: Reference all Hash Algorithms.",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/69",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "",
      "createdAt": "2023-03-16T17:51:02Z",
      "updatedAt": "2023-04-11T13:53:59Z",
      "closedAt": "2023-04-11T13:53:59Z",
      "comments": []
    },
    {
      "number": 70,
      "id": "I_kwDOH6Ln3M5hCT36",
      "title": "Draft 03: Transpose UUID Namespaces to match UUID Hashspaces",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/70",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "Remove the C structs and make them text.",
      "createdAt": "2023-03-16T17:52:14Z",
      "updatedAt": "2023-04-11T13:54:00Z",
      "closedAt": "2023-04-11T13:54:00Z",
      "comments": []
    },
    {
      "number": 72,
      "id": "I_kwDOH6Ln3M5h3DZl",
      "title": "provide definition for uuid_t, or do not use it",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/72",
      "state": "CLOSED",
      "author": "mcr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "duplicate"
      ],
      "body": "We either need to put the typedef back in for uuid_t, or we need to make just write the uuid like we do in appendix B.\r\n",
      "createdAt": "2023-03-27T10:14:31Z",
      "updatedAt": "2023-04-05T13:26:16Z",
      "closedAt": "2023-04-05T13:26:15Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yep, recorded under #70 where I will make it all text and remove the C code.",
          "createdAt": "2023-03-27T19:49:53Z",
          "updatedAt": "2023-03-27T19:49:53Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "I_kwDOH6Ln3M5izEQN",
      "title": "Draft 03: Remove URN from title",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/73",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "The URN in the title is out of place as the entire document defines UUIDs and their many usages. URN is one such (small) part of the greater document.\r\n",
      "createdAt": "2023-04-06T14:40:05Z",
      "updatedAt": "2023-04-11T13:54:01Z",
      "closedAt": "2023-04-11T13:54:01Z",
      "comments": []
    },
    {
      "number": 74,
      "id": "I_kwDOH6Ln3M5izH9j",
      "title": "Draft 03: Move some Normative Reference to Informative",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/74",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "",
      "createdAt": "2023-04-06T14:48:09Z",
      "updatedAt": "2023-04-11T13:54:01Z",
      "closedAt": "2023-04-11T13:54:01Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Unsure how to handle these in IDNITS checks:\r\n```\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'C309'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'C311'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'FIPS180-4'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'FIPS202'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'RANDOM'\r\n  -- Possible downref: Non-RFC (?) normative reference: ref. 'X667'\r\n```",
          "createdAt": "2023-04-06T15:57:38Z",
          "updatedAt": "2023-04-06T15:57:38Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "I_kwDOH6Ln3M5izmYM",
      "title": "Draft 03: Downgrade MUST NOT to SHOULD NOT for guessability of UUIDs",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/75",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Acheived"
      ],
      "body": "> Section 9, \u201cImplementations MUST NOT assume that UUIDs are hard to guess.\u201d \r\n> This would mean that it\u2019s not permissible to use a randomly generated UUID for something like a session cookie. \r\n> On the other hand, NIST currently considers a random value generated \r\n> from a CSPRNG with a security  strength of at least 112 bits to be \r\n> effectively unguessable (see SP 800-131A), and a version 4 UUID meets that requirement. This prohibition seems a little strong.\r\n\r\nThis is the RFC4122 verbiage but we could downgrade to a SHOULD NOT. \r\n",
      "createdAt": "2023-04-06T16:05:33Z",
      "updatedAt": "2023-04-11T13:54:02Z",
      "closedAt": "2023-04-11T13:54:02Z",
      "comments": [
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that if someone needs something that is hard to guess, they need to be responsible for making sure.\r\nI think that the point of this disclaimer is that not all UUIDs are hard to guess, and we don't want people confused.",
          "createdAt": "2023-04-06T19:21:10Z",
          "updatedAt": "2023-04-06T19:21:10Z"
        }
      ]
    },
    {
      "number": 83,
      "id": "I_kwDOH6Ln3M5lt0-8",
      "title": "List of remarks of current draft 03",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/83",
      "state": "CLOSED",
      "author": "ben221199",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I have read the whole specification from top to bottom and this are my remarks with the current version of the draft:\r\n\r\n---\r\n\r\n1.\t> P. Leach\r\n\t> Microsoft\r\n\r\n\tI tried to contact P. Leach to talk about UUID, but his mail paulle@microsoft.com doesn't work anymore, as it seems. Is he involved in the project? Else, should he be removed from the header?\r\n\r\n---\r\n\r\n2.\t> This specification defines a Uniform Resource Name namespace for UUIDs (Universally Unique IDentifiers), also known as GUIDs (Globally Unique IDentifiers).\r\n\r\n\tI would write this in another way, because the RFC is in the first place a RFC about UUIDs, not about URNs, like RFC 4122. I would write something like this:\r\n\t> This specification defines the UUIDs (Universally Unique IDentifiers) and it's a Uniform Resource Name namespace. UUIDs are also known as GUIDs (Globally Unique IDentifiers).\r\n\r\n\tAlso:\r\n\t> The information here is meant to be a concise guide for those wishing to implement services using UUIDs, as URNs [RFC8141], or otherwise.\r\n\r\n\tTo:\r\n\t> The information here is meant to be a concise guide for those wishing to implement services using UUIDs, eventually in combination with URNs [RFC8141] or other.\r\n\r\n---\r\n\r\n3.\t> 3 .   [Snowflake] by Twitter\r\n\r\n\tMaybe worth noting that Discord uses the same technique, but with a changed start date. Not 1970, but 2015.\r\n\r\n---\r\n\r\n4.\tMake a clear difference between wire formats and representation formats, like in Section 4. In wire format we have the families/variants and versions. In the representation format we have the old Apollo Computer format, but also the hex-and-dash format, the format without dashes and the hex-and dash format with `{` and `}`. Maybe, in the near future more representation formats will be designed, but those will not conflict with the wire format and vice versa. In case of URN, only hex-and-dash is allowed. I think it is important to list all representation formats I just called and which one (the hex-and-dash one), is a recommended. Don't talk about variants, families and versions in the section about representation formats.\r\n\r\n---\r\n\r\n5.\tAs mentioned in (4), I would rename Section 4 to `Representation Format` and create a new Section 5 with `Wire format`. Sections like 4.1 will now be Section 5.1, etc.\r\n\r\n---\r\n\r\n6.\tI talked about the variant field in #16, because at the moment it is a mess of 3 bits. In case of versions we have a clear view of what we are talking about: just 4 bits with a range from 0 to 15, of which in RFC 4122 the versions 1 to 5 were used. However, for variants this is not the case. In my issue I stated to use 8 bits, while some others proposed 4 bits. Why 8 bits? Because the legacy UUID also used 8 bits. So, in that case implementing libraries for UUIDs will become more easy to build and to understand.\r\n\r\n---\r\n\r\n7.\tMake it loud and clear that versions are ONLY a invention for the `10x` variant (see how ugly I have to name my variant at the moment). I have seen implementations of UUID libraries that messed up variants and versions, because they didn't understand RFC 4122.\r\n\r\n---\r\n\r\n8.\t> As such the definition of these UUIDs are outside the scope of this specification.\r\n\r\n\tI would suggest trying to define as much as possible, including UUID version 2.\r\n\r\n---\r\n\r\n9.\t> 5.10.  Max UUID\r\n\r\n\tI still prefer Omni UUID. \ud83d\ude05\r\n\r\n---\r\n\r\n10.\t> For compatibility with earlier specifications, note that this document uses the unicast/multicast bit, instead of the arguably more correct local/global bit.\r\n\r\n\tBecause MAC addresses with the local/global bit set or not are both possible in a network. This is not the case with the unicast/multicast bit. One node cannot have a MAC address that multicasts to multiple nodes.\r\n\r\n---\r\n\r\n11.\t> 7 .  IANA Considerations\r\n\r\n\tWhat does this mean? I understand that listing UUIDs themselves is not useful, but listing variants/families and versions would be useful for preventing conflicting implementations. In my case, I would reconsider the decision.\r\n\r\n---\r\n\r\n12.\t> Implementations SHOULD NOT assume that UUIDs are hard to guess. Foe example, they MUST NOT be used as security capabilities (identifiers whose mere possession grants access). Discovery of predictability in a random number source will result in a vulnerability.\r\n\r\n\tTypo.\r\n\r\n---\r\n\r\n13.\tTell about the Apollo variant, found here: https://opensource.apple.com/source/CF/CF-299.35/Base.subproj/uuid.c.auto.html.\r\n\r\n---\r\n\r\n14.\tTell about the Microsoft variant, if Paul Leach is still involved.\r\n\r\n---\r\n\r\nThanks for reading. I'm curious about your findings.",
      "createdAt": "2023-05-11T20:35:29Z",
      "updatedAt": "2023-05-23T20:50:01Z",
      "closedAt": "2023-05-23T16:39:24Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "1. We decided to keep the original authors as we are re-using some of their text.\r\n2. Yeah, that is a good suggestion.\r\n3. I wasn't aware of Discord when I did my research a few years ago. Not sure it is worth adding extra references to that since we currently have enough to drive the point home\r\n4. Makes sense to add the UUID layout enclosed by curly brackets if that is in use out there in modern implementations. Do you have anything to cite other than the legacy UUID usage?\r\n5. Not sure I agree.\r\n6. _See Below._\r\n7. Can I change the table to \"The variant mapped to the versions specified in this document.\"?\r\n8. _See Below._\r\n9. :)\r\n10. I am not sure I follow what should be changed?\r\n11. I believe the main point is we don't need an IANA listing where this document can serve as the purpose. When there are many IETF documents on a given topic; I see more value in a centralized IANA registry summarizing the disperse documents.\r\n12. \"Foe example\" thanks, many have missed that one!\r\n13. Yeah, easy enough to cite it in some way perhaps in the variant table row 1.\r\n14. _See Below_\r\n\r\n---\r\n\r\n6, 8, 14.\r\nI do not believe the IETF wanted this document detail every UUID in every variant space outside of variant 10x. \r\nIf there are resources we can cite them like we do for Version 2, and the new NCS one posted above.\r\nI will defer to the WG chairs @mcr and @jimfenton since this would add significant segments of text, push back the deadlines by a significant ammount and introduce fragmented sources of information on those UUID implementations outside of IETFs span of control. Further we risk something getting out of sync assuming one of those decide to update since the RFC isn't the authoritative source of those UUID variant implementations.\r\n\r\nEdit: Just to re-iterate my opinion: I believe that the other legacy UUIDs outside of the `10x` variant should be in a historical/informational type RFC separate from this update to 4122. That is, assuming IETF has interest in compiling and detailing reference specs for those.",
          "createdAt": "2023-05-15T14:22:32Z",
          "updatedAt": "2023-05-15T16:34:52Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Hello Kyzer,\r\n\r\nThanks for your response. My response:\r\n\r\n1.\tOk\r\n2.\tOk\r\n3.\tNo problem if Discord isn't added/mentioned in text, but it is always considerable if it has any added value\r\n4.\tI am aware of the following representation types:\r\n\t- `550e8400-e29b-41d4-a716-446655440000`\r\n\t- `{550e8400-e29b-41d4-a716-446655440000}`\r\n\t- `550e8400e29b41d4a716446655440000`\r\n\t- `34dc23469000.0d.00.00.7c.5f.00.00.00` (Legacy format: https://www.ibm.com/docs/en/aix/7.1?topic=u-uuid-gen-command-ncs)\r\n\t- 128-bit integer (both signed and unsigned)\r\n\t- Binary (just 0 and 1)\r\n5.\tIt doesn't need to be exactly as I proposed, but I think it should be very clear to people that do read the RFC can quickly see that there is a wire format and a representation format and that they aren't necessary dependent on each other. The best way I can imagine is having two top-sections called `Wire format` and `Representation format` (or it could be a first level sub-section).\r\n6.\t*See below.*\r\n7.\tAre you talking about table 2? The name has enough information, but maybe you can change it to: `UUID versions (as subtype for UUID variant 10x) defined by this specification`\r\n8.\t*See below.*\r\n9.\tI'm serious \ud83d\ude02\r\n10.\tThere is a sentence in the specification that tells that the `local/global` would be more logical. However, I explain why they chose the other bit: because multicast addresses cannot exist in a network.\r\n11.\tI think I don't agree on that one. For example, in DNS we have record types. Every RFC that defines a new record type will also be listed by IANA, RFC mentioned in the 4th column: https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml#dns-parameters-4. So, after all, you have a list of all types and the RFC they are defined in. Because of this, you will have no conflicts of using the same number. I think the same is happening with UUIDs. We have RFC 4122 that defines version 1 to version 5. The new specification will redefine those too, but will also define 3 additional versions: version 6, version 7 and version 8. This will look like the following table: ![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/12856904/a1b36012-1045-4d7e-a911-58d4b0555c5b)\r\n12.\tNo problem.\r\n13.\tIf it is somehow mentioned, I think that is at least something. I think it is better to tell about the format, instead of referring to some vague `.c` file.\r\n14.\t*See below.*\r\n\r\n---\r\n\r\n6.\t`v`\r\n8.\t`v`\r\n14.\tIn my opinion there should at least be some RFC that describes all the UUID variants, families, versions and representation formats. If that will be this specification or some other, I don't actually care. I only care about it happening one day. However, I have the feeling that, if make a new document and don't merge the history in the current draft, the historical draft should be released first, because that one tells the basis of UUID, where this draft then is based on. Defering things to IETF is good, so we will know their view on the issue. Keep in mind that if we do publish the historical RFC afterwards, we maybe have to release another RFC in the future that merges current specification and the historical one into one, eventually adding some more variants and versions. I am okay with that too, but maybe is also more work in the end.",
          "createdAt": "2023-05-15T16:53:05Z",
          "updatedAt": "2023-05-15T16:53:05Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@ben221199, majority of these made it into draft 04 around version variant sub-type being for this, some other formats of note, multicast-bit, modification of the abstract.\r\n\r\nI still left out citing legacy/historical versions except for the IBM_NCS format which was a one liner.\r\nI think together we can easily knock those out together as historical/info RFC w/IANA ask after we get this RFC across the finish line. I will whip something up and submit it to you for you to review when I am back from traveling.\r\n\r\nReview what I submitted to IETF under draft 04 and create a _new issue_ if I did not address items  2, 6, 7, 10 and 12 on your list appropriately.",
          "createdAt": "2023-05-23T17:12:59Z",
          "updatedAt": "2023-05-23T17:13:39Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Hi @kyzer-davis,\r\n\r\nThanks for making these changes. I had a look and the changes seemed good to me. Of course I will recreate a new issue when I come across some more improvements.\r\n\r\nI saw about the IBM NCS one. I think it is nicely done, so that people will understand that there are more representation formats. Maybe we have to tell te difference between UUID and GUID too. (Yes, there is a difference. Thanks Microsoft. *sigh*)\r\n\r\nIf you think making a historical RFC is better than merging it into this one, lets go for it. I already started something some months ago: https://github.com/yocto/draft-yocto-uuid.\r\n\r\nReview:\r\n\r\n1.\tFine.\r\n2.\tPerfect.\r\n3.\tI have some ideas about this.\r\n4.\tPerfect. Maybe add something about the difference between UUID and GUID.\r\n5.\tFine. Maybe a task for historical RFC.\r\n6.\tMaybe a task for historical RFC.\r\n7.\tPerfect.\r\n8.\tMaybe a task for historical RFC.\r\n9.\tNO. \ud83d\ude02\r\n10.\tPerfect.\r\n11.\tMaybe a task for historical RFC.\r\n12.\tPerfect.\r\n13.\tMaybe a task for historical RFC.\r\n14.\tMaybe a task for historical RFC.\r\n\r\nMost things are handled or will eventually be handled when having a historical RFC. I will create a new issue with the remaing points and maybe some new things.",
          "createdAt": "2023-05-23T20:47:51Z",
          "updatedAt": "2023-05-23T20:47:51Z"
        }
      ]
    },
    {
      "number": 85,
      "id": "I_kwDOH6Ln3M5l7jXK",
      "title": "Draft 04: Move endianness statement from layout to format section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/85",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> 2) Another remark, about byte order, perhaps the information of byte ordering should be moved from 5.  UUID Layouts to 4. UUID Format\r\nReading the section 4, you wonder about endianness and the info is quite far imho\r\n\r\nFrom: Aur\u00e9lien LAJOIE <orel@melix.net> via mailer.",
      "createdAt": "2023-05-15T13:29:29Z",
      "updatedAt": "2023-05-23T16:39:25Z",
      "closedAt": "2023-05-23T16:39:25Z",
      "comments": []
    },
    {
      "number": 86,
      "id": "I_kwDOH6Ln3M5l_n5q",
      "title": "Limiting size of additional clock precision (method 4) for v7",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(Copied from my email to uuidrev@ietf.org to add a relevant but different topic)\r\n\r\nI would propose to limit the size of Increased Clock Precision (6.2. Monotonicity and Counters: Method 4) to a certain number of bits, say 12 bits, for the UUIDv7 purpose. I really like the idea of the additional clock precision encoded using the fractional representation, but I'd like to point out a potential concern about universal uniqueness and usability.\r\n\r\nThe v7 scheme currently relies on randomness for universal uniqueness. On the other hand, a timestamp is not a source of randomness but is a shared piece of information across multiple generators. The timestamp field provides the universal uniqueness property by relying on the timing of generation, not randomness, so two timestamps collide if two generators generate IDs exactly at the same time, even if they employ picosecond timestamps. In other words, the timestamp and randomness both offer universal uniqueness but through different mechanisms.\r\n\r\nIn my opinion, UUIDv7 is more useful for users if the RFC sticks to the randomness mechanism to guarantee universal uniqueness. If the spec mixes the two mechanisms, then users have to take care of the timing of generations or the configuration of PRNGs depending on the implementation of a UUIDv7 generator, which introduces additional complexity to just get a time-ordered UUID. So, I believe the standard should limit the maximum size of extra clock precision to guarantee that a sufficient bit space is reserved for the randomness field.\r\n\r\nIt would be hard to set an appropriate limitation, but 12 bits might be a good starting point. By limiting the size of method 4 clock precision to 12 bits, we can guarantee the same level of randomness (62 bits) as UUIDv6 while accepting microsecond-precision timestamps. Applications that need finer timestamps are likely to be specialized use cases and should generally resort to UUIDv8.",
      "createdAt": "2023-05-16T03:52:23Z",
      "updatedAt": "2023-05-23T16:39:26Z",
      "closedAt": "2023-05-23T16:39:25Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is it possible to replace the following text in Replace Left-Most Random Bits with Increased Clock Precision (Method 4):\r\n\r\n> Using floating point math, multiply this fraction of a millisecond value by <del>4095</del> and round to an integer result to arrive at a number between 0 and the maximum allowed for the indicated bits which is sorts monotonically based on time.\r\n\r\nWith:\r\n\r\n> Using floating point math, multiply this fraction of a millisecond value by <ins>4096</ins> and round <ins>down (toward zero)</ins> to an integer result to arrive at a number between 0 and the maximum allowed for the indicated bits which is sorts monotonically based on time.\r\n\r\nThe latter logic is expressed in Python as follows:\r\n\r\n```python\r\nsubmsec_float = 0.4567\r\nsubmsec_frac_bin_from_float = int(submsec_float * 0b1_0000_0000_0000)\r\n\r\nassert submsec_frac_bin_from_float == 1870\r\n```\r\n\r\nAnd, it allows the faster integer math computation:\r\n\r\n```python\r\nsubmsec_nsec = 456700  # 0.4567 milliseconds expressed as nanosecond-precision ticks\r\nsubmsec_frac_bin_from_nsec = (submsec_nsec << 12) // 1_000_000\r\n\r\nassert submsec_frac_bin_from_nsec == 1870\r\n```\r\n\r\nThe latter logic is more friendly with the `clock_gettime` C function than the original approach. Plus, the original is less useful in that it requires the floating-point math for rounding.\r\n\r\nPlease also find a quick Rust code that demonstrates a couple of techniques to arrive at the binary fractional representation of a submillisecond timestamp:\r\n\r\n```rust\r\nconst SUBMSEC_SIZE: u64 = 12;\r\nconst SUBMSEC_MASK: u64 = (1 << SUBMSEC_SIZE) - 1;\r\n\r\n// iterate subsecond timestamp ticks of nanosecond resolution over one second, emulating all\r\n// the possible `tv_nsec` values returned by `clock_gettime(3)`\r\nfor tv_nsec in 0u64..1_000_000_000 {\r\n    let _msec = tv_nsec / 1_000_000;\r\n    let submsec = tv_nsec % 1_000_000;\r\n\r\n    // get fractional submsec representation using floating-point math\r\n    let submsec_fraction = submsec as f64 / 1_000_000f64;\r\n    let result_fp = (submsec_fraction * (1 << SUBMSEC_SIZE) as f64).trunc() as u64;\r\n\r\n    // get fractional submsec representation using integer math\r\n    let result_int = (submsec << SUBMSEC_SIZE) / 1_000_000;\r\n    assert_eq!(result_fp, result_int);\r\n\r\n    // get fractional submsec representation directly from `tv_nsec`\r\n    let result_from_nsec = ((tv_nsec << SUBMSEC_SIZE) / 1_000_000) & SUBMSEC_MASK;\r\n    assert_eq!(result_fp, result_from_nsec);\r\n}\r\n```\r\n\r\n**Update**: After further investigation, I now believe the original text is somewhat flawed and must be fixed:\r\n\r\n- The phrase \"round to an integer\" is ambiguous because there are multiple ways to round a floating-point number to an integer (e.g., half to even, half to odd, banker's rounding, and more). The v7 spec must be specific here because two different implementations must produce exactly the same integer from the same submillisecond timestamp to guarantee sortability.\r\n- A ties-to-nearest rounding mode makes the probabilities of producing zero and 4095 (the maximum) be half of other integers in between.",
          "createdAt": "2023-05-16T03:56:13Z",
          "updatedAt": "2023-05-16T13:11:12Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The introduction of Method 4 seems to require some updates to [5.7. UUID Version 7](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#name-uuid-version-7):\r\n\r\n---\r\n\r\n> UUID version 7 also has improved entropy characteristics over versions 1 or 6.\r\n\r\nThis statement in the first paragraph no longer holds unless the size of Method 4 timestamp is limited to 11 bits or less.\r\n\r\n---\r\n\r\n> rand_a:\r\n> 12 bits pseudo-random data to provide uniqueness as per Section 6.8 and/or an optional counter to guarantee additional monotonicity as per Section 6.2.\r\n>\r\n> var:\r\n> (snip)\r\n>\r\n> rand_b:\r\n> The final 62 bits of pseudo-random data to provide uniqueness as per Section 6.8 and/or an optional counter to guarantee additional monotonicity as per Section 6.2.\r\n\r\nThe explanation of rand_a and rand_b has to be updated to accept the Method 4 timestamp. Perhaps, we should add some clarifying text like:\r\n\r\n> The rand_a and rand_b fields, jointly, MUST be filled with a combination of the following subfields, in this order from the most significant bits to the least:\r\n>\r\n> 1.  An OPTIONAL submillisecond timestamp fraction (12 bits at maximum) to utilize extra clock resolution as per Section 6.2 (Method 4).\r\n> 2.  An OPTIONAL counter to guarantee additional monotonicity as per Section 6.2 (Method 1 or 2).\r\n> 3.  Random data to provide uniqueness as per Section 6.8.\r\n",
          "createdAt": "2023-05-19T00:28:50Z",
          "updatedAt": "2023-05-19T00:55:24Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK \r\nRegarding this proposed text:\r\n\r\n> Using floating point math, multiply this fraction of a millisecond value by 4096 and round down (toward zero) to an integer result to arrive at a number between 0 and the maximum allowed for the indicated bits which is sorts monotonically based on time.\r\n\r\nI totally agree, rounding down is better here - more explicit and easier to understand.  I'm 100% good with that change.\r\n\r\nOn the other text changes, my concerns are:\r\n* Language like \"The rand_a and rand_b fields, jointly, MUST be filled with a combination of the following subfields\" I think is too strict.  E.g. if some vendor wants to put some server node ID in here somewhere, we shouldn't explicitly prohibit that if it doesn't interfere with the basic parsing properties (in other words the random part is just random, if the generator wants to do something a bit different lose some entropy in the process - that's up to them - see the Global and Local Uniquess section).\r\n* I don't entirely agree that CSPRNG data is fundamentally going to result in less random data.  Let's say we have 12 bits that are generated with a CSPRNG and 12 bits which are a fraction of a millisecond - is there some mathematical property which says that it is less likely that the CSPRNG values will collide than two IDs will be generated in the exact same instant?  I realize some clocks may have less granularity available, but that's exactly why we want to make the length implementation dependent.  In general, I would be okay with suggesting 12 bits as a recommended length, but I think putting an absolute limit on there is too restrictive. If people want to put more precise clock data in there to express a more specific timestamp, and let's say due to clock granularity problems this reduces entropy, I think this is a tradeoff an implementation should be allowed to make.\r\n\r\nIn terms of workflow on some of these, for specific text changes it might be easier to just do a pull request and you can also link to it here - but that way the exact changes can be discussed and if there is consensus just merged in.\r\n",
          "createdAt": "2023-05-19T04:50:17Z",
          "updatedAt": "2023-05-19T04:50:17Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I totally agree, rounding down is better here\r\n\r\nWill craft a PR for this!\r\n\r\n> Language like \"The rand_a and rand_b fields, jointly, MUST be filled with a combination of the following subfields\" I think is too strict.\r\n\r\nWould propose an alternative wording: \"The rand_a and rand_b fields, jointly, <del>MUST be</del><ins>are</ins> filled with a combination of the following subfields\". It doesn't change a lot, but yeah the overall 5. UUID Layouts section doesn't really employ the MUST verbiage, so v7 should definitely follow that tone.\r\n\r\nHowever, it is questionable whether compliant implementations may embed a node ID in UUIDv7; my understanding is no, they can't. It is not 100% clear because the UUID Layouts section doesn't use the BCP 14 verbiage, but it reads like none of the UUID versions other than v8 accepts a node ID inside the 128-bit space. In the literal sense, 5.4. UUID Version 4 section doesn't preclude to include a timestamp and node ID in it, but I don't think a generator that constructs a UUIDv4 from a 60-bit timestamp and 60-bit node ID is an RFC-compliant generator. Similarly, I don't believe a UUIDv7 MAY contain a node ID. Technically, [6.4. Distributed UUID Generation](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#section-6.4) referred to by [6.7. Global and Local Uniqueness](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#section-6.7) reads \"Implementations that choose to leverage an embedded node id SHOULD utilize UUIDv8.\", but SHOULD here is in effect MUST, I think.\r\n\r\n> I think this is a tradeoff an implementation should be allowed to make.\r\n\r\nI totally agree that the randomness vs. granular timestamp is a trade-off issue. Perhaps, there is no theoretical advantage of one option over the other, but still I believe putting an absolute limit to the timestamp would increase the overall utility of UUIDv7 for general users.\r\n\r\nOnce finalized, v7 will become popular, many implementations will emerge, and many users will use it. As a common ground, it would be helpful if the standard is clear that the uniqueness of UUIDv7 is solely dependent on CSPRNGs and reserves sufficient space for CSPRNG inputs. Then, users just need to pick a compliant library and make sure their CSPRNG is working properly. Otherwise, users have to examine the library before use to understand the source of uniqueness and satisfy all the prerequisites for that specific implementation. This could sound like an extreme, but a standard exists to coordinate implementers and users, so clarifying the responsibility boundary should be helpful. Those who want to utilize a granular timestamp should resort to UUIDv8.\r\n\r\nThis is my personal opinion, and consensus is definitely needed.\r\n\r\nI admit my opinion is somewhat biased by the [recent government scandal in my country](https://www.asahi.com/ajw/articles/14904344), where timestamp collisions caused private information leakage. Microsecond timestamps reportedly collide multiple times in the incident. It is seemingly very difficult to ensure the timestamp granularity across a system. For example:\r\n\r\n- client or server hardware or operating systems might not support granular timestamp\r\n- mice and keyboards operate on a certain timing clock and might transmit users' input at a certain cycle\r\n- routers and network switches store packets in their buffer and might send multiple requests to the server at once\r\n\r\nLearning these cases recently, I feel kind of fearful to rely deeply on timestamps to guarantee uniqueness and randomness.",
          "createdAt": "2023-05-19T14:13:51Z",
          "updatedAt": "2023-05-19T14:13:51Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Once finalized, v7 will become popular, many implementations will emerge, and many users will use it. As a common ground, it would be helpful if the standard is clear that the uniqueness of UUIDv7 is solely dependent on CSPRNGs and reserves sufficient space for CSPRNG inputs. Then, users just need to pick a compliant library and make sure their CSPRNG is working properly. Otherwise, users have to examine the library before use to understand the source of uniqueness and satisfy all the prerequisites for that specific implementation. This could sound like an extreme, but a standard exists to coordinate implementers and users, so clarifying the responsibility boundary should be helpful. Those who want to utilize a granular timestamp should resort to UUIDv8.\r\n> \r\n\r\nI completely agree with you here.\r\n",
          "createdAt": "2023-05-19T16:43:07Z",
          "updatedAt": "2023-05-19T16:43:07Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Approved the PRs for this one so it should be good to close.\r\nEdit: I am changing method 4 to method 3 as per your note on that #91 PR.\r\nWill get it here as I address the last few issues :)",
          "createdAt": "2023-05-23T14:56:17Z",
          "updatedAt": "2023-05-23T15:00:16Z"
        }
      ]
    },
    {
      "number": 87,
      "id": "I_kwDOH6Ln3M5mGUPI",
      "title": "Remove Re-randomize Until Monotonic (Method 3) section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/87",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Reference: [6.2. Monotonicity and Counters](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#name-monotonicity-and-counters)\r\n\r\nI believe we don't need to (or simply, should not) give prominence to the Re-randomize Until Monotonic approach as Method 3, because it does not have a distinctive benefit over the other methods. To me, Method 3 doesn't seem to make sense.\r\n\r\nFirstly, the Method 3 approach is perfectly legal without this section along with Method 1 as per Fixed-Length Dedicated Counter Seeding:\r\n\r\n> When utilizing a randomly seeded counter alongside Method 1, the random value MAY be regenerated with each counter increment without impacting sortability.\r\n\r\nThe Fixed-Length Dedicated Counter Length section suggests limiting the counter length to 42 bits but does not forbid utilizing the entire random field as a counter. Method 3 is allowed under Method 1 should an implementer wish to employ it.\r\n\r\nSimplicity is not the strength of Method 3 at all. This method requires a generator to memorize the immediately preceding value and accordingly suffers from all the challenges relating to that, such as persistent storage and synchronization mechanisms. Plus, if a generator is able to memorize the previous value, just incrementing the counter field is obviously much simpler.\r\n\r\nMethod 3 could sound simple because it naturally embodies the counter overflow handling, but that is not the case. If naively implemented, a Method 3 generator enters a busy loop when it has fully consumed the counter space until the next timestamp tick. It is actually not a big deal at all either with Method 1 & 2 if it's okay to just busy-loop upon counter overflows. Challenges of overflow handling are mostly around the graceful handling of timestamp rollbacks and malfunctioning system clocks. For example, it would be a nightmare if your generator claimed 100% CPU power for busy loops when you adjusted your server's system clock back to the correct position, and thus library writers make a lot of effort with many other techniques than a busy loop to avoid such an incident. A naive Method 3 generator will never be a practical implementation.\r\n\r\nThe performance drawback is tremendous. On average, a Method 3 generator can generate only 74 UUIDs (given the 74-bit counter space) per millisecond, which is incredibly slow, even though the generator consumes a significant amount of CPU time just to throw away unnecessary random numbers.\r\n\r\nIn conclusion, I would propose to remove the Method 3 section because:\r\n\r\n- this approach is permitted without this section\r\n- this method is no simpler than the other methods\r\n- the performance drawback is significant\r\n- this method does not have a distinctive benefit or a specific use case\r\n",
      "createdAt": "2023-05-17T01:02:05Z",
      "updatedAt": "2023-05-23T14:54:56Z",
      "closedAt": "2023-05-23T14:54:56Z",
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK I see where you are coming from on this. Am giving it more thought.  My goal here was to have a simple solution for monotonicity that does not require dedicated counter bits, since these reduce entropy for all values (instead of just the values that occur during the same timestamp), and requires whatever additional bookkeeping. But I also agree with the issues you've brought up.  I'll give this some thought and see if there's another approach to this which addresses those concerns.  I do think there is value in having a solution which only requires dealing with timestamp collisions as needed rather than dedicating counter bits to this in every generated value.",
          "createdAt": "2023-05-17T05:15:05Z",
          "updatedAt": "2023-05-17T05:22:27Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @bradleypeabody, I see your points. Will try to offer an alternative idea. For your entropy concern, perhaps a Method 2 counter incremented by a large random number works well. For example, if you increment the 74-bit monotonic random bits by a 64-bit random number for each generation within the same millisecond, the resulting UUIDs will be spread over the 74-bit space in a reasonably distributed and unguessable manner. This approach consumes much less CPU power than Method 3 and accommodates 1024 UUIDs per millisecond on average. This approach doesn't require bookkeeping either; the generator only needs to know the previous UUID and does not require any other state.\r\n\r\nTechnically, counters do not need a state other than the immediately preceding UUID. Please take a look at the signature of [my prototype implementation in C](https://github.com/LiosK/uuidv7-h/blob/v0.1.6/uuidv7.h#L112C1-L114). This function is based on a 42-bit Method 1 counter and equipped with fully operational counter overflow and clock rollback handling logics but does not require any state other than the previous UUID passed as an argument. If a generator can memorize the previous UUID, effectively it can do whatever it wants.",
          "createdAt": "2023-05-17T12:04:12Z",
          "updatedAt": "2023-05-17T12:04:12Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Or alternatively, perhaps we can tweak the first paragraph of the following part to mention something similar to the Method 3 approach:\r\n\r\n> For single-node UUID implementations that do not need to create batches of UUIDs, the embedded timestamp within UUID version 6 and 7 can provide sufficient monotonicity guarantees by simply ensuring that timestamp increments before creating a new UUID. Distributed nodes are discussed in Section 6.4.\r\n>\r\n> Implementations SHOULD choose one method for single-node UUID implementations that require batch UUID creation, or are otherwise concerned about monotonicity with high frequency UUID generation.\r\n\r\nMethod 3 is ultimately like generating a UUIDv7 without counters and just seeing if it's greater than the previous one or not, no matter whether timestamp has incremented since the last run or not. In this sense, it is as simple as and close to the approach described in the first paragraph (\"simply ensuring that timestamp increments before creating a new UUID\"). On the other hand, Method 3 is not appropriate for the second paragraph use cases (batch UUID creation and high frequency UUID generation) as I pointed out in the original post. So, I believe it's better to merge the Method 3 ideas into the first paragraph than to emphasize it as an independent method prepared for the second paragraph use cases.\r\n",
          "createdAt": "2023-05-17T12:51:20Z",
          "updatedAt": "2023-05-17T12:51:20Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do we have requirements to generate more than 74 UUID/ms [is that a typo for\n64?] on an ongoing basis, or would it be acceptable to grab timer values into\nthe future to deal with some transient burst of demand?\n\n\n",
          "createdAt": "2023-05-17T18:02:42Z",
          "updatedAt": "2023-05-17T18:02:42Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Do we have requirements to generate more than 74 UUID/ms\r\n\r\nI don't think so, but the methods 1-4 are introduced as methods used in \"batch UUID creation\" and \"high frequency UUID generation\" as clearly stated in the leading paragraph. In this sense, Method 3 is never recommended for these purposes because it generates only 74 UUIDs per millisecond despite the 100% consumption of CPU power. With the other methods, JavaScript implementations easily reach 1k+ and Rust 15k+ per millisecond without deep optimization.\r\n\r\n> 74 UUID/ms [is that a typo for 64?]\r\n\r\nIt is not a typo. UUIDv7's `rand_a` + `rand_b` fields give 74-bit space available for counters. With Method 3, the first UUID in a millisecond picks a random number from the 74-bit space, leaving on average 73-bit space available for the second trial. And, the second UUID on average picks one from the 73-bit space, leaving 72-bit space on average for the third UUID, and ....\r\n",
          "createdAt": "2023-05-17T23:54:04Z",
          "updatedAt": "2023-05-17T23:54:04Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK After looking at this newly I totally agree on this one and I think it is fine to just remove method 3.   If implementations do not need to generate more than one value per clock tick then they don't need to use any of the methods, and if they do then I agree the efficiency issues with method 3 are too great to use this.  If I have a better idea I'll propose it but yeah, method 3 should just come out.",
          "createdAt": "2023-05-19T04:54:30Z",
          "updatedAt": "2023-05-19T04:54:30Z"
        }
      ]
    },
    {
      "number": 89,
      "id": "I_kwDOH6Ln3M5mToL_",
      "title": "Fix ambiguous text around UUIDv6 clock sequence",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/89",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "[5.6. UUID Version 6](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-03.html#name-uuid-version-6)\r\n\r\n### Current text\r\n\r\n> The clock sequence bits remain unchanged from their <del>usage and </del>position in Section 5.1.\r\n>\r\n> The clock sequence and node bits SHOULD be reset to a pseudo-random value for each new UUIDv6 generated; however, implementations MAY choose to retain the old MAC address behavior from Section 5.1. For more information on MAC address usage within UUIDs see the Section 8.\r\n\r\n### Proposed text\r\n\r\n> The clock sequence <ins>and node </ins>bits remain unchanged from their position in Section 5.1.\r\n>\r\n> The clock sequence and node bits SHOULD be reset to a pseudo-random value for each new UUIDv6 generated; however, implementations MAY choose to retain the old <ins>clock sequence and </ins>MAC address behavior from Section 5.1. For more information on MAC address usage within UUIDs see the Section 8.\r\n\r\n### Rationale\r\n\r\nThe usage of the clock sequence field is technically changed because it is filled with random bits by default, though the old behavior is still permitted.",
      "createdAt": "2023-05-19T00:02:49Z",
      "updatedAt": "2023-05-23T16:39:26Z",
      "closedAt": "2023-05-23T16:39:26Z",
      "comments": []
    },
    {
      "number": 95,
      "id": "I_kwDOH6Ln3M5msCci",
      "title": "List of remarks of current draft 04",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/95",
      "state": "CLOSED",
      "author": "ben221199",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As seen in #83, I made some remarks on draft 03. In this issue I will list things that are not fully handled by the current draft (04) and some additional things I have in mind:\r\n\r\n1.\tAs mentioned in #83 (point 3), I talked about the Discord variant of Twitter snowflake. Today, I was thinking about UUIDv7. I think it is better to allow other time offsets next to 1970-01-01. Why? If Twitter decides to convert their IDs to UUID, they choose the current form of UUIDv7. However, because Discord has another offset (2015-01-01), if they want to use the current form of UUIDv7, they also have to convert all there timestamps with an additional 45 years offset. I don't think this is desirable. I propose some changes on this:\r\n\t```diff\r\n\t-UUID Version 7 features a time-ordered value field derived from the\r\n\t+UUID Version 7 features a time-ordered value field containing the number\r\n\t-widely implemented and well known Unix Epoch timestamp source, the\r\n\t+of miliseconds, leap seconds excluded, since a defined offset, in most\r\n\t-number of milliseconds since midnight 1 Jan 1970 UTC, leap seconds\r\n\t+cases the RECOMMENDED offset of midnight 1 Jan 1970 UTC. If a system\r\n\t-excluded.  UUIDv7 generally has improved entropy characteristics over\r\n\t+requires a different offset to be used, another offset MAY be used.\r\n\t-UUIDv1 or UUIDv6.\r\n\t+UUIDv7 generally has improved entropy characteristics over UUIDv1 or UUIDv6.\r\n\r\n\t-UUIDv7 values are created by allocating a Unix timestamp in\r\n\t+UUIDv7 values are created by allocating a timestamp in\r\n\tmilliseconds in the most significant 48 bits and filling the\r\n\tremaining 74 bits, jointly, excluding the required version and\r\n\tvariant bits, with a combination of the following subfields, in this\r\n\torder from the most significant bits to the least:\r\n\t```\r\n---\r\n\r\n2.\tThere is a difference between UUID and GUID. Not in the wire format, but in the representation format. If a UUID/GUID has the hexadecimal value `00 11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF`, the UUID will be written like `00112233-4455-6677-8899-AABBCCDDEEFF`, where the GUID will be written like `{33221100-5544-7766-8899-AABBCCDDEEFF}`. Except the `{` and `}`, it is also vissible that some parts are flipped. This is seen in HxD (a well-known Hex-Editor), for example: ![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/12856904/f970ff75-4ff7-45aa-8e63-402de91b8184)\r\n\tI think it is worth noting that GUIDs have this effect.\r\n\r\n---\r\n\r\n3.\tI think we still have to talk about the name of `Max UUID`. I understand the people that say \"It is the maximum value\". However, the makers of RFC 4122 went with \"Nil UUID\" when talking about the \"minimum value\". I think we should stay in the same jargon when naming things. So, we rename \"Nil UUID\" to \"Min UUID\" or something, or we change \"Max UUID\" to \"Omni UUID\". I think we should go for the Nil/Omni pair rather than the Min/Max pair. For example, Min/Max doesn't make sense when looking at UUID as a 128 bit SIGNED integer. All bits set is not the maximum and all bits not is not the minimum, see https://en.wikipedia.org/wiki/Two%27s_complement. I would rather go for the Nil/Omni pair:\r\n\r\n\t**Nil** (https://en.wiktionary.org/wiki/nil#Latin) is an alternative form of \"nihil\" and means \"nothing\" in Latin. This is true, because of all bits, NOTHING is set.\r\n\t**Omni** (https://en.wiktionary.org/wiki/omni#Latin) is an declension of \"omnis\" and means \"all\" in Latin. This is true, because ALL bits are set.",
      "createdAt": "2023-05-23T21:35:58Z",
      "updatedAt": "2023-06-02T20:27:34Z",
      "closedAt": "2023-06-02T20:27:34Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "1. Those who needs another timestamp epoch than 1970 or 1582 must use UUIDv8. It doesn't make sense to allow different epochs within the scope of UUIDv7 because the standard has to coordinate all the implementations to produce sortable values.",
          "createdAt": "2023-05-23T22:40:53Z",
          "updatedAt": "2023-05-23T22:40:53Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "1. Agree with @LiosK here.\r\n2. I am not sure it is worth noting the that level of detail. \r\n3. See:\r\n3a ~@bradleypeabody you had said to me you wanted to touch add some fluff text to the Nil/Max, can you hit a PR on this topic before the close of WGLC (June 4st for review by June 9th)?~ Edit: saw we did add this at the end of both sections already in draft-02.\r\n3b. As for Omni vs Max; I don't care I just want to get the document finished. I just don't want to change Nil since it is referenced everywhere all over the net, in docs, and misc. code.",
          "createdAt": "2023-05-31T17:40:51Z",
          "updatedAt": "2023-05-31T17:43:17Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "1.\t~I don't know if my point is fully understood. Of course I want all implementations to be coordinated to produce sortable values, but I can imagine that companies, like Discord, will say \"Yeah, we will use UUIDv7 with another offset\", like they did with Twitter's snowflake.~\r\n\t\r\n\tI see that both Twitter and Discord have another offset than 1970. For Twitter is Thursday 4 November 2010 01:42:54.657 (`1288834974657`) and for Discord it is Thursday 1 January 2015 00:00:00 (`1420070400000`). In my mind Twitter used 1970, so that was why I came up with the idea. Because it isn't the case, it is indeed better to use UUIDv8 for it for now and I will agree with @LiosK.\r\n\t\r\n\t_(Companies always can choose to patch the UUIDv7 with their own offset, but they have to clearly define this offset in their documentation, like Discord did for Snowflake. However, doing this will make it not fully follow the spec, so it will be likely that not all implementations will support custom offsets. This is not a problem for the people making the spec, (althrough it could be shortly mentioned), but it is more a issue for the company that defined this new offset.)_\r\n\r\n---\r\n\r\n2.\tI think one or two sentences mentioning it should be enough. It is just a representation format, but can be important during serializing and deserializing.\r\n\r\n---\r\n\r\n3.\tChanges of #98 seem fine.",
          "createdAt": "2023-05-31T20:00:35Z",
          "updatedAt": "2023-05-31T20:00:35Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "For item 2, do you have an application example (or two) that does that? \r\nPersonally I feel like they shouldn't be doing that... but at least looking at the app and docs myself will help me think of any text I may be able to put in there on the topic.",
          "createdAt": "2023-05-31T20:30:26Z",
          "updatedAt": "2023-05-31T20:30:26Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Well, Raymond Chen made an blog post on it: https://devblogs.microsoft.com/oldnewthing/20220928-00/.\r\n\r\nThe editor HxD (download here: https://mh-nexus.de/en/hxd/), has a Data Inspector that supports GUIDs (and no UUIDs).\r\nAlso mentioning this post: https://stackoverflow.com/questions/10190817/guid-byte-order-in-net\r\nAnd the Wikipedia: https://en.wikipedia.org/wiki/Universally_unique_identifier#Encoding\r\n\r\nImagine having the following binary data:\r\n![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/12856904/237fee02-3ab8-4df1-8ff1-97bdd299c6e4)\r\n\r\nNormally, when reading this data, we use a big-endian representation format, so the UUID will have the following representation: `00112233-4455-6677-8899-AABBCCDDEEFF`\r\n\r\nHowever, Microsoft has a GUID struct:\r\n```c\r\nstruct GUID\r\n{\r\n    uint32_t Data1;\r\n    uint16_t Data2;\r\n    uint16_t Data3;\r\n    uint8_t  Data4[8];\r\n}\r\n```\r\n\r\nThe 128 bit data is still read the same. However, the representation format is different. A GUID will print all little-endian using the struct above, so:\r\n\r\nAn `uint32_t`, so `00 11 22 33`. In case of little-endian it becomes `33 22 11 00` when printed.\r\nAn `uint16_t`, so `44 55`. In case of little-endian it becomes `55 44` when printed.\r\nAn `uint16_t`, so `66 77`. In case of little-endian it becomes `77 66` when printed.\r\nThen an array of `uint8_t`, 8 times. An octet isn't possible to write in some endianness, so the last 8 octets are printed in the same order as viewed the hex editor.\r\n\r\nThe representation becomes: `{33221100-5544-7766-8899-AABBCCDDEEFF}`\r\n\r\nMaybe that is also why there is a diffence between UUID en GUID, to distinguish the difference in encoding? I don't know, but it sounds reasonable to me.\r\n\r\n(I think I will do a big rewrite of the Wikipedia soon.)",
          "createdAt": "2023-05-31T22:54:09Z",
          "updatedAt": "2023-05-31T22:54:09Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I think I can add a bullet to the ones I added last update and state that MS implementation of GUIDs leverage little-endian and cite that MS post but also generally discourage that practice while we are at it.",
          "createdAt": "2023-06-01T14:39:04Z",
          "updatedAt": "2023-06-01T14:39:04Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I think it isn't that simple to discourage an UUID format that is used by one of the biggest tech companies in the world. I will try to investigate the problem a little bit more, so we can describe the situation in the best way possible.",
          "createdAt": "2023-06-01T18:39:13Z",
          "updatedAt": "2023-06-01T18:39:13Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I did some testing on GUID in C++:\r\n\r\n```cpp\r\nCLSID StringToGUID(){\r\n\tCLSID clsid;\r\n\twchar_t* clsid_str = L\"{5C98B8E4-2B3D-12B1-ADE2-0000F86456B2}\";\r\n\tCLSIDFromString(clsid_str, &clsid);\r\n\treturn clsid;\r\n}\r\n\r\nCLSID cls = StringToGUID();\r\n\r\nchar data[16];\r\nmemcpy(&data,&cls,16);\r\n\r\nstd::ofstream myfile;\r\nmyfile.open(\"example.dat\");\r\nfor(int i=0;i<16;++i){\r\n\tchar c[2];\r\n\tsprintf(c,\"%02X\", data[i] & 0xFF);\r\n\tmyfile << c;\r\n}\r\nmyfile.close();\r\n```\r\n\r\nWhen viewing the content of `example.dat`, the following is visible:\r\n![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/12856904/9b4a8189-403a-421d-9875-dc86066e8aba)\r\nThe value `E4B8985C3D2BB112ADE20000F86456B2`.\r\n\r\nComparing it with the input string, it is definitely little-endian. Note that `CLSIDFromString` is a Windows function: https://learn.microsoft.com/en-us/windows/win32/api/combaseapi/nf-combaseapi-clsidfromstring. Discouraging this representtion format seems a bad thing to me in this case.\r\n\r\n---\r\n\r\nImagine having an UUID with the bytes `00 11 22 33 44 55 66 77 88 99 AA BB CC DD EE FF` saved in memory, e.g. a file. In big-endian there is no trouble. The UUID is always represented in the same (network) byte order, regardless of the fields of the wire format.\r\n\r\nHowever, when going to GUID, the same sequence of bytes in the memory will behave differently. The representation format is a little different, because little-endian is used.\r\n\r\nActually, if you look very specificly to the whole thing, it is not the representation format that behaves like it is little-endian, but it is the binary format. In case of `5C98B8E4-2B3D-12B1-ADE2-0000F86456B2`, the `Data1` value of the GUID struct is `1553512676`. In hexadecimal format that is `0x5C98B8E4`. That is the same order as the representation format!!!\r\n\r\nSo, it is like the following:\r\n\r\nUUID: `Representation format <--(no conversion)--> Field values <--(no conversion)--> Wire format`\r\nGUID: `Representation format <--(no conversion)--> Field values <--(conversion of endianness*)--> Wire format`\r\n\r\nNote that GUID uses a `Data1`, `Data2`, `Data3`, `Data4` struct that is linked to the Microsoft variant, but that also non-Microsoft variant are used in this little-endian world. I have to investigate more about the handling of `version` fields in that case, because the `version` field is located at the part that is visibly influenced by little-endian.\r\n\r\nI will also make a table explaining it in some way.\r\n\r\n| Name | Endianness | Description |\r\n| - | - | - | \r\n| UUID (initially) | Big-endian | Originally the Apollo UUID that was binary saved as big-endian. |\r\n| UUID (currently) | Both | Name for all 128 bit values that follow the specs, like RFC 4122, including the Microsoft variant. |\r\n| GUID (initially) | Little-endian | Name for the specific Microsoft variant. | \r\n| GUID (currently) | Both | Same as UUID currently. GUID and UUID are used interchangeably at the moment. |\r\n\r\nSo if you have a struct like this:\r\n```cpp\r\nstruct GUID\r\n{\r\n    uint32_t Data1;\r\n    uint16_t Data2;\r\n    uint16_t Data3;\r\n    uint8_t  Data4[8];\r\n}\r\n```\r\n\r\nIn case of big-endian, you DON'T HAVE TO flip bytes when encoding to and decoding from the representation format and wire-format.\r\nIn case of little-endian, you only HAVE TO flip bytes when encoding to and decoding from the wire-format. Between fields and representation format, things should stay the same.",
          "createdAt": "2023-06-01T21:18:51Z",
          "updatedAt": "2023-06-01T21:18:51Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Let's take `IID_IActivation` as example. It has the following value: `4d9f4ab8-7d1c-11cf-861e-0020af6e7c57`.\r\n\r\n---\r\n\r\n### UUID\r\n\r\nUsing https://www.uuidtools.com/decode, it tells us it is DCE variant and version 1.\r\n\r\nThe UUID is saved in the same byte order.\r\n\r\n---\r\n\r\n### GUID\r\n\r\nUsing the `GUID` struct, the value is parsed. The fields have the following value:\r\n - Data1: `0x4d9f4ab8`\r\n - Data2: `0x7d1c`\r\n - Data3: `0x11cf`\r\n - Data4: `[0x86, 0x1e, 0x00, 0x20, 0xaf, 0x6e, 0x7c, 0x57]` (array of 8 items)\r\n\r\nNote that we still have the same order as the representation format.\r\n\r\nThe GUID is saved in little-endian, so every byte should be flipped per field as seen above:\r\n - `0x4d9f4ab8` => `0xb84a9f4d`\r\n - `0x7d1c` => `0x1c7d`\r\n - `0x11cf` => `0x11cf`\r\n - The array just as is, because it are seperate octets and octets don't have endianness.\r\n\r\nIn the end, concatenate: `0xb84a9f4d` + `0x1c7d` + `0x11cf` + array => `b84a9f4d1c7d11cf861e0020af6e7c57` (as only seen in the hex editor.\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\nMaybe I have used too many words for it, but we are NOT talking about a new representation format, as I found out by now. We are talking about Microsoft having a different way of writing UUIDs to disk. It is not big-endian, like the normal UUID, but also not a fully 16-byte flipped thing. It is something between it, because they use their own GUID struct for chunking.\r\n\r\nI propose to not add it as new representation format. It simply isn't and I was wrong in the beginning of this issue about it.\r\n\r\nI propose we add some little sentences about Microsoft using a slightly different way of writing the UUID to disk/memory and further say it is out of scope of this specification to define how, because it has actually to do with Microsoft's variant, which is out of scope too.\r\n\r\nSomething like this:\r\n\r\n> When saving the UUIDs to its binary form, normally this is done by sequencing all fields in big-endian. Microsoft uses a slightly different method when saving GUIDs, but this is out of scope for this specification. This different method doesn't have any effect on the representation format, so parsing human readable UUIDs should not give a problem.",
          "createdAt": "2023-06-01T21:56:26Z",
          "updatedAt": "2023-06-01T21:56:26Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Defining this different method will be done in the historical RFC that @kyzer-davis and I will try to make after the successor of RFC 4122 is published.",
          "createdAt": "2023-06-01T21:59:39Z",
          "updatedAt": "2023-06-01T21:59:39Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> When saving the UUIDs to its binary form, normally this is done by sequencing all fields in big-endian. Microsoft uses a slightly different method when saving GUIDs, but this is out of scope for this specification. This different method doesn't have any effect on the representation format, so parsing human readable UUIDs should not give a problem.\r\n\r\n> Defining this different method will be done in the historical RFC that @kyzer-davis and I will try to make after the successor of RFC 4122 is published.\r\n\r\nJust reviewed: \r\nSo do we want the MS GUID text or are we good with covering that topic in the historical doc?\r\nLet me know so I can get the latest Draft 05 up to IETF for the last week of WLGC review. \r\n\r\nIf I add the text I will add an asterisk next to [Microsoft] in the first section 4 bullet and then call cite that text at the end of section 4.",
          "createdAt": "2023-06-02T15:43:59Z",
          "updatedAt": "2023-06-02T15:43:59Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I think we should maybe only mention the fact that Microsoft's GUID has a slightly different binary output then the original UUID to take into account, but nothing more than that. The details will be in the historical RFC. The text I made previously (`When saving ... a problem.`) seems good enough for me, but you can make some modifications to it. I would suggest to add the text after paragraph 2 in section 4.\r\n\r\nWhat do you mean by adding a asterisk next to [Microsoft] in the first section 4 bullet? (I assume you mean `Some UUID ... curly braces.`.) The binary form of Microsoft's GUID doesn't have anything to do with the curly braces.",
          "createdAt": "2023-06-02T18:51:37Z",
          "updatedAt": "2023-06-02T18:51:37Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> What do you mean by adding a asterisk next to [Microsoft] in the first section 4 bullet? (I assume you mean Some UUID ... curly braces..) The binary form of Microsoft's GUID doesn't have anything to do with the curly braces.\r\n\r\nYeah, I was trying to tie to MS so it flows nicely but since we are talking about big-endian encoding in paragraph 2 it can work there. Let me whip up a PR real fast.",
          "createdAt": "2023-06-02T19:58:21Z",
          "updatedAt": "2023-06-02T19:58:21Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Sure. I already started to improve the Wikipedia.",
          "createdAt": "2023-06-02T20:11:31Z",
          "updatedAt": "2023-06-02T20:11:31Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@ben221199, take a peek at https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/408c5a72a6779391fc879e71bb050e3922b5aaca\r\n\r\nIf that looks good I will merge down and get this back to IETF under draft 05 closing this thread.",
          "createdAt": "2023-06-02T20:18:54Z",
          "updatedAt": "2023-06-02T20:18:54Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Seems good to me. I think that DCOM (Distributed Component Object Model) is better than COM (https://nl.wikipedia.org/wiki/Distributed_component_object_model), but I also see COM appearing in some docs. I see that Raymond uses `COM`, so let's stick with that. Perfect.",
          "createdAt": "2023-06-02T20:26:40Z",
          "updatedAt": "2023-06-02T20:26:40Z"
        }
      ]
    },
    {
      "number": 99,
      "id": "I_kwDOH6Ln3M5nfv36",
      "title": "Limitations of 32 bit unix epoch in UUID V7",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/99",
      "state": "CLOSED",
      "author": null,
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "question"
      ],
      "body": "Hi,\r\n\r\nNot sure if this is the correct place to add this but I'm truly excited to see these being used in the future. Reading through the draft would UUID V7 which I am intending to use in the future experience the 2038 problem?",
      "createdAt": "2023-06-01T13:50:45Z",
      "updatedAt": "2023-06-01T15:33:23Z",
      "closedAt": "2023-06-01T15:31:56Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Hello! \r\nTake a look at the \"length\" sub-section of Section 6.1 Timestamp Considerations:\r\nhttps://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-04.html#name-timestamp-considerations-3",
          "createdAt": "2023-06-01T14:34:47Z",
          "updatedAt": "2023-06-01T14:34:47Z"
        },
        {
          "author": null,
          "authorAssociation": "NONE",
          "body": "Thank you! I missed that while looking through. 48 bit is perfect. I'm really excited for this to get approved.",
          "createdAt": "2023-06-01T15:31:56Z",
          "updatedAt": "2023-06-01T15:33:23Z"
        }
      ]
    },
    {
      "number": 101,
      "id": "I_kwDOH6Ln3M5nuA8r",
      "title": "Emphasis of optional subfields for v7",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/101",
      "state": "CLOSED",
      "author": "fboulnois",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I have an implementation of v7 UUIDs for [Postgres](https://github.com/fboulnois/pg_uuidv7) based on the [original draft](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-00.html#name-uuid-version-7). I stumbled upon the [updated draft](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-05) today and I think the latest draft places too strong an emphasis on the optional subfields in v7 UUIDs (changed in #91).\r\n\r\nIn the original draft, the implementation was straightforward: 48 bits for a Unix timestamp in milliseconds and 74 bits of randomness.\r\n\r\nThe updated draft include a more detailed description of the 74 bits of randomness, but in doing so I think it places too much emphasis on the use of timestamps or counters in the optional subfields. This raises the barrier to implementation (I was initially confused and concerned I needed to reimplement or add code to remain conformant) and in my opinion we should steer implementations away from relying on anything other than a CSPRNG in the random bits unless there is a specific need for all the reasons described in #86. Additionally, I think encouraging the use of timestamps or counters in those subfields can lead to incompatible implementations of v7 UUIDs even if they are optional.\r\n\r\nTherefore, my suggestion would be either to:\r\n\r\n1. Remove the numeric bullet points and rephrase the section as:\r\n\r\n> UUIDv7 values are created by allocating a Unix timestamp in milliseconds in the most significant 48 bits and filling the remaining 74 bits, jointly, excluding the required version and variant bits, with pseudo-random data in the subfields.\r\n\r\n(the subfields are described right after and include pointers to how they should be filled, so I think it is ok to omit the bullet points)\r\n\r\n2. Emphasize \"Random data to provide uniqueness as per {{unguessability}} OR \" in front of bullet points 1 and 2.\r\n\r\nI am not a standards person, so perhaps there is a more elegant and/or IETF-y way to rephrase the section to deemphasize the use of the optional subfields.\r\n",
      "createdAt": "2023-06-04T04:11:56Z",
      "updatedAt": "2023-06-05T19:13:04Z",
      "closedAt": "2023-06-05T19:13:04Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "How about the text like this?\r\n\r\n> UUIDv7 values are created by allocating a Unix timestamp in milliseconds in the most significant 48 bits and filling the remaining 74 bits, jointly, excluding the required version and variant bits, with random bits to provide uniqueness for each new UUIDv7 generated. Alternatively, implementations MAY fill the 74 bits with a combination of the following subfields, in this order from the most significant bits to the least, to guarantee additional monotonicity within a millisecond:\r\n>\r\n> 1.  An OPTIONAL sub-millisecond timestamp fraction (12 bits at maximum) to utilize extra clock precision as per {{monotonicity_counters}} (Method 3).\r\n> 2.  An OPTIONAL carefully seeded counter to guarantee additional monotonicity as per {{monotonicity_counters}} (Method 1 or 2).\r\n> 3.  Random data for each new UUIDv7 generated to provide uniqueness for any remaining space.\r\n\r\nI totally agree that the emphasis should be given to the random data because the extra clock precision and monotonic counter are absolutely optional. I'm concerned about removing the bullets because the Monotonicity and Counters section isn't really intuitive, and thus it looks hard for readers to determine what is actually permitted in implementing a UUIDv7 generator. The subfield description should be helpful to clarify that point.\r\n",
          "createdAt": "2023-06-04T13:28:25Z",
          "updatedAt": "2023-06-04T13:28:25Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Tweaked the proposed text to reduce repetition:\r\n\r\n> UUIDv7 values are created by allocating a Unix timestamp in milliseconds in the most significant 48 bits and filling the remaining 74 bits, jointly, excluding the required version and variant bits, with random bits for each new UUIDv7 generated to provide uniqueness as per {{unguessability}}. Alternatively, implementations MAY fill the 74 bits with a combination of the following subfields, in this order from the most significant bits to the least, to guarantee additional monotonicity within a millisecond:\r\n>\r\n> 1.  An OPTIONAL sub-millisecond timestamp fraction (12 bits at maximum) as per {{monotonicity_counters}} (Method 3).\r\n> 2.  An OPTIONAL carefully seeded counter as per {{monotonicity_counters}} (Method 1 or 2).\r\n> 3.  Random data for each new UUIDv7 generated for any remaining space.",
          "createdAt": "2023-06-04T14:22:17Z",
          "updatedAt": "2023-06-04T14:22:17Z"
        },
        {
          "author": "fboulnois",
          "authorAssociation": "NONE",
          "body": "> Tweaked the proposed text to reduce repetition:\r\n> \r\n> > UUIDv7 values are created by allocating a Unix timestamp in milliseconds in the most significant 48 bits and filling the remaining 74 bits, jointly, excluding the required version and variant bits, with random bits for each new UUIDv7 generated to provide uniqueness as per {{unguessability}}. Alternatively, implementations MAY fill the 74 bits with a combination of the following subfields, in this order from the most significant bits to the least, to guarantee additional monotonicity within a millisecond:\r\n> > \r\n> > 1. An OPTIONAL sub-millisecond timestamp fraction (12 bits at maximum) as per {{monotonicity_counters}} (Method 3).\r\n> > 2. An OPTIONAL carefully seeded counter as per {{monotonicity_counters}} (Method 1 or 2).\r\n> > 3. Random data for each new UUIDv7 generated for any remaining space.\r\n\r\nThis version sounds great! I agree with your earlier concerns about removing the bullet points completely. Thanks for revising the text so quickly.",
          "createdAt": "2023-06-04T14:42:19Z",
          "updatedAt": "2023-06-04T14:42:19Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Crafted a PR. Let's see if everyone is okay with it.\r\n\r\nPerhaps, I tend to construct unintuitive if logically correct paragraphs. Thank you for your great feedback.",
          "createdAt": "2023-06-04T18:07:34Z",
          "updatedAt": "2023-06-04T18:07:34Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "I_kwDOH6Ln3M5n0OuH",
      "title": "Better Clarify Case in ABNF",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/104",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In section 4 after the ABNF for textual representation of UUIDs it says:\r\n> An example UUID using this textual representation from the above ABNF is shown in Figure 1. Note that in this example the alphabetic characters may be all uppercase, all lowercase, or mixed case, as per [RFC5234], Section 2.3 \r\n\r\nI find this confusing. It isn\u2019t just in the example that alphabetic characters may be upper, lower, or mixed case \u2013 it is true for all text representations of UUIDs. I suggest changing it to\r\n> Note that the alphabetic characters may be all uppercase, all lowercase, or mixed case, as per [RFC5234], Section 2.3. \r\n> An example UUID using this textual representation from the above ABNF is shown in Figure 1. \r\n\r\nFrom: Paul Leach <pauljleach@msn.com>\r\n",
      "createdAt": "2023-06-05T13:05:53Z",
      "updatedAt": "2023-06-06T14:37:27Z",
      "closedAt": "2023-06-06T14:37:27Z",
      "comments": []
    },
    {
      "number": 105,
      "id": "I_kwDOH6Ln3M5n0Pns",
      "title": "Verbiage change in 6.2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/105",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In section 6.2. it says\r\n> Implementations SHOULD choose one method for single-node UUID implementations that require batch UUID creation\u2026\r\n\r\nand I suggest changing it to\r\n> Implementations SHOULD choose one of the following methods for single-node UUID implementations that require batch UUID creation\u2026\r\n\r\nFrom: Paul Leach <pauljleach@msn.com>",
      "createdAt": "2023-06-05T13:07:43Z",
      "updatedAt": "2023-06-06T14:37:28Z",
      "closedAt": "2023-06-06T14:37:28Z",
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Technically, Method 3 and Method 1/2 can be used together, so something like \"Implementations SHOULD employ the following methods for ...\" is better, maybe?",
          "createdAt": "2023-06-05T13:37:41Z",
          "updatedAt": "2023-06-05T13:37:41Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "I_kwDOH6Ln3M5n_nSS",
      "title": "Revert Max UUID Naming",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/107",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I'd raise this issue to hear more voices because I'm not sure if the Omni naming has achieved consensus. As far as I'm aware, nobody but @ben221199 seems to have a strong opinion about the naming of ffffffff-ffff-ffff-ffff-ffffffffffff. In the previous discussion https://github.com/uuid6/uuid6-ietf-draft/issues/62, although nobody expressed a strong opinion, nobody expressed support for Omni either, while people there showed favorable reactions to Max.\r\n\r\nI'm more or less concerned about Omni partly because I have no idea about Latin and it sounds like omni-UUID (all of UUIDs) based on the prefix usage in English, but mostly because I am not able to find this usage of Omni in the programming and mathematics worlds. In this sense, we are almost creating a new word, though the word itself exists for thousands of years. I'm skeptical if that's worth it, especially when Max is the default term in programming languages to describe the greatest unsigned integer values.",
      "createdAt": "2023-06-06T22:48:46Z",
      "updatedAt": "2023-06-09T13:15:49Z",
      "closedAt": "2023-06-09T13:15:49Z",
      "comments": [
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "I don't agree that just because a word is derived from Latin we should use another Latin word to stay in the same jargon. \r\n\r\nI am also of the opinion that the document should be finalized, although the <del>word</del> prefix \"omni\" is far from consensus.\r\n\r\n",
          "createdAt": "2023-06-07T02:21:53Z",
          "updatedAt": "2023-06-07T02:40:34Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I understand your concern, @LiosK, but as I told in #95, the min/max isn't correct. Definitely when looking to signed numbers. For example, in Java this are the min and max constants of `Integer` and important here is the first bit of the whole thing:\r\n```java\r\n    /**\r\n     * A constant holding the minimum value an {@code int} can\r\n     * have, -2<sup>31</sup>.\r\n     */\r\n    @Native public static final int   MIN_VALUE = 0x80000000;\r\n\r\n    /**\r\n     * A constant holding the maximum value an {@code int} can\r\n     * have, 2<sup>31</sup>-1.\r\n     */\r\n    @Native public static final int   MAX_VALUE = 0x7fffffff;\r\n```\r\n\r\nWhy RFC 4122 (and maybe some other documents) choose the Nil bit is because it has the meaning \"no bits\" in some way. Why I choose the \"omni\" is because it has the meaning \"all bits\" in some way.\r\n\r\nIf you think \"omni\" doesn't fit, we should come up with a better name with the same meaning, if there is any. But \"max\" is just not right.\r\n\r\nI also agree with @fabiolimace that we maybe should slowly try to finalize the document.",
          "createdAt": "2023-06-07T08:12:28Z",
          "updatedAt": "2023-06-07T08:12:28Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> the min/max isn't correct\r\n\r\nActually, I don't really understand this logic. Nobody would pick <stdint.h> and blame `UINT64_MAX` for setting the most significant bit, because that's for `uint64_t`. Similarly, nobody would blame Max UUID for ignoring the interpretation as a signed integer, because that's for UUID. Generally, UUIDs are not interpreted as signed integers, which is clear to some extent from the description in Section 6.10. Sorting. I don't really see the necessity to take such uncommon use cases into account in the spec.\r\n\r\n> because it has the meaning \"no bits\"\r\n\r\nI don't understand this either. In the programming world, nil/null/none are almost interchangeably used to simply express the concept of _nothing_, regardless of their physical representations. Nil doesn't necessarily imply, or have people imagine, a byte buffer with all bits unset. Furthermore, nil can just mean _zero_, and in this sense, it's not unnatural at all in an unsigned space to have a Nil (zero) value on one end and a Max (from Latin _maximum_) value on the other. It's a subjective matter.\r\n\r\nAnyway, I know Max doesn't look super perfect but still find no reason to believe that's wrong or incorrect.\r\n",
          "createdAt": "2023-06-07T14:12:21Z",
          "updatedAt": "2023-06-07T14:22:28Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe somebody throw something up on ~Twitter/Reddit poll~ or some other place so we get a side-by-side vote from a larger community of programmers?\r\n\r\nI will shout at all the prototype implementers over on the other repo and get a small poll going there.\r\nEdit: Send folks here to cast a vote: https://github.com/uuid6/prototypes/discussions/46",
          "createdAt": "2023-06-07T14:54:50Z",
          "updatedAt": "2023-06-07T15:08:23Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I closed the poll and Max UUID won. I will revert the changes and get this back into the hands of IETF so we can submit to IESG today.\r\n\r\n![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/867657/3d37aeb5-6fe1-4a29-a983-246f9f6ccd50)\r\nSource: https://github.com/uuid6/prototypes/discussions/46\r\n",
          "createdAt": "2023-06-09T13:01:33Z",
          "updatedAt": "2023-06-09T13:01:33Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "I_kwDOH6Ln3M5rGn9o",
      "title": "AD Review: BCP 14 - SHOULD",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/114",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- AD Review request from Murray on Section 6's SHOULDs. \r\n- Addressing all as numbered by the section.subsection with author commentary.\r\n- Feel free to discuss my suggestions.\r\n\r\nMurray Feedback:\r\n> Several of the \"SHOULD\"s in Section 6.1 seem questionable to me.  For instance, the first one leaves the possibility of an implementation that doesn't use an increasing clock.  Why isn't this a MUST?  The various \"Care SHOULD be taken ...\" ones are also curious; why would we allow for this to be a choice?  Generally below that, the \"SHOULD\" instances left me wondering why we leave all of these as implementation choices.  Then, in \"every UUID generation SHOULD be a random integer of any desired length larger than zero\", this allows a length of zero; is that okay?  And lastly, I don't know what \"Implementations SHOULD weigh the consequences\" or \"Care SHOULD be taken\" mean from an interoperability perspective.\r\n\r\n---\r\n\r\n### [RFC2119](https://www.rfc-editor.org/rfc/rfc2119)\r\n- **SHOULD**:  This word, or the adjective \"RECOMMENDED\", mean that there may exist valid reasons in particular circumstances to ignore a particular item, but the full implications must be understood and carefully weighed before choosing a different course.\r\n\r\nQuestion to answer for each:\r\n- For the SHOULD, does a valid alternative exist and is it outlined; thus staying a **SHOULD**.\r\n- For the SHOULD, is it fully requires with no alternative; thus upgrading to a **MUST**.\r\n- For the SHOULD, truly optional and can be ignored with no downside; thus downgrading to a **MAY**.\r\n\r\n---\r\n\r\n\r\n### [6.1. Timestamp Considerations](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-timestamp-considerations)\r\n1.\tImplementations **SHOULD** use the current timestamp from a reliable source to provide values that are time-ordered and continually increasing.\r\n    - Could upgrade to a **MUST**, for v1, v6, v7 the starting timestamp is the backbone of the UUID so stating that we always pull from a reliable source makes sense.\r\n3.\tCare **SHOULD** be taken to ensure that timestamp changes from the environment or operating system are handled in a way that is consistent with implementation requirements.\r\n    - I think a **SHOULD** is fine here as later sections discuss how you can handle that, but if you really don\u2019t care about catching something like NTP changing a clock you can ignore those backwards timestamp moves.\r\n4.\tFor other levels of precision UUIDv8 **SHOULD** be utilized.\r\n    - We probably need to put a forward reference to the UUIDv7 (method 3 counter) to drive home the alternative.\r\n5.\tCare **SHOULD** be given to ensure that the proper length is selected for a given timestamp.\r\n    - Can probably be removed entirely if I am being honest. The paragraph section does enough to discuss this point it does not need normative language. \r\n6. \tIf a system overruns the generator by requesting too many UUIDs within a single system time interval, the UUID service **SHOULD** either return an error, or stall the UUID generator until the system clock catches up, and MUST NOT return knowingly duplicate values.\r\n    - Can upgrade to a **MUST**.\r\n\r\n### [6.2. Monotonicity and Counters](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-monotonicity-and-counters)\r\n1.\tCare **SHOULD** be taken to ensure UUIDs generated in batches are also monotonic.\r\n    - Just use non-normative language something like \u201cImplementations might require UUIDs generated in batches adhere to monotonicity requirements.\u201d\r\n2.\tThat is, if one thousand UUIDs are generated for the same timestamp, there **SHOULD** be sufficient logic for organizing the creation order of those one thousand UUIDs.\r\n    - Can upgrade to a **MUST**.\r\n3.\tBatch UUID creation implementations MAY utilize a monotonic counter that **SHOULD** increment for each UUID created during a given timestamp.\r\n    - Can upgrade to a **MUST**.\r\n4.\tImplementations **SHOULD** employ the following methods for single-node UUID implementations that require batch UUID creation, or are otherwise concerned about monotonicity with high frequency UUID generation.\r\n    - Can upgrade to a **MUST**.\r\n5.\tA fixed bit-length counter, if present, **SHOULD** be positioned immediately after the embedded timestamp.\r\n    - Can upgrade to a **MUST**.\r\n7.\tWith this method, the rand_a section of UUIDv7 **SHOULD** be used as fixed-length dedicated counter bits that are incremented by one for every UUID generation.\r\n    - I think a **SHOULD** is fine, if somebody wants to increase by some random number that is fine.\r\n8.\tUUIDv7's rand_b section **SHOULD** be utilized with this method to handle batch UUID generation during a single timestamp tick.\r\n    - Author\u2019s weighing this method vs the others. Alternatives exist and are defined (method 1 and 2). **SHOULD** seems fine.\r\n9.\tThe increment value for every UUID generation **SHOULD** be a random integer of any desired length larger than zero.\r\n    - Similar to the previous but opposite, if an implementation wants to increment by +1 that is fine too. Downsides outlines in next few sentences with a **MAY**.\r\n10.\tImplementations utilizing the fixed-length counter method **SHOULD** randomly initialize the counter with each new timestamp tick.\r\n    - Starting at zeros is fine. Re-using the previous counter for a new timestamp tick in theory would also be okay.\r\n11.\tHowever, when the timestamp has not incremented, the counter **SHOULD** be frozen and incremented via the desired increment logic.\r\n    - Can Upgrade to a **MUST**.\r\n12.\tGeneral guidance is that the counter **SHOULD** be at least 12 bits but no longer than 42 bits.\r\n    - Fine if it is shorter, just providing guidance.\r\n13.\tCare **SHOULD** also be given to ensure that the counter length selected leaves room for sufficient entropy in the random portion of the UUID after the counter.\r\n    - Can remove normative verbiage and change to something like \u201cThese counter length of 12 to 42 are selected to ensure the that the counter length selected leaves room for sufficient entropy in the random portion of the UUID after the counter.\u201d\r\n14.\tCounter rollovers **SHOULD** be handled by the application to avoid sorting issues.\r\n    - Can upgrade to a **MUST**.\r\n15.\tThe general guidance is that applications that care about absolute monotonicity and sortability **SHOULD** freeze the counter and wait for the timestamp to advance which ensures monotonicity is not broken.\r\n    - **SHOULD** seem fine. Alternatives exist defined in next sentence. \r\n16.\tImplementations **SHOULD** check if the currently generated UUID is greater than the previously generated UUID\r\n    - Do it if you want, just a recommendation. Downsides discussed.\r\n17.\tApplications **SHOULD** embed sufficient logic to catch these scenarios and correct the problem to ensure that the next UUID generated is greater than the previous, or at least report an appropriate error\r\n    - Do it if you want, just a recommendation. Downsides discussed.\r\n\r\n### [6.3. UUID Generator States](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-uuid-generator-states)\r\n1.\tIf an implementation does not have any stable store available, then it **SHOULD** proceed with UUID generation as if this was the first UUID created within a batch.\r\n    - Can downgrade to a **MAY**?\r\n\r\n### [6.4. Distributed UUID Generation](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-distributed-uuid-generation)\r\n1.\tIt should be noted that although this section details two methods for the sake of completeness; implementations **SHOULD** utilize the pseudo-random Node ID option if additional collision resistance for distributed UUID generation is a requirement.\r\n    - Authors recommending one method vs the others. Alternatives detailed.\r\n\r\n### [6.5. Name-Based UUID Generation](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-name-based-uuid-generation)\r\n1.\tWhile Appendix A details a few interesting namespaces; implementations SHOULD provide the ability to input a custom namespace.\r\n    - They can already but most don\u2019t because of the old RFC. Just some text trying to nudge implementors of libraries to open it up to more than just what is in the appendix.\r\n\r\n### [6.6. Collision Resistance](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-collision-resistance)\r\n1.\tImplementations **SHOULD** weigh the consequences of UUID collisions within their application and when deciding between UUID versions that use entropy (randomness) versus the other components such as those in Section 6.1 and Section 6.2.\r\n    - Can remove normative verbiage and change it to a lowercase \u201cshould\u201d \r\n\r\n### [6.8. Unguessability](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-unguessability)\r\n1.\tImplementations **SHOULD** utilize a cryptographically secure pseudo-random number generator (CSPRNG) to provide values that are both difficult to predict (\"unguessable\") and have a low likelihood of collision (\"unique\").\r\n    - Some client might not have CSPRNG, regular PRNG can be an alternative. MUST is too harsh.\r\n2.\tCare **SHOULD** be taken to ensure the CSPRNG state is properly reseeded upon state changes, such as process forks, to ensure proper CSPRNG operation.\r\n    - Can upgrade to a **MUST** and change to \u201cThe CSPRNG state **MUST** be properly reseeded upon state changes, such as process forks, to ensure proper CSPRNG operation.\u201d\r\n\r\n### [6.9. UUIDs That Do Not Identify the Host](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-uuids-that-do-not-identify-)\r\n1.\tImplementations **SHOULD** obtain a 47-bit cryptographic-quality random number as per Section 6.8 and use it as the low 47 bits of the node ID.\r\n    - Alternative is detailed in the last paragraph of the section so a **SHOULD** seems fine here.\r\n\r\n### [6.10. Sorting](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#section-6.10)\r\n1.\tUUIDv6 and UUIDv7 are designed so that implementations that require sorting (e.g., database indexes) **SHOULD** sort as opaque raw bytes, without need for parsing or introspection\r\n    - As we have found, some folks like their introspection. I think this was a **MUST** but it was laxed to a **SHOULD** at one point.\r\n2.\tUUIDs formats created by this specification **SHOULD** be lexicographically sortable while in the textual representation.\r\n    - More of a statement than a requirement. Can change to \u201cUUIDs formats created by this specification were created to be lexicographically sortable while in the textual representation.\u201d\r\n3.\tUUIDs created by this specification are crafted with big-endian byte order (network byte order) in mind. If little-endian style is required a custom UUID format **SHOULD** be created using UUIDv8.\r\n    - Can upgrade to a **MUST**\r\n\r\n### [6.11. Opacity](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-opacity)\r\n1.\tUUIDs **SHOULD** be treated as opaque values and implementations **SHOULD NOT** examine the bits in a UUID.\r\n    - Similar to a previous bullet, folks like to examine the bits although usually not required for interoperability. \r\n\r\n### [6.12. DBMS and Database Considerations](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-dbms-and-database-considera)\r\n1.\tThus, where feasible, UUIDs **SHOULD** be stored within database applications as the underlying 128 bit binary value.\r\n    - Authors nudging towards the better method, alternative in next paragraph.\r\n",
      "createdAt": "2023-07-10T14:25:21Z",
      "updatedAt": "2023-07-24T19:40:29Z",
      "closedAt": "2023-07-24T19:40:29Z",
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@kyzer-davis I'll take a crack at this.  A lot of these should be simple.  In some cases non-normative language can be used as you suggest, and this includes some situations where just a general concept is being described and the word \"should\" is used but then has been capitalized - I don't think we need that.  Even the RFC describing \"SHOULD\" https://www.rfc-editor.org/rfc/rfc2119 also uses \"should\" in a non-normative way in its introduction, I think we can take a cue from that.  In other scenarios the \"SHOULD\" can just be removed altogether with some simple rewording.\r\n\r\nHere's my proposal on it:\r\n\r\n---\r\n\r\n\r\n### [6.1. Timestamp Considerations](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-timestamp-considerations)\r\n> 1.\tImplementations **SHOULD** use the current timestamp from a reliable source to provide values that are time-ordered and continually increasing.\r\n1.\tImplementations **MUST** use the current timestamp from a reliable source to provide values that are time-ordered and continually increasing.\r\n    - Agreed, upgrade to MUST.\r\n   \r\n> 3.\tCare **SHOULD** be taken to ensure that timestamp changes from the environment or operating system are handled in a way that is consistent with implementation requirements.\r\n3.\tTake care to ensure that timestamp changes from the environment or operating system are handled in a way that is consistent with implementation requirements.\r\n    - Suggest using non-normative language, recommendation is not specific enough, just general advice.\r\n  \r\n> 4.\tFor other levels of precision UUIDv8 **SHOULD** be utilized.\r\n4.\tFor other levels of precision UUIDv8 is available as an option.\r\n    - Suggest using non-normative language, the spec gives all available UUIDs, the reader can already choose for themselves, I don't see a need to be more specific.\r\n\r\n> 5.\tCare **SHOULD** be given to ensure that the proper length is selected for a given timestamp.\r\n5.\tTake care to ensure that the proper length is selected for a given timestamp.\r\n    - Agree with earlier suggestion, non-normative language seems good.\r\n\r\n> 6. \tIf a system overruns the generator by requesting too many UUIDs within a single system time interval, the UUID service **SHOULD** either return an error, or stall the UUID generator until the system clock catches up, and MUST NOT return knowingly duplicate values.\r\n6. \tIf a system overruns the generator by requesting too many UUIDs within a single system time interval, the UUID service MUST NOT return knowingly duplicate values, and instead can either return an error, or stall the UUID generator until the system clock catches up.\r\n    - I think the MUST NOT provides the most important imperative here.  I don't like the idea of saying the stall or error is what they must do because what if there's some other solution we haven't thought of?  The point is that it shouldn't return duplicates, so I think we just say that.\r\n\r\n### [6.2. Monotonicity and Counters](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-monotonicity-and-counters)\r\n> 1.\tCare **SHOULD** be taken to ensure UUIDs generated in batches are also monotonic.\r\n1.\tTake care to ensure UUIDs generated in batches are also monotonic.\r\n    - Agree with suggestion, go non-normative\r\n> 2.\tThat is, if one thousand UUIDs are generated for the same timestamp, there **SHOULD** be sufficient logic for organizing the creation order of those one thousand UUIDs.\r\n2.\tThat is, if one thousand UUIDs are generated for the same timestamp, there should be sufficient logic for organizing the creation order of those one thousand UUIDs.\r\n    - This is not a specific requirement, it's simply giving an example of correct behavior, I think \"should\" is okay here.  Or if someone disagrees let's just reword so it's non-normative and not use \"should\" or \"SHOULD\".\r\n\r\n> 3.\tBatch UUID creation implementations MAY utilize a monotonic counter that **SHOULD** increment for each UUID created during a given timestamp.\r\n3.\tBatch UUID creation implementations MAY utilize a monotonic counter that increments for each UUID created during a given timestamp.\r\n    - Reword to non-normative\r\n\r\n5.\tImplementations **SHOULD** employ the following methods for single-node UUID implementations that require batch UUID creation, or are otherwise concerned about monotonicity with high frequency UUID generation.\r\n    - I think this \"SHOULD\" has to stay, because we specifically do not want to say that these three methods are the only ways to solve the problem.  I think it's important to leave it open ended because if someone wants to do something else, and it produces correct output, and it doesn't impact interoperability, just on principle they should be allowed to do that.  However I think if we say SHOULD here, then other more detailed points inside can say MUST, because the entire thing is a recommendation.  \r\n\r\n> 6.\tA fixed bit-length counter, if present, **SHOULD** be positioned immediately after the embedded timestamp.\r\n6.\tA fixed bit-length counter, if present, **MUST** be positioned immediately after the embedded timestamp.\r\n    - Agreed per above, becomes MUST\r\n\r\n> 7.\tWith this method, the rand_a section of UUIDv7 **SHOULD** be used as fixed-length dedicated counter bits that are incremented by one for every UUID generation.\r\n7.\tWith this method, the rand_a section of UUIDv7 **MUST** be used as fixed-length dedicated counter bits that are incremented for every UUID generation.\r\n    - Could also leave as SHOULD but this works too - we say it gets incremented but not by how much.\r\n\r\n8.\tUUIDv7's rand_b section **SHOULD** be utilized with this method to handle batch UUID generation during a single timestamp tick.\r\n    - I agree with earlier comment, suggest leave it.\r\n\r\n> 9.\tThe increment value for every UUID generation **SHOULD** be a random integer of any desired length larger than zero.\r\n9.\tThe increment value for every UUID generation is a random integer of any desired length larger than zero.\r\n    - What if we just say \"is\", since we're describing a method of doing something, I think that works.\r\n\r\n> 10.\tImplementations utilizing the fixed-length counter method **SHOULD** randomly initialize the counter with each new timestamp tick.\r\n10.\tImplementations utilizing the fixed-length counter method randomly initialize the counter with each new timestamp tick.\r\n    - Same deal here, we're explaining how to do something, we've already set up the context for it, the normative language doesn't help us here, can just come out.\r\n\r\n> 11.\tHowever, when the timestamp has not incremented, the counter **SHOULD** be frozen and incremented via the desired increment logic.\r\n11.\tHowever, when the timestamp has not incremented, the counter is frozen and incremented via the desired increment logic.\r\n    - Ditto\r\n\r\n12.\tGeneral guidance is that the counter **SHOULD** be at least 12 bits but no longer than 42 bits.\r\n    - Agreed that this is okay.\r\n\r\n> 13.\tCare **SHOULD** also be given to ensure that the counter length selected leaves room for sufficient entropy in the random portion of the UUID after the counter.\r\n13.\tTake care to ensure that the counter length selected leaves room for sufficient entropy in the random portion of the UUID after the counter.\r\n    - how about that\r\n\r\n> 14.\tCounter rollovers **SHOULD** be handled by the application to avoid sorting issues.\r\n14.\tCounter rollovers **MUST** be handled by the application to avoid sorting issues.\r\n    - Agreed, upgrade to a **MUST**.\r\n\r\n15.\tThe general guidance is that applications that care about absolute monotonicity and sortability **SHOULD** freeze the counter and wait for the timestamp to advance which ensures monotonicity is not broken.\r\n    - Agree with earlier statement: **SHOULD** seem fine. Alternatives exist defined in next sentence. \r\n\r\n16.\tImplementations **SHOULD** check if the currently generated UUID is greater than the previously generated UUID\r\n    - Agree with earlier statement: Do it if you want, just a recommendation. Downsides discussed.\r\n\r\n17.\tApplications **SHOULD** embed sufficient logic to catch these scenarios and correct the problem to ensure that the next UUID generated is greater than the previous, or at least report an appropriate error\r\n    - Agree with earlier statement: Do it if you want, just a recommendation. Downsides discussed.\r\n\r\nAnd then everything else from 6.3. UUID Generator States and down in the earlier post I agree with the recommendation given and I think unless someone else expresses concerns, just go for it on those changes.\r\n\r\n",
          "createdAt": "2023-07-12T03:35:33Z",
          "updatedAt": "2023-07-12T03:35:33Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Generally, I agree with @bradleypeabody; rewording to non-normative verbiage should work very well in many contexts.\r\n\r\nSome comments:\r\n\r\n[6.1. Timestamp Considerations](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-timestamp-considerations)\r\n\r\n> 1. Implementations SHOULD use the current timestamp from a reliable source to provide values that are time-ordered and continually increasing.\r\n\r\nI think we should keep SHOULD here. MUST conflicts with the following \"Altering, Fuzzing, or Smearing\" section. Plus, I got a feature request to my prototype to add a feature to create a UUIDv7 with an arbitrary timestamp to migrate old IDs to UUIDv7 based on the `created_at` database field. I think that's a legitimate use case.\r\n\r\n> 5. If a system overruns the generator by requesting too many UUIDs within a single system time interval, the UUID service SHOULD either return an error, or stall the UUID generator until the system clock catches up, and MUST NOT return knowingly duplicate values.\r\n\r\nI would rather suggest to downgrade MUST NOT to SHOULD NOT here. With MUST, every compliant service on a machine MUST refuse to return a value when the system clock stops or goes backwards, which might cause the entire break down of applications running on that server, even if the absolute monotonicity is not a requirement of such applications. A generator should have an option to reset the state and continue when the system clock seems to be broken.\r\n\r\n[6.2. Monotonicity and Counters](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-monotonicity-and-counters)\r\n\r\n> 2. That is, if one thousand UUIDs are generated for the same timestamp, there SHOULD be sufficient logic for organizing the creation order of those one thousand UUIDs.\r\n\r\nSHOULD sounds fine here. MUST sounds like prohibiting the generation of one thousand UUIDs without a monotonic counter. For some applications, it should absolutely be fine to get 1000 unordered UUIDs from a simple, much-easier-to-implement counter-less UUIDv7 generator.\r\n\r\n> 3. Batch UUID creation implementations MAY utilize a monotonic counter that SHOULD increment for each UUID created during a given timestamp.\r\n\r\nMUST might be fine, but also we can simply omit SHOULD here.\r\n\r\n> 6. With this method, the rand_a section of UUIDv7 SHOULD be used as fixed-length dedicated counter bits that are incremented by one for every UUID generation.\r\n\r\nCould be MUST if we would prohibit a counter shorter than 12 bits. Alternatively, we can reword this sentence not to mention `rand_a`. The RFC already provides guidance of 12 to 42 bits for counters. That should be sufficient.\r\n\r\n[6.8. Unguessability](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-07#name-unguessability)\r\n\r\n> 2. Care SHOULD be taken to ensure the CSPRNG state is properly reseeded upon state changes, such as process forks, to ensure proper CSPRNG operation.\r\n\r\nMUST is ideal, but note that in some environments it is very difficult or often impossible to reseed CSPRNG upon fork. We should perhaps keep SHOULD.\r\n",
          "createdAt": "2023-07-12T16:04:01Z",
          "updatedAt": "2023-07-12T16:04:01Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@kyzer-davis Here's a PR for this https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/119.  @LiosK I think I've addressed your concerns as well.",
          "createdAt": "2023-07-16T20:27:02Z",
          "updatedAt": "2023-07-16T20:27:02Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Will review tomorrow.\r\nRe-submission to IETF does not re-open until 7-22 anyway because of IETF 117.",
          "createdAt": "2023-07-17T19:53:54Z",
          "updatedAt": "2023-07-17T19:53:54Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "I_kwDOH6Ln3M5rGrDg",
      "title": "Discuss \"front-loaded rollover counter\" for 32-bit epoch with Padding method",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/115",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From individual mailer:\r\n\r\nProposed new text:\r\n> Padding:\r\n> When timestamp padding is required, implementations MUST pad the most significant bits (left-most) bits. An example is padding the most significant, left-most bits of a Unix timestamp with zeros to fill out the 48 bit timestamp in UUIDv7. **An alternative is to pad the most significant, left-most bits with the number of  32 bit Unix timestamp roll-overs after 2038-01-19.**\r\n",
      "createdAt": "2023-07-10T14:31:53Z",
      "updatedAt": "2023-07-24T19:40:30Z",
      "closedAt": "2023-07-24T19:40:30Z",
      "comments": []
    },
    {
      "number": 116,
      "id": "I_kwDOH6Ln3M5rGrhB",
      "title": "AD Review: Add proper references to v1 and v6",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/116",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Murray,\r\n> GIven the opening text of Section 5.6, should UUID v1 include a forward reference to here?  My thinking is that someone implementing UUID v1 might not read all the way to this section and thus miss the hints that this version is preferred for new applications.\r\n- Makes sense, I can add a reference back to the UUIDv1 section.\r\n\r\n> Same question about 5.7 and UUID versions 1 and 6.\r\n - Agreed, better to be consistent.\r\n",
      "createdAt": "2023-07-10T14:32:57Z",
      "updatedAt": "2023-07-24T19:40:30Z",
      "closedAt": "2023-07-24T19:40:30Z",
      "comments": []
    },
    {
      "number": 117,
      "id": "I_kwDOH6Ln3M5rW0bR",
      "title": "ISO OID acronym",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/117",
      "state": "CLOSED",
      "author": "danielmarschall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nIn 2020, I reported [errata 6225 for RFC4122](https://www.rfc-editor.org/errata/eid6225)\r\n\r\nThe errata is mentioned in the changelog of \"draft-00\", so I guess it was fixed. Thank you for this change.\r\n\r\nHowever, there is another reference where it says \"ISO OID\", in Appendix A.  It should be called \"Object Identifier (OID)\".\r\n\r\nI also mentioned in Errata 6225, that I think it would be important to define how the OID should be defined, so I think it should mention in parentheses \"In dot-notation without leading dot, e.g. **2.999**\".\r\n\r\nWhat do you think?",
      "createdAt": "2023-07-12T14:46:20Z",
      "updatedAt": "2023-07-17T19:48:14Z",
      "closedAt": "2023-07-17T19:48:14Z",
      "comments": [
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(You can completely delete issue #117 since I have created a pull request #118. I thought these would automatically merge and not generate a new issue number).",
          "createdAt": "2023-07-12T21:44:43Z",
          "updatedAt": "2023-07-12T21:44:43Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> (You can completely delete issue #117 since I have created a pull request #118. I thought these would automatically merge and not generate a new issue number).\r\n\r\nThey merge if you say something like close #117.\r\n\r\n\r\n",
          "createdAt": "2023-07-12T22:09:32Z",
          "updatedAt": "2023-07-12T22:09:32Z"
        }
      ]
    },
    {
      "number": 120,
      "id": "I_kwDOH6Ln3M5ry4z6",
      "title": "AD Review: Remove SHOULD in section 4",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/120",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Why the \"SHOULD\" in Section 4?\r\n\u2022\tThere are a number of other ways to encode 128 bits, \u201chex-and-dash\u201d is one such way. Binary is another, URN is a third. \r\n\u2022\tI guess it doesn\u2019t require any SHOULD/MAY/MUST verbiage? Is that the point?\r\n\r\nYes.  SHOULD, when written that way, means you really ought to do this, but there might be reasons you don't, and as long as you really understand what you're doing, you can deviate from this without impacting interoperability.  But in leaving such a choice to an implementer, it's helpful to provide some guidance around when it's OK to deviate, and also to understand the potential impact of deviating.\r\n\r\nSo, for example: Why might I use binary or URN?  What's the impact of not using hex-and-dash?\r\n\r\nIf a producer and consumer fail utterly to interoperate if you don't use hex-and-dash, use MUST.  If it really doesn't matter all that much, use MAY.  If the other syntaxes will work but there are possibly serious implications of using them, that's SHOULD, and it's a good idea to include a sentence or two about the issues.\r\n\r\nOr if all of this is too much to think about, try this on for size: Change \"SHOULD be\" to \"is typically\".\r\n",
      "createdAt": "2023-07-17T19:50:56Z",
      "updatedAt": "2023-07-24T19:40:31Z",
      "closedAt": "2023-07-24T19:40:31Z",
      "comments": []
    },
    {
      "number": 121,
      "id": "I_kwDOH6Ln3M5sygRC",
      "title": "DNSDIR Review: DNS Considerations Update",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/121",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From Email:\r\n```\r\nReviewer: Florian Obser\r\nReview result: Ready with Issues\r\n\r\nI have been selected as the DNS Directorate reviewer for this draft. The DNS Directorate seeks to review all DNS or DNS-related drafts as they pass through IETF last call and IESG review, and sometimes on special request. The purpose of the review is to provide assistance to the ADs.\r\nFor more information about the DNS Directorate, please see https://wiki.ietf.org/en/group/dnsdir\r\n\r\nThis document reference the DNS as one of multiple possible name spaces for Name-Based UUID Generation. It has no considerations that reflect on the DNS.\r\n\r\nIssue:\r\n\r\nThe document does not reference any DNS RFCs.\r\n\r\nSection 5.3, 5.5 and 6.5 refer to \"a canonical sequence of octets in network byte order\". It is not specified what that canonical sequence is nor is there a reference to a document that specifies the canonical sequence for any of the name spaces.\r\n\r\nSection 6.5 also has this:\r\n   *  UUIDs generated at different times from the same name in the same\r\n      namespace MUST be equal.\r\n\r\nIt is unclear to me how to implement that MUST if there is not a single canonical sequence specified for a given name space, as is the case for DNS.\r\n\r\nFor DNS RFC 8499 has this:\r\n      Format of names: Names in the global DNS are domain names.  There\r\n      are three formats: wire format, presentation format, and common\r\n      display.\r\n\r\nThe test vectors in Appendix C use the common display format, i.e. they leave off the root label and the \".\" before it.\r\n\r\nI'm not sure how best to address this issue, options include:\r\n- refer to specifications for all the name spaces and point at the\r\n  canonical sequence (in case of DNS this means RFC 8499 and choosing\r\n  common display)\r\n- mark it out of scope, like is done for \"uniqueness within their name\r\n  spaces\".\r\n- mark it out of scope, but point out that applications must (MUST?)\r\n  agree on what the canonical sequence is.\r\n```\r\n\r\n**Author comment:** \r\n- Option 1: at first seems logical way to solve this. We can also note the same for URL, OID, X500 and add a \"Note on Names\" section to \"6.5. Name-Based UUID Generation\"\r\n- Option 2:  also seems logical, can provide an example citing RFC 8499 and show that there are 3 possible ways to ways to represent DNS (Common: `www.example.com`, Presentation: `www.example.com.`, Wire: `3www7example3com0`) and the one selected for \"name\" input is up to the implementor.\r\n- Option 3: similar to option 2 but much more hand waving \r\n\r\n**Personal Preference:** \r\n- Leaning Option 2, may also need to back out #117/#118 which added OID dot notation guidance e.g \"Object Identifiers (OIDs) in dot-notation without leading dot\" \r\n\r\n**Reasoning:** \r\n- Current Name-space UUID generators allow arbitrary input from my most resent testing. (uuidgen, python, uuidtools.com, etc.)\r\n- I would like to be able to cite [URL](https://datatracker.ietf.org/doc/html/rfc1738), [OID](https://www.itu.int/rec/T-REC-X.660), [X500](https://www.itu.int/rec/T-REC-X.500), [DNS](https://datatracker.ietf.org/doc/html/rfc8499) as informative references.",
      "createdAt": "2023-07-27T20:37:18Z",
      "updatedAt": "2023-08-04T13:20:16Z",
      "closedAt": "2023-08-04T13:20:15Z",
      "comments": [
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Personally, I would be glad if all four namespaces would receive a notation guidance, for example\r\n* URL => FQDN\r\n* OID => dot-notation without leading dot\r\n* X500 => text representation [but I think this breaks RFC4122 backwards compatibility where it says text or DER notation?]\r\n* DNS => common format\r\n\r\nThis way, we can assume that equal UUID means that the same name was used, and in general I think it is always good to have canonical formats",
          "createdAt": "2023-07-28T07:52:46Z",
          "updatedAt": "2023-07-28T07:52:46Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In case you decide to rollback #117 and #118, please make sure that the term \"ISO OID\" (errata 6225) don't get reintroduced. It should be \"OID\" or \"Object Identifier (OID)\". Thank you.",
          "createdAt": "2023-07-28T07:56:02Z",
          "updatedAt": "2023-07-28T07:56:02Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> In case you decide to rollback #117 and #118, please make sure that the term \"ISO OID\" (errata 6225) don't get reintroduced. It should be \"OID\" or \"Object Identifier (OID)\". Thank you.\r\n\r\nYeah, understood on the point.",
          "createdAt": "2023-07-28T16:17:15Z",
          "updatedAt": "2023-07-28T16:17:15Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Taking Option 2 to keep them as ambiguous as were in RFC 4122 but also adding another set of namespace identifiers with strict notation guidance to ensure future interoperability?",
          "createdAt": "2023-07-30T00:22:22Z",
          "updatedAt": "2023-07-30T00:22:22Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK, @bradleypeabody, @danielmarschall:\r\nI took a stab at this in https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/7c6026b0690d0b8535cbf1e154b95aabd34168bb\r\n\r\nLet me know what you think.",
          "createdAt": "2023-07-31T19:53:49Z",
          "updatedAt": "2023-07-31T19:53:49Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me, I have no objection.",
          "createdAt": "2023-07-31T21:31:55Z",
          "updatedAt": "2023-07-31T21:31:55Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have a few requests for the OIDs in the section \"A note on names\":\r\n\r\n- The Cisco OID (1.3.6.1.4.1.9) should not be used as an example, since there is a special example OID (2.999) for the purpose of documentation.\r\n\r\n- Besides the dot notation (`2.999` or `.2.999`), there are two other important notations:\r\n\r\n    - There is also the Abstract Syntax Notation One (ASN.1) notation in various forms, e.g. (including but not limited to):\r\n`{ 2 999 }`, `{ joint-iso-itu-t(2) example(999) }`, or `{ joint-iso-itu-t example(999) }`.\r\n\r\n    - As well as the Internationalized Resource Identifier (OID-IRI) notation in various forms, e.g. (including but not limited to):\r\n`/2/999`, `/Joint-ISO-ITU-T/Example`, or `/Example`.\r\n\r\n    - The reference for ASN.1 and OID-IRI notation is Rec. ITU-T X.680 | ISO/IEC 8824-1.\r\n\r\n\r\nI am unsure about creating a pull request, because I want to avoid that you have trouble with a change conflict if I change something that already has a pull request.\r\n\r\nCan you please make these two changes for me? Thank you very much.\r\n",
          "createdAt": "2023-08-01T08:24:11Z",
          "updatedAt": "2023-08-01T08:29:26Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM!",
          "createdAt": "2023-08-01T18:02:26Z",
          "updatedAt": "2023-08-01T18:02:26Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, yeah I can switch it to `2.999` and `.2.999` I wasn't aware of that Example OID but I know the Cisco one by heart :) \r\n\r\nAs for the second item, I will see what I can do to cite X.680 but I dont' know if we need any further examples since the text is already getting long and the point that \"these things can be represented in many different ways\" is sufficiently detailed.\r\n\r\nEdit: done Check below, added a single X.680 example since we got some space back from removing the Cisco OID.\r\nhttps://github.com/ietf-wg-uuidrev/rfc4122bis/pull/124/commits/972e2e4a05beb5fcf22a115db8c3a2072d09e66c\r\n\r\nEdit2: X.660 > X.680",
          "createdAt": "2023-08-01T18:54:30Z",
          "updatedAt": "2023-08-01T21:02:29Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @danielmarschall, yeah I can switch it to `2.999` and `.2.999` I wasn't aware of that Example OID but I know the Cisco one by heart :)\r\n\r\nI haven't seen 2.999 often, but I am very proud of it, because I was literally its inventor 12 years ago :)\r\n\r\n> As for the second item, I will see what I can do to cite X.680 but I dont' know if we need any further examples since the text is already getting long and the point that \"these things can be represented in many different ways\" is sufficiently detailed.\r\n> \r\n> Edit: done Check below, added a single X.660 example since we got some space back from removing the Cisco OID. [972e2e4](https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/972e2e4a05beb5fcf22a115db8c3a2072d09e66c)\r\n\r\nThank you very much. It is compact and your wording includes all possible notations of X.680, so it's perfect. \ud83d\udc4d",
          "createdAt": "2023-08-01T20:54:46Z",
          "updatedAt": "2023-08-01T20:54:46Z"
        }
      ]
    },
    {
      "number": 122,
      "id": "I_kwDOH6Ln3M5syg0V",
      "title": "DNSDIR Review: Typos!",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/122",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\n4.  UUID Format\r\nold: the version bits described in the next sections in determine\r\nnew: the version bits described in the next sections determine\r\n\r\n6.5.  Name-Based UUID Generation\r\nold: but the hashspace should be used to as the starting point\r\nnew: but the hashspace should be used as the starting point\r\n```",
      "createdAt": "2023-07-27T20:38:55Z",
      "updatedAt": "2023-08-04T13:20:16Z",
      "closedAt": "2023-08-04T13:20:16Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Update: Also caught by GENART review.",
          "createdAt": "2023-08-03T13:04:08Z",
          "updatedAt": "2023-08-03T13:04:08Z"
        }
      ]
    },
    {
      "number": 123,
      "id": "I_kwDOH6Ln3M5syiUU",
      "title": "Late addition of IETF reference for CSPRNG guidance",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/123",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Can cite [RFC 8937 Randomness Improvements for Security Protocols](https://www.rfc-editor.org/rfc/rfc8937.html)\r\nNote that [RANDOM](https://peteroupc.github.io/random.html) citation also cites this (and RFC4086 which we also cite)\r\n\r\nPersonally feel like it can't hurt to have another direct reference in the event RANDOM reference goes away.",
      "createdAt": "2023-07-27T20:43:15Z",
      "updatedAt": "2023-08-04T13:20:17Z",
      "closedAt": "2023-08-04T13:20:17Z",
      "comments": []
    },
    {
      "number": 125,
      "id": "I_kwDOH6Ln3M5tFp-n",
      "title": "Binary prefix usage in prose",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/125",
      "state": "CLOSED",
      "author": "tgross35",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Is there any precedent for adding a prefix such as `0b` to indicate that a number is presented in binary? There are a handful of places where I could see this making sense, for example in section 5.6\r\n\r\n```\r\n   var:\r\n      The 2 bit variant field as defined by Section 4.1 set to 10.\r\n      Occupies bits 64 and 65 of octet 8.\r\n```\r\n\r\nI would find it more clear to see `set to 0b10`, confirming the value to be a decimal 2 rather than decimal 10.",
      "createdAt": "2023-07-31T23:15:35Z",
      "updatedAt": "2023-08-04T13:21:54Z",
      "closedAt": "2023-08-04T13:21:54Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, we have a few places where 0b is defined (mostly in the appendix test vectors) but I can see the value here. I will sneak it in.",
          "createdAt": "2023-08-01T18:55:27Z",
          "updatedAt": "2023-08-01T18:55:27Z"
        }
      ]
    },
    {
      "number": 126,
      "id": "I_kwDOH6Ln3M5tFtNw",
      "title": "Stronger v7 > v6 > v1 preference claims",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/126",
      "state": "CLOSED",
      "author": "tgross35",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Would it make sense to be slightly more unambiguous that users should prefer v7, then v6, then v1 for time-based UUIDs?\r\n\r\nIn this document, v1 is referred to as \"Gregorian time-based  UUID\", v6 as \"Reordered Gregorian time-based UUID\", and v7 as \"Unix Epoch time-based UUID\". I am wondering if there may be value in renaming v1 and v6 to make it more clear that v6 is the preferred version of the two. For example, v1 could be referred to as \"Compatible Gregorian time-based UUID\" or \"Legacy Gregorian...\" and v6 as \"Normalized Gregorian time-based UUID\", or similar.\r\n\r\nOtherwise, it seems that section `5.1. UUID Version 1` should contain language indicating that v7 is preferred where possible. Section `5.6.  UUID Version 6` states in the first paragraph `Systems that do not involve legacy UUIDv1 SHOULD use UUIDv7 instead.` - it seems like a similar statement would be suitable in section 5.1 as well.\r\n\r\n(this may have been discussed elsewhere but I have not seen it)",
      "createdAt": "2023-07-31T23:29:30Z",
      "updatedAt": "2023-08-04T13:22:59Z",
      "closedAt": "2023-08-04T13:22:59Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Nobody has brought up the names as far as I can tell with no strong opposition as to what they are describes as in that version table. I would be hesitant to change those this late in the process. \r\n\r\nAs for discouraging v1 in lieu of v7:\r\nWe could add some text like:\r\n> It should be noted that this section is included for historical purposes. Implementations that require time-based UUIDs SHOULD use UUIDv7 {{UUIDv7_section_link}}.",
          "createdAt": "2023-08-01T19:11:05Z",
          "updatedAt": "2023-08-01T19:11:05Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Will let this one sit a bit to garner a few more thumbs up/down and/or discussion on the topic of marking \"UUIDv1\" legacy and pointing to v7. Again, somewhat late in the process so \"big\" changes like formally deprecating v1 within v1 section vs what is done in v6 section would need strong group feedback.\r\n\r\nIMO the difference is that the text in v6 is saying \"hey if you are implementing a new UUID type in 2023+ just do v7 vs bit swapping of v1\" but saying \"v1 is terrible use v7\" could be a bridge too far. \r\n\r\n@bradleypeabody @LiosK whatcha think?",
          "createdAt": "2023-08-01T20:50:57Z",
          "updatedAt": "2023-08-01T20:50:57Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think that the new versions v6-v8 are great, but \r\nI am not sure if v7 could be described as a 100% successor of v1.\r\n\r\nI think the **_direct_** successor of v1 is v6 because v6 has everything v1 has, just better (because it is ordered).\r\n\r\nv7 has some differences which **_some_** people could argue as being disadvantages, making it not a 100% successor of v1:\r\n1. The time resolution is not as good as in v1. When you create a lot of UUIDv7 and want that they are in the correct order, the code must sleep for 1 millisecond between UUIDv7 generations.\r\n2. The MAC address - which some people or applications might consider useful metadata - is not available.\r\n3. The random data could **_theoretically_** cause a collision, but very very very unlikely\r\n\r\nI personally think that v6 and v7 are both equally good, and people could choose either v6 or v7, depending if they are okay with their MAC address included in the UUID or not.\r\n",
          "createdAt": "2023-08-02T00:37:56Z",
          "updatedAt": "2023-08-02T00:37:56Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I echo @danielmarschall's comment and advise to \"leave it as is\" with no text change to v1",
          "createdAt": "2023-08-02T14:24:58Z",
          "updatedAt": "2023-08-02T14:24:58Z"
        },
        {
          "author": "tgross35",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That comment makes sense, I did not consider the resolution / MAC components.\r\n\r\nI do still think it may make sense to add something along the lines of `use cases that do not already employ v1 UUIDs will likely prefer  using v6 or v7 for improved ordering` - just to help answer the question of \"when should I use this\" early on. I think somebody may have brought this up on the list recently? However, I do understand that this may be considered too big a change at this point.",
          "createdAt": "2023-08-02T16:10:26Z",
          "updatedAt": "2023-08-02T16:10:26Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My understanding is that v6 is introduced primarily for round-trip conversions from/to v1 and for ease of implementation utilizing the existing v1 generators. In this sense, v6 is like introduced for backward compatibility purposes, and thus it is natural to recommend v7 over v6 for other fresh-new use cases. Anyway, Sections 5.6 and 5.7 are clear enough that v7 is recommended over v6.\r\n\r\nNow I was just wondering: should we recommend v6/v7 over v1? v1 and v6/v7 are both time-based but have different characteristics and use cases. v6/v7 isn't superior just because they are ordered. Some will choose v6/v7 if they need ordering while others might choose v1 otherwise. Now I don't really find a strong reason why we should discourage v1.\r\n",
          "createdAt": "2023-08-03T13:20:39Z",
          "updatedAt": "2023-08-03T13:20:39Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Going to close this one since the consensus seems to be that we do not need text changes in v1 section.",
          "createdAt": "2023-08-04T13:22:59Z",
          "updatedAt": "2023-08-04T13:22:59Z"
        }
      ]
    },
    {
      "number": 127,
      "id": "I_kwDOH6Ln3M5tHxzY",
      "title": "Hash Space IDs",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/127",
      "state": "CLOSED",
      "author": "danielmarschall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\r\nThe UUIDv8 contains custom, vendor-specific data and theoretically, the description of the contents would be out-of-scope for the RFC.\r\n\r\nHowever, I agree that the sections \"Example of a UUIDv8 Value (time-based)\" and \"Example of a UUIDv8 Value (name-based)\" are good because they give people some inspiration about how a custom UUID could be designed.\r\n\r\nBut I am confused about the \"Some Hash Space IDs\" section because it is a main section, instead of a sub-section in the \"Example of a UUIDv8\" section. If I understand correctly, these Hash Space IDs are only used in this example, so I think they should be directly listed in the example.\r\n\r\nWhat do you think?\r\n",
      "createdAt": "2023-08-01T08:39:34Z",
      "updatedAt": "2023-08-04T13:20:17Z",
      "closedAt": "2023-08-04T13:20:17Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think it matters one way or the other by having them part of the test vector or as its own section. I just mimic'd what was done with name spaces and copy and pasted the section. I think I created the test vector later so that is probably why the hash space is after the name space section.\r\n\r\nIf anything I should probably just provide a reference in that test vector back to the hash space appendix.\r\n\r\nI am trying to avoid changing too much here late in the state of IETF review and since it does not really help I will just add the missing appendix reference as the most minimal change.",
          "createdAt": "2023-08-01T19:33:35Z",
          "updatedAt": "2023-08-01T19:33:35Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I hope you don't consider it as \"spam\", but I wanted to share that I have implemented the UUIDv8 namebased concept in my [open source solution](http://github.com/danielmarschall/uuid_mac_utils) and it can be tested here: https://misc.daniel-marschall.de/tools/uuid_mac_decoder/index.php#gen_uuidv35\r\n... In case someone finds it useful (i.e. to generate or verify test vectors; I could reproduce that the SHA2-256 test vector `401835fd-a627-870a-873f-ed73f2bc5b2c` is correct.)",
          "createdAt": "2023-08-02T23:06:48Z",
          "updatedAt": "2023-08-02T23:06:48Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, nope! I am a big advocate for real testing which provides valuable insight.\r\nI have a prototype page here if you want to open a PR and cite the latest IETF draft for your v8 solution!\r\nhttps://github.com/uuid6/prototypes",
          "createdAt": "2023-08-03T13:07:41Z",
          "updatedAt": "2023-08-03T13:07:41Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "I_kwDOH6Ln3M5tNOZ9",
      "title": "Error in UUIDv8 Name-based Test Vector",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/129",
      "state": "CLOSED",
      "author": "danielmarschall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nAt this example:\r\n\r\n```\r\n-------------------------------------------\r\nfield     bits value\r\n-------------------------------------------\r\ncustom_a  48   0x401835fda627\r\nver        4   0x8\r\ncustom_b  12   0x627\r\nvar        2   b10\r\ncustom_c  62   b0, 0x73fed73f2bc5b2c\r\n-------------------------------------------\r\ntotal     128\r\n-------------------------------------------\r\nfinal: 401835fd-a627-870a-873f-ed73f2bc5b2c\r\n```\r\n\r\nThe field `custom_b` should be `0x70a` , not `0x627`.\r\n\r\n\r\nThat being said, I noticed that the pull requests are marked as failed. I hope it is not too late for the changes",
      "createdAt": "2023-08-01T23:47:39Z",
      "updatedAt": "2023-08-04T13:20:18Z",
      "closedAt": "2023-08-04T13:20:18Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yup, bad copy and paste on my part. Thanks for the double-check. Let me get that real fast.\r\n\r\nEdit: I also noticed custom_c nees to have two 0s to be consistent with the other test-vectors. \r\nI did that over on https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/128/commits/1bad8f0decd035938927c06ca92aacea6c3dddf3 as to not create merge conflict between my outstanding Branches/PRs",
          "createdAt": "2023-08-02T14:27:29Z",
          "updatedAt": "2023-08-02T14:37:43Z"
        }
      ]
    },
    {
      "number": 130,
      "id": "I_kwDOH6Ln3M5txd6L",
      "title": "ARTART Review and Feedback",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/130",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nReviewer: Marco Tiloca\r\nReview result: Ready with Nits\r\n\r\nI reviewed this document as part of the Applications and Real-Time (ART) Area Review Team's ongoing effort to review all IETF documents being processed by the IESG. These comments were written primarily for the benefit of the ART Area Directors. Document authors, document editors, and WG chairs should treat these comments just like any other IETF Last Call comments.\r\n\r\n[Section 2.1]\r\n\r\n* As expanded format for UUID version, point 4 uses \"Version 1 UUIDs\". Later in the document, a different expanded format is used, i.e., \"UUID Version 1\" in Section 5.1.\r\n\r\n   It would be better to consistently use a single expanded format to indicate\r\n   the UUID version throughout the document. The format \"UUID Version 1\" seems\r\n   a better choice.\r\n\r\n   A note about the equivalence of \"UUIDvX\" and \"Version X UUIds\" can be worth\r\n   adding in Section 3.2 \"Abbreviations\".\r\n\r\n* On points 5 and 6, please have RFC 4122 as an actual reference.\r\n\r\n* \"RFC4122 did not distinguish between the requirements for generation of a UUID versus an application that simply stores one, which are often different.\"\r\n\r\n   Suggested rephrasing:\r\n\r\n   \"RFC4122 did not distinguish between the requirements for generating a UUID\r\n   and those for simply storing one, although they are often different.\"\r\n\r\n[Section 4]\r\n\r\n* s/is 16 octets (128 bits);/is 16 octets (128 bits) in size;\r\n\r\n[Section 5.0]\r\n\r\n* \"within bit layout consisting four octets to a row\"\r\n\r\n   I think you mean \"within a bit layout consisting of four octets per row\"\r\n\r\n[Section 6.1]\r\n\r\n* \"The length of a given timestamp directly impacts how long a given UUID will be valid. ... UUID version 1 and 6 utilize a 60 bit timestamp valid until 5623 AD and UUIDv7 features a 48 bit timestamp valid until the year 10889 AD.\"\r\n\r\n   I am not sure that \"valid\" is the best word here, as it makes (me) think\r\n   more about security aspects such as time-based access control rules for\r\n   accepting a timestamp that is otherwise possible to understand and process.\r\n\r\n   Also, let's say that a UUIDv7 is released before 10889 AD. Does the passing\r\n   of 10889 AD per se automatically make the UUID not *valid*? I think it just\r\n   means that no more UUIDs Version 7 can be issued from then on, right?\r\n\r\n   I believe you actually refer to the impact on the time span during which a\r\n   UUID can be generated. Like mentioned in the second sentence of the\r\n   paragraph, then it boils down to how many UUIDs one can generate before the\r\n   maximum value for the timestamp field is reached.\r\n\r\n   Perhaps it's just better to focus on the length of the time span that the\r\n   timestamps cover (see above).\r\n\r\n[Section 6.5]\r\n\r\n* \"An important note for secure hashing algorithms that produce variable rate outputs, such as those found in SHAKE, ...\"\r\n\r\n   I guess you actually mean \"produce outputs of arbitrary size\", right?\r\n\r\n[Nits]\r\n\r\n* Section 2.1\r\n- s/is as database keys/is database keys\r\n- s/The negative performance effects of which/The resulting negative performance effects - s/has lead/has led\r\n\r\n* Section 4.0\r\n- s/Binary Figure 2/Binary (Figure 2)\r\n- s/Integer Figure 3/Integer (Figure 3)\r\n- s/URN Figure 4/URN (Figure 4)\r\n- s/of Table 1/of Table 1.\r\n\r\n* Section 4.1\r\n- s/document bits 64/document, bits 64\r\n\r\n* Section 5.1\r\n- s/The 14-bits/The 14 bits\r\n- s/clock sequence associated/the clock sequence associated\r\n\r\n* Section 5.2\r\n- s/such the definition/such, the definition\r\n\r\n* Section 5.3\r\n- s/Where possible UUIDv5/Where, possible UUIDv5\r\n\r\n* Section 5.5\r\n- s/As such it/As such, it\r\n\r\n* Section 5.6\r\n- s/where there are existing v1 UUIDs/where UUIDv1 is used\r\n- s/With UUIDv6 the steps/With UUIDv6, the steps\r\n\r\n* Section 5.8\r\n- s/bits are the version and variant/bits are those of the version and variant fields\r\n\r\n* Section 5.10\r\n- s/The Max UUID is special form/The Max UUID is a special form\r\n\r\n* Section 6\r\n- s/and up to the implementer/and it is up to the implementer\r\n\r\n* Section 6.1\r\n- s/Take care to ensure/Care must be taken to ensure\r\n- s/with zeros to fill/with zeroes to fill\r\n- s/to counter rollover/to a counter rollover\r\n\r\n* Section 6.2\r\n- s/unguessablity/unguessability\r\n- s/Take care to/Care must be taken to\r\n- s/by ensuring the total/by ensuring that the total\r\n- s/As such the/As such, the\r\n\r\n* Section 6.4\r\n- s/that although this ... completeness; implementations/that, although this ... completeness, implementations\r\n\r\n* Section 6.5\r\n- s/select of of the/select one of the\r\n- s/Ensure the version and variant and variant bits/ Ensure that the version and variant bits - s/to detail SHA-256 was used to create a given UUIDv8 name-based UUID an/to detail that SHA-256 was used to create a given UUIDv8 name-based UUID, an - s/this need not be/this needs not be\r\n\r\n* Section 6.9\r\n- s/node ID set to one to create/node ID to 1, in order to create\r\n\r\n* Section 12\r\n- s/and thus maybe simpler/, which thus may make it simpler\r\n```\r\n\r\nShould be able to fix all of these with editorial updates in a single PR.\r\nNo technical items that I can surmise upon first review.",
      "createdAt": "2023-08-08T16:59:22Z",
      "updatedAt": "2023-08-23T13:55:03Z",
      "closedAt": "2023-08-23T13:55:03Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed everything except the following which seems incorrect:\r\n\r\n```\r\n* Section 5.3\r\n- s/Where possible UUIDv5/Where, possible UUIDv5\r\n```\r\n",
          "createdAt": "2023-08-14T22:14:23Z",
          "updatedAt": "2023-08-14T22:14:23Z"
        }
      ]
    },
    {
      "number": 132,
      "id": "I_kwDOH6Ln3M5uXHVo",
      "title": "Clarify Hash Space IDs listed are not the only options",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/132",
      "state": "CLOSED",
      "author": "danielmarschall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "It's probably too late for any amendments, so maybe it will only be an errata after publishing instead.\r\n\r\n_Appendix B:\r\nThis appendix lists **_the_** hash space IDs for use with UUIDv8 name-based UUIDs._\r\n=> The word \"the\" suggests that there can only be these hash space IDs and nothing else.\r\n\r\nIn comparison:\r\n_Appendix A:\r\nThis appendix lists **the** name space IDs **for some** potentially interesting name spaces_ \r\n=> so appendix A implies that there can be many name space IDs.\r\n\r\n\r\nMy suggestion is that for Appendix B, remove the word \"the\" or replace it is \"some\", to imply that there can be other hash space IDs. (I guess this was your intention)\r\n",
      "createdAt": "2023-08-15T14:36:14Z",
      "updatedAt": "2023-08-23T13:55:04Z",
      "closedAt": "2023-08-23T13:55:04Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, I can sneak that in to my open PR.",
          "createdAt": "2023-08-15T18:01:14Z",
          "updatedAt": "2023-08-15T18:01:14Z"
        }
      ]
    },
    {
      "number": 133,
      "id": "I_kwDOH6Ln3M5u8xad",
      "title": "Add example to timestamp fuzzing",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/133",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From: https://github.com/uuid6/uuid6-ietf-draft/issues/127",
      "createdAt": "2023-08-22T13:05:01Z",
      "updatedAt": "2023-08-23T13:55:04Z",
      "closedAt": "2023-08-23T13:55:04Z",
      "comments": []
    },
    {
      "number": 134,
      "id": "I_kwDOH6Ln3M5vUIj5",
      "title": "IANA Review: Verbiage to update RFC4122 references",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/134",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "> \"All references to RFC 4122 in the IANA registries should be replaced with references to this document. References to that document's Section 4.1.2 should be updated to refer to this document's Section 4.\"\r\n\r\n> https://www.iana.org/assignments/urn-namespaces/\r\n> https://www.iana.org/assignments/cbor-tags/\r\n> https://www.iana.org/assignments/urn-formal/cdx\r\n> https://www.iana.org/assignments/uri-schemes/prov/teliaeid",
      "createdAt": "2023-08-25T18:58:47Z",
      "updatedAt": "2023-09-05T15:23:30Z",
      "closedAt": "2023-09-05T15:23:29Z",
      "comments": []
    },
    {
      "number": 135,
      "id": "I_kwDOH6Ln3M5vcuNn",
      "title": "Crosspost: Typo in Approximate UUID timestamp calculations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/135",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "From https://github.com/uuid6/uuid6-ietf-draft/issues/131",
      "createdAt": "2023-08-28T13:45:20Z",
      "updatedAt": "2023-09-05T15:23:30Z",
      "closedAt": "2023-09-05T15:23:30Z",
      "comments": []
    },
    {
      "number": 136,
      "id": "I_kwDOH6Ln3M5vcvBy",
      "title": "DNSDIR re-review: Better Define \"a canonical sequence of octets\"",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/136",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nReviewer: Geoff Huston\r\nReview result: Ready with Issues\r\n\r\nI have been selected as the DNS Directorate reviewer for this draft. The DNS Directorate seeks to review all DNS or DNS-related drafts as they pass through IETF last call and IESG review, and sometimes on special request. The purpose of the review is to provide assistance to the ADs.\r\nFor more information about the DNS Directorate, please see https://wiki.ietf.org/en/group/dnsdir\r\n\r\nThis document references the DNS as one of multiple possible name spaces for Name-Based UUID Generation. It has no considerations that reflect on the DNS.\r\n\r\nPrevious iterations of this draft have been reviewed by the DNS Directorate for the -08 [1]  and -09 [2] versions of this draft.\r\n\r\nThe changes between -09 and -10 address specific comments from the ATART review and make some clarifying changes to the document which do not appear to have a substantive impact on the specification.\r\n\r\nIssue:\r\n\r\nI would like to note that the issues noted in the DNSDIR -08 review [1], namely:\r\n\r\n  \"Section 5.3, 5.5 and 6.5 refer to \"a canonical sequence of octets in\r\n   network byte order\". It is not specified what that canonical sequence\r\n   is nor is there a reference to a document that specifies the canonical\r\n   sequence for any of the name spaces.\"\r\n\r\nand \r\n\r\n  \"Section 6.5 also has this:\r\n     *  UUIDs generated at different times from the same name in the same\r\n        namespace MUST be equal.\"\r\n        \r\ndo not appear to have been resolved in -09 or -10 versions of this document.\r\n\r\nThe suggestions made in the -08 review on how to to resolve this issue appears not to have been resolved in any tangible manner in the subsequent document versions\r\n\r\n\r\nGeoff Huston\r\n\r\n[1] https://datatracker.ietf.org/doc/review-ietf-uuidrev-rfc4122bis-08-dnsdir-lc-obser-2023-07-26/\r\n[2] https://datatracker.ietf.org/doc/review-ietf-uuidrev-rfc4122bis-09-dnsdir-lc-obser-2023-08-04/\r\n```\r\n\r\nThread: https://mailarchive.ietf.org/arch/msg/uuidrev/hFiEUoa4BIQ_VGO5HX5kV18BIEE/",
      "createdAt": "2023-08-28T13:47:09Z",
      "updatedAt": "2023-09-05T15:23:30Z",
      "closedAt": "2023-09-05T15:23:30Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Replied via email here: https://mailarchive.ietf.org/arch/msg/uuidrev/njBLWEdlHpp_nZu1MrT9_1rpPzI/\r\n\r\nWill update this thread with any changes that are needed.",
          "createdAt": "2023-08-28T13:47:35Z",
          "updatedAt": "2023-08-28T13:47:35Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Major issue is around \u201ccanonical\u201d verbiage from RFC4122 as per Geoff:\r\n\r\n```\r\nIt looks like you have taken the text in section 4.3 of RFC4122 \r\n\r\n\"Convert the name to a canonical sequence of octets (as defined by the standards or conventions of its name space); put the name space ID in network byte order.\u201d\r\n\r\nand rephrased it in this draft.\r\n\r\nMy question remains - what is a \u201ccanonical\u201d sequence of octets? Or even its opposite - what is a sequence of octets that is NOT \u201ccanonical\u201d?\r\n\r\nIn a standards document it seems reasonable to ask for extremely clear specifications, and I just don\u2019t understand what you are getting at with the use of the term \u201ccanonical\u201d here.\r\n```\r\n\r\nSource: https://mailarchive.ietf.org/arch/msg/uuidrev/WAMXvzzcXTLF-lGXBIJWenIcJ-4/",
          "createdAt": "2023-08-28T18:10:42Z",
          "updatedAt": "2023-08-28T18:12:57Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "My suggestion: https://mailarchive.ietf.org/arch/msg/uuidrev/uEIwBdg24NGF9MCuOiqQdtzjlqc/\r\n\r\n```\r\nPersonally, I have never been a fan of \"canonical\" verbiage in the original document, so I suggest we remove it from the text.\r\n>From what I can see \"canonical\" usage is just a fancy way of saying \"Select a Name value formatted as per the underlying specs usual representation format\". Sources: [1][2][3].\r\n\r\nFor example in UUIDv3, with \"canonical\" removed, the text would say:\r\n> UUIDv3 values are created by computing an MD5 [RFC1321] hash over a given name space value concatenated with the desired name value after both have been converted to a sequence of octets in network byte order.\r\n\r\nThen I can add a line above the Appendix callout for Namespaces with guidance on how to select said name value and representation from an underlying spec when there are many to choose from.\r\n\r\n> Information around selecting a desired name value's representation/conveyance format within a given name space can be found in section 6.5, \"A note on names\".\r\n> Some common namespace values have been defined via Appendix A.\r\n\r\nThen repeat this for UUIDv5 and remove \"canonical\" from the v8 callout in 6.5.\r\n\r\nFinally, update the line about names and namespaces being equal to state to include a line about the representation format.\r\n> The UUIDs generated at different times from the same name (using the same name representation/conveyance format) in the same namespace MUST be equal.\r\n\r\nDefine \"canonical\":\r\n[1] https://www.gnu.org/software/libc/manual/html_node/Byte-Order.html\r\n[2] https://en.wikipedia.org/wiki/Canonicalization\r\n[3] https://en.wikipedia.org/wiki/Canonical_form\r\n```\r\n\r\nWill create a PR for this since Geoff agreed to these changes: https://mailarchive.ietf.org/arch/msg/uuidrev/MPSDMazoe6ObYcG02xfi3aQqJsk/",
          "createdAt": "2023-08-28T18:12:43Z",
          "updatedAt": "2023-08-28T18:12:43Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Alternative from Paul Leach, also okay'd by Geoff:\r\n\r\n> A canonical sequence of octets is one that conforms to the specification for that name form's canonical representation. A name can have many usual forms, only one of which can be canonical. Implementers of new namespaces for UUIDs need to use the specification for the canonical form of names in that space, or define such a canonical for the name space if it does not exist.",
          "createdAt": "2023-08-29T13:51:30Z",
          "updatedAt": "2023-08-29T13:51:30Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Re-add the \"as defined by the standards or conventions of its namespace\" \r\n\r\n> a canonical sequence of octets, as defined by the standards or conventions of its namespace, in network byte order.\r\n\r\n> a canonical sequence of octets (as defined by the standards or conventions of its namespace) in network byte order.",
          "createdAt": "2023-08-30T14:00:32Z",
          "updatedAt": "2023-08-30T14:00:32Z"
        }
      ]
    },
    {
      "number": 137,
      "id": "I_kwDOH6Ln3M5vdkuh",
      "title": "Normalize \"name space\" to \"namespace\" everywhere",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/137",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "RFC4122 used both \"name space\" and \"namespace\"\r\nAs per my searches, \"namespace\" seems to see more usage than \"name space\".\r\nHence I think we should normalize it to one word without spaces throughout the document.\r\n",
      "createdAt": "2023-08-28T15:49:53Z",
      "updatedAt": "2023-09-05T15:23:31Z",
      "closedAt": "2023-09-05T15:23:31Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Will also do the same for \"hash space\" to \"hashspace\"",
          "createdAt": "2023-08-29T18:52:20Z",
          "updatedAt": "2023-08-29T18:52:20Z"
        }
      ]
    },
    {
      "number": 139,
      "id": "I_kwDOH6Ln3M5vylwB",
      "title": "INTDIR Review",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/139",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\n## Section 1\r\n\r\nTwo sentences appear to contradict each others:\r\n\r\n- `A UUID is 128 bits long and requires no central registration process`\r\n- `In addition, a global registration function is being provided by the\r\nTelecommunications Standardization Bureau of ITU-T`\r\n\r\n## Section 2\r\n\r\nShould there be an informative reference to `IEEE 802 node identifiers` ?\r\n\r\n## Section 2.1\r\n\r\nWhat is the impact of randomised MAC address (cfr MADINAS WG and IEEE work) on\r\nbullet 4. Should this randomised MAC address be mentioned in the text ?\r\n\r\n## Section 5.1\r\n\r\nWhy only IEEE 802.3 LAN what about 802.11 or 802.15.4 ? Should the text be\r\nrelaxed ?\r\n\r\n## Section 8\r\n\r\nShould privacy be added in `MAC addresses pose inherent security risks ` ?\r\n\r\n# NITS\r\n\r\n## Section 3.3\r\n\r\nThe usual wording is more like `Note to RFC Editor: This section needs to be\r\nremoved before publication as RFC`.\r\n\r\n## Sections C.1 & C.5\r\n\r\nPlease use a documentation MAC address per section 2.1.2 of RFC 7042. *IF* the\r\nnode is assumed to be a MAC address.\r\n```\r\n\r\nSections Section 3.3 and Sections C.1 & C.5 comments can be disregarded. No change required after further discussion.",
      "createdAt": "2023-08-31T13:27:06Z",
      "updatedAt": "2023-09-05T15:23:31Z",
      "closedAt": "2023-09-05T15:23:31Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: the last item about C.1 and C.5 won't be needed since the leading text of Appendix C states this data is not a MAC but rather randomized data.\r\n> Both UUIDv1 and UUIDv6 utilize the same values in clock_seq, and node. All of which have been generated with random data.\r\n\r\nAlso, on this item:\r\n> The usual wording is more like `Note to RFC Editor: This section needs to be removed before publication as RFC`.\r\nThe text being used is from the Kramdown template item \"{:removeinrfc}\" and is generated automatically by author-tools.ietf.org when converting to XML/TXT/HTML.\r\n",
          "createdAt": "2023-08-31T13:32:33Z",
          "updatedAt": "2023-08-31T13:32:33Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In regards the \"_global registration function is being provided by the Telecommunications Standardization Bureau of ITU-T_\":\r\n\r\nActually, ITU-T had a registration function for **_UUID-OIDs_** (2.25.xx) long time ago. But since there is a 1:1 relation between UUID and UUID-OID, we can say that the registration function also applied to UUIDs.\r\n\r\nHowever, the registration function is deprecated and not used today. Long time ago, UUID-OID created at the ITU-T website had to be registered at oid-info.com. Nowadays, oid-info.com do not accept UUID-OIDs anymore, and ITU-T has dropped the rule that UUID-OID must be registered.\r\n\r\n\r\nAddendum:\r\nHere is how the page looks today https://www.itu.int/en/ITU-T/asn1/Pages/UUID/uuids.aspx\r\nand how the page looked back then https://web.archive.org/web/20061129101621/http://www.itu.int/ITU-T/asn1/uuid.html#UUID%20Generation%20&%20Registration\r\nInterestingly, they even had a contradiction back then. \"_UUIDs are registered in the OID repository as subsequent arcs of {joint-iso-itu-t(2) uuid(25)}_\" vs. \"_This enables users to generate OIDs without any registration procedure_.\"\r\n",
          "createdAt": "2023-08-31T13:43:22Z",
          "updatedAt": "2023-08-31T13:59:32Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi, I don't know if we need to be backwards compatible for EUI-48 based UUIDs, but if we don't, then I suggest upgrading 16-bit, and 48-bit OUIs to the 64-bit equivalents, and then use that.   Well, I can't find a way to turn 16-bit ones into 64-bit, and I question if 16-bit mac addresses, which are dynamically assigned in 802.15.4 networks have any entropy at all.",
          "createdAt": "2023-08-31T15:08:57Z",
          "updatedAt": "2023-08-31T15:08:57Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, interesting points! \r\n> the registration function is deprecated and not used today. \r\nI assume it would be safe to simply remove the line to avoid the contradiction.\r\n \r\n---\r\n\r\n@mcr, I think in terms of the MACs, it is worth discussing randomized MAC in that it is something I would say is acceptable \"if a MAC must be used at all\". e.g Random Data > Random MAC > Static MAC\r\n\r\nEUI-48 vs EUI-64, keep in mind where the MAC is used within v1/v6 for `node` the space is 48 bits.\r\nI think it would be easy enough to keep 48 and put a one liner about obtaining 48 bits from the 64  which should also 802.15.4 which use EUI-64 right [1]. (I wasn't able to find anything about 16-bit mac.)\r\n\r\nI also found how one could convert from 48 to 64 [2][3], I assume if FFFE is in play one could undo this conversion to get the 48 bit option. _I am not sure if there are EUI-64 MACs without FFFE..._ but in a scenario where it was not converted use left-most 48 bits?\r\n\r\n---\r\n\r\n[1] https://en.wikipedia.org/wiki/MAC_address#Applications\r\n[2] https://networkengineering.stackexchange.com/a/30864\r\n[3] https://community.cisco.com/t5/networking-knowledge-base/understanding-ipv6-eui-64-bit-address/ta-p/3116953",
          "createdAt": "2023-08-31T16:41:00Z",
          "updatedAt": "2023-08-31T16:41:00Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "802.15.4 has two formats for the L2 frame: one has 2x 64-bit slots and the other has two 2x 16-bit slots.\r\n(Actually there are mixes too).  16-bits are not assigned in any random way, so let's ignore them.\r\nIf we are mixing the 48-bits in LITERALLY, then I agree: just truncate and take lower 48.\r\nI thought it was going through a PRF for some reason.\r\n",
          "createdAt": "2023-08-31T18:25:38Z",
          "updatedAt": "2023-08-31T18:25:38Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, there are 64-bit MACs without the FFFE.  ",
          "createdAt": "2023-08-31T18:26:02Z",
          "updatedAt": "2023-08-31T18:26:02Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(Found a missing fullstop)\r\nSection 5.1.   `s/unique identifier Occupies bits/unique identifier. Occupies bits`\r\n",
          "createdAt": "2023-08-31T22:31:09Z",
          "updatedAt": "2023-08-31T22:31:09Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcr, so with this logic my changes to text include the following topics for MAC:s\r\n- Support EUI-48 based Support (e.g 802.3 and 802.11)\r\n- Support 48 Bit MACs derived from EUI-64 (Either by unwinding FFFE types or grabbing least-significant, right-most 48 bits)\r\n- Support for 802.15.4 16-bit MACs is out of scope, use some psuedorandom value in section 6.9 instead\r\n- Where randomized MACs are concerned; Supported and encouraged over static MAC but pseudorandom is better.\r\n- Section 8, explicitly call out Privacy in MAC section. \r\n- Cite all these 802.3/11/15 topics as informative references. \r\n\r\nAlternative, on the non-EUI-48 topic, since we really don't want folks using MACs. \r\nGiving more options to use a MAC could go against this... we could simply state that \"Only specifications using EUI-48 MACs are supported (802.3/802.11) and those using other types such as EUI-64 or 802.15.4 are out of scope. Instead implantations should follow what is outlined in section 6.9 to obtain a 48 bit pseudorandom value instead\" \r\n\r\nAny idea if \"IEEE 802 node identifiers\" is covered in either of these changes. I am not familiar with this.",
          "createdAt": "2023-09-01T13:22:45Z",
          "updatedAt": "2023-09-01T13:23:31Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Alternative, on the non-EUI-48 topic, since we really don't want folks using MACs.\r\n\r\nI personally like using my MAC address in my UUIDs. It allows me to give the UUIDs some kind of \"signature\", and I can easily see if these UUIDs are mine or not. I think you should leave the decision to the developers/users if they want to use a real MAC or a pseudo-random MAC, by using the unicast/multicast bit as defined in section 6.9.",
          "createdAt": "2023-09-01T13:38:00Z",
          "updatedAt": "2023-09-01T13:38:00Z"
        },
        {
          "author": "evyncke",
          "authorAssociation": "NONE",
          "body": "If you do not mind my presence in this thread...\r\n\r\nThere must be some text about 16-bit and 64-bit MAC address. This can be as simple as \"16-bit address MUST not be used, the least significant 48 bits of a 64-bit MAC address MUST be used\".\r\n\r\nAs a side note, the bit that you want to flip is not unicast/multicast but probably local/global.\r\n\r\n-\u00e9ric",
          "createdAt": "2023-09-01T13:52:15Z",
          "updatedAt": "2023-09-01T13:52:15Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> As a side note, the bit that you want to flip is not unicast/multicast but probably local/global.\r\n\r\nYes, local/global would be the more correct one, but unfortunately, for backwards compatibility I guess it needs to stay unicast/multicast\r\n",
          "createdAt": "2023-09-01T13:59:00Z",
          "updatedAt": "2023-09-01T13:59:00Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Took a pass at updating the text in commit: https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/bd1f37c5b5c1ac1b40105275b15fccefaf97f705. \r\nLet me know if this encompass all of the changes @mcr, @danielmarschall, @evyncke ",
          "createdAt": "2023-09-01T17:31:25Z",
          "updatedAt": "2023-09-01T17:31:25Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "There is written:  \"_For systems with no IEEE address or utilizing an IEEE 802.15.4 16 bit address, a randomly or pseudo-randomly\r\ngenerated value may be used_\" . Shouldn't it be \"MUST be used\"? (since we cannot use the 16 bit address in a 48 bit field) ",
          "createdAt": "2023-09-01T18:10:53Z",
          "updatedAt": "2023-09-01T18:11:11Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, yeah, modified them in https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/e33e137c0738dc59b495003526ffc015e9bc3a0e",
          "createdAt": "2023-09-01T20:10:00Z",
          "updatedAt": "2023-09-01T20:10:00Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://datatracker.ietf.org/doc/html/rfc4944#section-6 explains how to do things with 16-bit MACs, but in general, I'm quite happy with your text.",
          "createdAt": "2023-09-03T19:35:15Z",
          "updatedAt": "2023-09-03T19:35:15Z"
        }
      ]
    },
    {
      "number": 140,
      "id": "I_kwDOH6Ln3M5wLIui",
      "title": "INDIR Review 2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/140",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nI have the following DISCUSS level issues:\r\n\r\nSection 2.1, page 5: I think a MAC address identifies a network interface, not a \"machine\". Also, for MAC addresses, this document should Reference RFC 7042 or, even better, draft-ietf-intarea-rfc7042bis (which is through WGLC and, in my opinion, ready for publication request). Those documents point out the existence of 64-bit MAC addresses and where they have been and are currently used so this document should say something about how those are handled (perhaps by discarding the top 16 bits).\r\nOLD\r\n       address in the node field of UUID version 1.  Exposed MAC\r\n       addresses can be used as an attack surface to locate machines and\r\n       reveal various other information about such machines (minimally\r\nNEW\r\n       address in the node field of UUID version 1.  Exposed MAC\r\n       addresses can be used as an attack surface to locate network interfaces\r\n       and reveal various other information about such interfaces (minimally\r\n\r\nSection 6.1, Page 27, 1st paragraph: The last sentence of this paragraph is \"The count will range between zero and the number of 100-nanosecond intervals per system time interval.\" This is confusing. Why couldn't the count exceed that number?\r\n\r\nSection 7: I think it is improper in the IANA Considerations to talk about what \"the authors and the working group have concluded\". The RFC this document will be is issued as the consensus of the IETF, not as the opinion of its authors or even the working group. I suggest replacing this section in its entirety with the following:\r\n\"This document requires no IANA actions. In particular, no update is required to the IANA URN namespace registration [URNNamespaces] for UUID filed in [RFC4122] and IANA is not required to track UUIDs used for identifying items such as versions, variants, namespaces, or hashspaces.\"\r\n\r\n\r\nThe following are other issues I found with this document that SHOULD be corrected before publication:\r\nSection 5.5, page 20: \"This SHA-1 value is then used to populate all 128 bits of the UUID layout.  Excess bits beyond 128 are discarded.\" Seems like you can and should be more precise. Maybe \"The high order 128 bits of the SHA-1 value is then used to populate all 128 bits of the UUID layout and the remaining 32 low order bits of SHA-1 output are discarded\"\r\n\r\nSection 6.2, page 29: \"Using floating point math,\" appears to mandate the use of floating point which might not be available on some small platforms. Suggest \"Using floating point or scaled integer arithmetic,\"\r\n\r\nSection 6.2, Page 30, paragraph headed \"Fixed-Length Dedicated Counter Seeding\":\r\n+    \"However, when the timestamp has not incremented, the counter is frozen and\r\n      incremented via the desired increment logic.\" To my mind, frozen means it is not changed and is inconsistent with incrementing it. Perhaps \"When the timestamp has not increased, the counter is instead incremented by the desired increment logic.\"\r\n+    \"For example, a 24 bit counter could have\r\n      the 23 bits in least-significant, right-most, position randomly\r\n      initialized.  The remaining most significant, left-most counter\r\n      bits are initialized as zero for the sole purpose of guarding\r\n      against counter rollovers.\" This is inconsistent. Either it should say \"the 23 or fewer bits\" in the first sentence or it should say \"bit is initialized to zero\" in the second sentence.\r\n\r\nSection 6.3, page 32, 3rd paragraph: Frequent generation of random numbers also puts more stress on any entropy source and or entropy pool being used as the basis for such random numbers. This should be mentioned.\r\n\r\nSection 6.9: The discussion of the local/global bit here would be a good place to reference RFC 7042 or, even better, draft-ietf-intarea-ref4042bis.\r\n\r\nSection 6.10: This section uses \"quite large\" without any indication of how large. A factor of ten? A factor of ten to the tenth power? Can some hint of how large be given? Similarly Section 2.1, item 1.\r\n\r\nSection 8, Page 39: I think \"transposed\" is the wrong word. That just means to swap around various parts of something. While that is one type of modification, I think you mean any type of slight modification. \"slightly transposed\" -> \"slightly modified\"\r\n\r\n\r\nThe following are minor issues (typos, misspelling, minor text improvements) with the document:\r\n\r\nSection 1, paragraph 3, page 3:\r\nOLD\r\nto implement services using UUIDs, UUIDs in combination with URNs [RFC8141], or otherwise.\r\nNEW\r\nto implement services using UUIDs either in combination with URNs [RFC8141] or otherwise.\r\n\r\nSection 3.2: The expansions of UUIDv1 through UUIDv8 are quite repetitive and uninformative. Since you have already expanded UUID in the previous line, I don't think it needs to be expanded here. I suggest:\r\n   UUIDv1    Gregorian time-based UUID\r\n   UUIDv2    DCE Security version UUID\r\n   UUIDv3    Name-based UUID with MD5\r\n   UUIDv4    Pseudo-random UUID\r\n   UUIDv5    Name-based UUID with SHA-1\r\n   UUIDv6    Re-ordered Gregorian time-based UUID\r\n   UUIDv7    Unix Epoch time-based UUID\r\n   UUIDv8    Custom UUID\r\n\r\nI think Section 6.2 is too long and should have subsections (6.2.1, 6.2.2, ...).\r\n\r\nSection 6.2, page 29: \"which is sorts\" -> \"which sorts\"\r\n\r\nSection 6.2, page 30: \"randomly initialize a portion counter\" -> \"randomly initialize a portion of the counter\"\r\n\r\nSection 6.2., page 31: \"the random being incremented.\" -> \"the random value being incremented.\"\r\n\r\nSection 6.5, last paragraph, page 35: \"needs not be the only\" -> \"need not be the only\"\r\n\r\n```",
      "createdAt": "2023-09-05T13:18:29Z",
      "updatedAt": "2023-09-27T20:21:50Z",
      "closedAt": "2023-09-27T20:21:50Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Will end up in Draft 12, no time to get this done by draft 11 deadline.",
          "createdAt": "2023-09-05T13:18:47Z",
          "updatedAt": "2023-09-05T13:18:47Z"
        },
        {
          "author": "tgross35",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you know what the rough outline or timeline is for the proposal at this point? I assume there will be at least one more draft to address all review concerns, but I am having trouble figuring out what happens after that point.\r\n\r\nAlso confusing is the recent milestone change, since that milestone is set for March 2023 https://mailarchive.ietf.org/arch/msg/uuidrev/Wt03UVzzrxqmHJT5DeM58UT0Hww/",
          "createdAt": "2023-09-20T03:03:32Z",
          "updatedAt": "2023-09-20T03:03:32Z"
        },
        {
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@tgross35 This sort of question is really better suited for the mailing list, not the GitHub repository.\n\nThe change to the milestones was simply that the document the milestone referred to was left out. I added the reference to the document.\n\n@mcr has sent out a poll to try to have an interim meeting of the working group. The timeframe will depend greatly on WG rough consensus on how much change will be done at this very late stage. Please try to attend if you have an opinion on any of this.\n\n-Jim, co-chair",
          "createdAt": "2023-09-20T06:13:53Z",
          "updatedAt": "2023-09-20T06:13:53Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Changes completed in https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/cfcb3b077b96fc6bb460579db368c48d50bea790\r\nAll are done except:\r\n- Section 6.9, spun into new issue, 150\r\n- I did not change UUIDvX abbreviations as the were requested by another individual\r\n- I did not modify Section 6.10, @bradleypeabody would you take a look at how we can change that text?",
          "createdAt": "2023-09-20T19:30:18Z",
          "updatedAt": "2023-09-20T19:30:18Z"
        },
        {
          "author": "tgross35",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @jimfenton, I honestly did not know that the mailing list was open to nontechnical discussion. I appreciate the clarification.",
          "createdAt": "2023-09-20T21:42:13Z",
          "updatedAt": "2023-09-20T21:42:13Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@kyzer-davis I think it's safe to replace \"quite large\" with \"one order of magnitude or more\".  I.e.:\r\n\r\n> The real-world differences in this approach of index locality vs random data inserts can be one order of magnitude or more.",
          "createdAt": "2023-09-20T22:51:32Z",
          "updatedAt": "2023-09-20T22:51:32Z"
        }
      ]
    },
    {
      "number": 141,
      "id": "I_kwDOH6Ln3M5wOCsO",
      "title": "SECDIR Review",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/141",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nSection 6.6\r\n   High Impact:\r\n      A duplicate key causes an airplane to receive the wrong course\r\n      which puts people's lives at risk.  In this scenario there is no\r\n      margin for error.  Collisions MUST be avoided and failure is\r\n      unacceptable.  Applications dealing with this type of scenario\r\n      MUST employ as much collision resistance as possible within the\r\n      given application context.\r\n\r\nNot to trivialize the seriousness of the described scenario, but normative\r\nlanguage around airplane design and operation doesn\u2019t seem appropriate or in\r\nscope for the WG.  Furthermore \u201cas much collision resistance as possible\u201d isn\u2019t\r\nparticularly precise.  Recommend s/MUST/must/\r\n\r\n** Section 6.9\r\n   A generic approach, however, is\r\n   to accumulate as many sources as possible into a buffer, use a\r\n   message digest such as MD5 [RFC1321] or SHA-1 [FIPS180-4], take an\r\n   arbitrary 6 bytes from the hash value, and set the multicast bit as\r\n   described above.\r\n\r\nRFC4112 referenced MD5 and SHA-1, but didn\u2019t tie the implementation to them,\r\nwhy can\u2019t a modern hash algorithm (SHA-256) be recommended here instead?\r\n\r\n** Section 6.11\r\n\r\n   UUIDs SHOULD be treated as opaque values and implementations SHOULD\r\n   NOT examine the bits in a UUID.  However, inspectors MAY refer to\r\n   Section 4.1 and Section 4.2 when required to determine UUID version\r\n   and variant.\r\n\r\n   As general guidance, we recommend not parsing UUID values\r\n   unnecessarily, and instead treating them as opaquely as possible.\r\n   Although application-specific concerns could of course require some\r\n   degree of introspection (e.g., to examine the variant, version or\r\n   perhaps the timestamp of a UUID), the advice here is to avoid this or\r\n   other parsing unless absolutely necessary.\r\n\r\nWhy are both of these paragraphs needed?  The first seems to say the same thing\r\nas the second except with normative language.\r\n\r\n** Section 8\r\nImplementations SHOULD NOT assume that UUIDs are hard to guess. For example,\r\nthey MUST NOT be used as security capabilities (identifiers whose mere\r\npossession grants access).\r\n\r\n-- Why isn\u2019t this a \u201cMUST NOT assume\u201d?\r\n\r\n** Section 8\r\n   MAC addresses pose inherent security risks and SHOULD NOT be used within a\r\n   UUID.\r\n\r\nIs there any advisory language that can be provided that could explain when a\r\nMAC address should be used?\r\n```",
      "createdAt": "2023-09-05T21:10:07Z",
      "updatedAt": "2023-09-27T20:21:50Z",
      "closedAt": "2023-09-27T20:21:50Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Will get to this in draft 12",
          "createdAt": "2023-09-05T21:11:43Z",
          "updatedAt": "2023-09-05T21:11:43Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I have two thoughts/annotations:\r\n\r\n(1)\r\nI am confused about the definition \"_Implementations SHOULD NOT assume that UUIDs are hard to guess_.\".\r\nWhy is this so?  If I generate a UUIDv4 using a CSRNG and use it as BEARER in a REST-API, I basically have a 122-bit random number created using a CSRNG. This is very secure.\r\nOn the other hand, I know that not all UUID are that \"secure\". For example, a UUIDv2 is easy to guess and has a horrible time resolution.\r\n\r\nIn my opinion, since \"some\" UUID (e.g. UUIDv4 using CSRNG) are good as credentials, I think that it should stay \"SHOULD NOT assume\" and not \"MUST NOT assume\". I believe there are a lot of products that use UUIDv4 for tokens (e.g. Session Identifiers), and if you change the definition to \"MUST NOT\", it would mean that all these products must change their code.\r\n\r\n---\r\n\r\n(2) \r\n\"_Is there any advisory language that can be provided that could explain when a MAC address should be used_?\"\r\nI cannot provide an advisory language, but I want to give a personal opinion and thoughts... Personally, I am an advocate for using real MAC in a UUID.\r\n1. I see the MAC address as a kind of \"signature\". I can easily see if these UUIDs are created by myself or not. I think it is a nice touch when you develop Microsoft COM interfaces and all your UUIDs have the same ending. So people know \"Hey, if the CLSID ends with 112233445566, this is a interface written by Contoso Ltd.\"\r\n2. I can imagine that in a distributed computing environment, machines are generating data and identifying them with a UUID with a real MAC address. In case something is not good with the data, the machine producing the defective data can be identified. (I believe such \"meta data\" was extensively used in UUIDv2)\r\n3. When choosing a random number as Node ID, the probability of a UUID collision is mathematically greater than zero. If we use a real MAC address, the probability of collision is mathematically zero. I am stressing the word \"mathematically\" because I know that a collision is **_practically_** unlikely/impossible.\r\n",
          "createdAt": "2023-09-05T21:51:05Z",
          "updatedAt": "2023-09-05T21:58:41Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Changes from https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/aa08603209711448575802658ffb828835199fb4\r\n- Downgraded MUST to non-normative in high impact section\r\n- Swapped MD5/SHA-1 for SHA-256 and SHA-512\r\n- Removed extra paragraph in section 6.11, Opacity\r\n\r\nDid not change language around section 8 (and the last item was already fixed in another issue tracker item.)",
          "createdAt": "2023-09-20T18:11:52Z",
          "updatedAt": "2023-09-20T18:11:52Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "I_kwDOH6Ln3M5wUY1M",
      "title": "SECDIR Review 2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/142",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\n----------------------------------------------------------------------\r\nCOMMENT:\r\n----------------------------------------------------------------------\r\n\r\n        Padding:\r\n\r\n                When timestamp padding is required, implementations\r\n                MUST pad the most significant bits (left-most) bits\r\n                with zeros. An example is padding the most significant,\r\n                left-most bits of a Unix timestamp with zeroes to fill\r\n                out the 48 bit timestamp in UUIDv7. An alternative is to\r\n                pad the most significant, left-most bits with the number\r\n                of 32 bit Unix timestamp roll-overs after 2038-01-19.\r\n\r\nHow can this MUST clause have an alternative? Should it be a SHOULD? If\r\nso, when would one use the alternative specified here?\r\n\r\n\r\n        sharing the hashspace ID proves useful for identifying the algorithm.\r\n\r\nIt is not clear what the term \"hashspace ID\" refers to.\r\n\r\n        Implementations SHOULD utilize a cryptographically secure\r\n        pseudo-random number generator (CSPRNG) to provide values that\r\n        are both difficult to predict (\"unguessable\") and have a low\r\n        likelihood of collision (\"unique\").\r\n\r\nCouldn't Verifiable Random Functions (VRF) also be used instead of a CSPRNG?\r\n\r\n        use a message digest such as MD5 [RFC1321] or SHA-1 [FIPS180-4],\r\n        take an arbitrary 6 bytes from the hash value, and set the\r\n        multicast bit as described above.\r\n\r\nWhile it might not matter, use of a more modern message digest algorithm is\r\nstill recommended here. One reason is that the IETF is trying to phase out\r\nthese older digests, and prefers to not reference these in new RFCs. A second\r\nreason is that sometimes, cryptographic libraries are prevented from using\r\nthese older type of digests (eg when running in FIPS mode)\r\n\r\n        Implementations can also leverage MAC address randomization\r\n        techniques (IEEE 802.11bh) as an alternative to the pseudo-random\r\n        logic provided in this section.\r\n\r\nI'm not sure why the Section didn't lead with this more obvious approach?\r\n\r\nNITS:\r\n\r\nfor readability, change:\r\n\r\n        The increment value MAY be one when the number of UUIDs generated\r\n        in a particular period of time is ...\r\n\r\nto\r\n\r\n        The increment value MAY be 1 when the number of UUIDs generated\r\n        in a particular period of time is ...\r\n\r\n\r\n\r\n        However, it SHOULD NOT be used by implementations that favor\r\n        unguessability, as the resulting values are easily guessable.\r\n\r\nWhat does \"it\" refer to? Incrementing by 1? Write it out instead of using \"it\"\r\n\r\n```",
      "createdAt": "2023-09-06T16:48:00Z",
      "updatedAt": "2023-09-27T20:21:51Z",
      "closedAt": "2023-09-27T20:21:51Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Changed via https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/8425364794ff3cfe68528f3fd7c88e7376edeabf\r\n- Modified padding to better call out the MUST for padding but then provide two options for said padding data.\r\n- Modified the method 2 counter to better define 1 and \"it\"\r\n- Cited hashspace section to better detail what a \"hashspace ID\" is\r\n- Moved randomized MAC to the top and provided 47 bit CSPRNG+Mcast bit flip as the alternative\r\n- Did not need to hit MD5/SHA1 change, done under https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/aa08603209711448575802658ffb828835199fb4\r\n- Did not touch on Verifiable Random Functions (VRF). While I guess it is true. It could be used. Nobody has brought this up in the 3 years of this document existing. CSPRNG seems to fit the bill.",
          "createdAt": "2023-09-20T18:26:34Z",
          "updatedAt": "2023-09-20T18:26:34Z"
        }
      ]
    },
    {
      "number": 143,
      "id": "I_kwDOH6Ln3M5wUbi_",
      "title": "Alternative proposal for Hashspace ID Values",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "wontfix"
      ],
      "body": "From Paul Wouters\r\n```\r\nWhy are hashspace IDs chosen to look like random uuids? Eg why not encode\r\n\"SHA2_224\" (hex 534841325F323234) as 53484132-5F32-3234-0000-000000000000\r\nor 00000000-0000-0000-5348-41325F323234 (plus or minus variant/version bits)\r\nso that it becomes far more clear this is not an ordinary random uuid?\r\n```\r\n\r\n\r\n### Current, All random\r\n```\r\nSHA2_224     = \"59031ca3-fbdb-47fb-9f6c-0f30e2e83145\"\r\nSHA2_256     = \"3fb32780-953c-4464-9cfd-e85dbbe9843d\"\r\nSHA2_384     = \"e6800581-f333-484b-8778-601ff2b58da8\"\r\nSHA2_512     = \"0fde22f2-e7ba-4fd1-9753-9c2ea88fa3f9\"\r\nSHA2_512_224 = \"003c2038-c4fe-4b95-a672-0c26c1b79542\"\r\nSHA2_512_256 = \"9475ad00-3769-4c07-9642-5e7383732306\"\r\nSHA3_224     = \"9768761f-ac5a-419e-a180-7ca239e8025a\"\r\nSHA3_256     = \"2034d66b-4047-4553-8f80-70e593176877\"\r\nSHA3_384     = \"872fb339-2636-4bdd-bda6-b6dc2a82b1b3\"\r\nSHA3_512     = \"a4920a5d-a8a6-426c-8d14-a6cafbe64c7b\"\r\nSHAKE_128    = \"7ea218f6-629a-425f-9f88-7439d63296bb\"\r\nSHAKE_256    = \"2e7fc6a4-2919-4edc-b0ba-7d7062ce4f0a\"\r\n```",
      "createdAt": "2023-09-06T16:55:09Z",
      "updatedAt": "2023-10-05T13:36:31Z",
      "closedAt": "2023-10-05T13:36:31Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Alternative from me:\r\nPick a random UUID to start, increment the lowest bits by 1 for each.\r\n\r\nLogic for Namespace is a specific UUIDv1 \r\n`6ba7b810-9dad-11d1-80b4-00c04fd430c8` starts and next is `6ba7b811-9dad-11d1-80b4-00c04fd430c8` is next where the 6ba7b81**0** and 6ba7b81**1** increments for each up through 0-4 in that position.\r\n\r\n\r\n### Increment by UUID in least significant position. \r\n- First part is UUIDv4 was initiated from random and frozen to `59031ca3-fbdb-47fb-9f6c`\r\n\r\n```\r\nSHA2_224     = \"59031ca3-fbdb-47fb-9f6c-000000000000\"\r\nSHA2_256     = \"59031ca3-fbdb-47fb-9f6c-000000000001\"\r\nSHA2_384     = \"59031ca3-fbdb-47fb-9f6c-000000000002\"\r\nSHA2_512     = \"59031ca3-fbdb-47fb-9f6c-000000000003\"\r\nSHA2_512_224 = \"59031ca3-fbdb-47fb-9f6c-000000000004\"\r\nSHA2_512_256 = \"59031ca3-fbdb-47fb-9f6c-000000000005\"\r\nSHA3_224     = \"59031ca3-fbdb-47fb-9f6c-000000000006\"\r\nSHA3_256     = \"59031ca3-fbdb-47fb-9f6c-000000000007\"\r\nSHA3_384     = \"59031ca3-fbdb-47fb-9f6c-000000000008\"\r\nSHA3_512     = \"59031ca3-fbdb-47fb-9f6c-000000000009\"\r\nSHAKE_128    = \"59031ca3-fbdb-47fb-9f6c-00000000000A\"\r\nSHAKE_256    = \"59031ca3-fbdb-47fb-9f6c-00000000000B\"\r\n```",
          "createdAt": "2023-09-06T16:57:24Z",
          "updatedAt": "2023-09-06T17:17:24Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Paul's proposal, TEXT to HEX, is tough because the current hashspace ID labels for a value is at minimum 16 characters and at max 24 characters after encoding in hex. (See the end)\r\nThe Version/Variant bits need to be set which leaves position that isn't ideal to slot these in easily.\r\n- X, the start of the UUID 12 chars\r\n- Y, the end of the UUID 15 chars\r\n- Z, the middle of the UUID 3 chars\r\n\r\n```\r\nxxxxxxxx-xxxx-Mzzz-Nyyy-yyyyyyyyyyyy\r\n```\r\n\r\n### Text to Hex\r\n```\r\nSHA2_224     = 534841325f323234\r\nSHA2_256     = 534841325f323536\r\nSHA2_384     = 534841325f333834\r\nSHA2_512     = 534841325f353132\r\nSHA2_512_224 = 534841325f3531325f323234\r\nSHA2_512_256 = 534841325f3531325f323536\r\nSHA3_224     = 534841335f323234\r\nSHA3_256     = 534841335f323536\r\nSHA3_384     = 534841335f333834\r\nSHA3_512     = 534841335f353132\r\nSHAKE_128    = 5348414b455f313238\r\nSHAKE_256    = 5348414b455f323536\r\n```\r\n\r\nEdit: I could change the names labels, remove underscore but it does not scale nicely unless they can all be 12-15 chars after the encoding or one must navigate the Ver/Var hex.",
          "createdAt": "2023-09-06T17:23:42Z",
          "updatedAt": "2023-09-06T17:27:06Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For [my online service](https://misc.daniel-marschall.de/tools/uuid_mac_decoder/index.php#gen_uuidv35) I have done the following approach:\r\n\r\n    HashSpaceUuid<AlgoName> := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", AlgoName).\r\n\r\nwhich results in the following UUIDs:\r\n\r\n```\r\n-- Algorithms from this draft (revision 00-11)\r\n-- The payload of the UUIDv5 is the algorithms name from PHP hash_algos(), as well as \"shake128\" and \"shake256\"\r\nSHA224                 := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha224\")      = \"59031ca3-fbdb-47fb-9f6c-0f30e2e83145\".\r\nSHA256                 := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha256\")      = \"3fb32780-953c-4464-9cfd-e85dbbe9843d\".\r\nSHA384                 := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha384\")      = \"e6800581-f333-484b-8778-601ff2b58da8\".\r\nSHA512                 := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha512\")      = \"0fde22f2-e7ba-4fd1-9753-9c2ea88fa3f9\".\r\nSHA512/224             := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha512/224\")  = \"003c2038-c4fe-4b95-a672-0c26c1b79542\".\r\nSHA512/256             := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha512/256\")  = \"9475ad00-3769-4c07-9642-5e7383732306\".\r\nSHA3/224               := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha3-224\")    = \"9768761f-ac5a-419e-a180-7ca239e8025a\".\r\nSHA3/256               := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha3-256\")    = \"2034d66b-4047-4553-8f80-70e593176877\".\r\nSHA3/384               := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha3-384\")    = \"872fb339-2636-4bdd-bda6-b6dc2a82b1b3\".\r\nSHA3/512               := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"sha3-512\")    = \"a4920a5d-a8a6-426c-8d14-a6cafbe64c7b\".\r\nSHAKE128               := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"shake128\")    = \"7ea218f6-629a-425f-9f88-7439d63296bb\".\r\nSHAKE256               := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"shake256\")    = \"2e7fc6a4-2919-4edc-b0ba-7d7062ce4f0a\".\r\n\r\n-- Other algorithms\r\n-- Excluded are algorithms whose output is too short to fit into an UUIDv8\r\n-- The payload of the UUIDv5 is the algorithms name from PHP hash_algos()\r\nGOST                   := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"gost\")        = \"be782e40-b9e8-59c4-8500-31a6cfb91a75\".\r\nGOST-CryptoProParamSet := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"gost-crypto\") = \"9c1d4a70-75ec-5c6a-84e2-09b400fe8f21\".\r\nHAVAL-3-128            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval128,3\")  = \"176e81e1-9fc8-50f3-b569-08f264e5ae58\".\r\nHAVAL-3-160            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval160,3\")  = \"8d160752-d034-54e0-ac73-930ec60580c2\".\r\nHAVAL-3-192            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval192,3\")  = \"1f53cfc9-a36c-5a36-b27c-6dc88074ca38\".\r\nHAVAL-3-224            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval224,3\")  = \"56ef61fc-16de-55f4-bd3f-f44856d3d436\".\r\nHAVAL-3-256            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval256,3\")  = \"66111477-b9e1-54cc-a38f-b73b228964cc\".\r\nHAVAL-4-128            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval128,4\")  = \"55d554f5-7c2e-5e08-a8e3-cd6ecbac1e32\".\r\nHAVAL-4-160            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval160,4\")  = \"5d3d8b32-d57d-54b4-9a01-342e8fa9df5b\".\r\nHAVAL-4-192            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval192,4\")  = \"c7c66b4d-4299-5489-aa29-991b7bd4aa52\".\r\nHAVAL-4-224            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval224,4\")  = \"5c86a1f5-6b47-576e-a900-087897bf83a7\".\r\nHAVAL-4-256            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval256,4\")  = \"5851bbb5-56a3-55b3-8775-371739d251ca\".\r\nHAVAL-5-128            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval128,5\")  = \"9d40aac4-d8e5-5846-ad91-dc3429294d0d\".\r\nHAVAL-5-160            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval160,5\")  = \"764e5acb-88c4-5b24-b3bd-cca0941de88a\".\r\nHAVAL-5-192            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval192,5\")  = \"4455573f-5ff9-5cac-aadc-7ecf5c0c7ad1\".\r\nHAVAL-5-224            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval224,5\")  = \"0336bbe3-f703-5184-b52d-4e9d8163ddcd\".\r\nHAVAL-5-256            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"haval256,5\")  = \"5f4a8511-9e92-5d62-b94d-0b910a1e3d9a\".\r\nMD2                    := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"md2\")         = \"6ca7dd19-4755-5c6a-8b3f-3056ef6bebf6\".\r\nMD4                    := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"md4\")         = \"15329616-0af7-535a-b4b6-41c4eba21457\".\r\nMurmur3c               := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"murmur3c\")    = \"b941a86c-9e70-5044-9496-da00eec9b934\".\r\nMurmur3f               := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"murmur3f\")    = \"4a2262be-0dec-587f-843a-eb50c707d779\".\r\nRIPEMD128              := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"ripemd128\")   = \"efd0677a-e9f4-5337-8764-51be1c353d4a\".\r\nRIPEMD160              := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"ripemd160\")   = \"b54b1a0a-ce07-5d4b-9d03-96d57da2bf29\".\r\nRIPEMD256              := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"ripemd256\")   = \"e288aa2a-5260-5aaf-825a-f40ce0514d19\".\r\nRIPEMD320              := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"ripemd320\")   = \"2919713b-ae42-58a3-916a-039989f07300\".\r\nSNEFRU                 := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"snefru\")      = \"d38f5891-c553-5d58-88de-199cbf48291e\".\r\nSNEFRU256              := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"snefru256\")   = \"30b628e4-4587-5f06-ae1b-be9d0cba1187\".\r\nTiger-3-128            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"tiger128,3\")  = \"6f5ba86a-a362-50f1-bc6a-62787ee998b8\".\r\nTiger-4-128            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"tiger128,4\")  = \"13ff3c12-da5d-5437-89d9-a76e44abd0c8\".\r\nTiger-3-160            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"tiger160,3\")  = \"50d3d8af-6a6c-5ea3-bfad-450424668dee\".\r\nTiger-4-160            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"tiger160,4\")  = \"31d39089-28e0-584b-bf72-7cf33c2caeea\".\r\nTiger-3-192            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"tiger192,3\")  = \"63cfdad3-a720-55e2-83a4-b8c762ad4012\".\r\nTiger-4-195            := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"tiger192,4\")  = \"5b07ff46-f679-5d3c-97e1-10b800be9246\".\r\nWHIRLPOOL              := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"whirlpool\")   = \"74fd261c-1f13-5015-81cc-fdc9a7354ae5\".\r\nXXH128                 := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"xxh128\")      = \"1a66c377-af3d-5f24-b9fb-d6c067d8b588\".\r\n```\r\n\r\nWhat do you think about it?\r\n",
          "createdAt": "2023-09-06T18:02:11Z",
          "updatedAt": "2023-09-07T15:21:10Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "I know that not being a hash function expert, I shouldn't even question the advantage and simplicity of incrementing a base UUID. However, in terms of [avalanche effect](https://arishs.medium.com/analyze-your-hash-functions-the-avalanche-metrics-calculation-767b7445ee6f), which is better: changing only 1 bit or <s>changing 128 bits</s> changing more bits?\r\n\r\nI also know that **it is not** a requirement that an ID produced with a hashspace has a very high probability of not clashing with IDs produced with a different hashspace. SHA-x algorithms already guarantee that changing 1 bit in the input produces a drastically different output, so this probability must be extremely low to be taken into account. However, if it is possible to maximize this effect by changing as many input bits as possible, wouldn't that be more desirable?\r\n\r\n--\r\n\r\n**EDIT:** I crossed out the \"changing 128 bits\" phrase because changing 128 bits means inverting all bits, which is the result of an XOR operation. It seems more appropriate to change more than 1 bit, but not all.",
          "createdAt": "2023-09-06T18:15:46Z",
          "updatedAt": "2023-09-06T19:58:59Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "> For [my online service](https://misc.daniel-marschall.de/tools/uuid_mac_decoder/index.php#gen_uuidv35) I have done the following approach:\r\n> \r\n> HashSpaceUuid<AlgoName> := UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", AlgoName).\r\n\r\nSounds logical to me and easy to describe as you only need to define the namespace UUID that will be used with the UUIDv5 function to generate the hashspaces for each algorithm name.\r\n\r\nHowever, it is necessary to use the \"canonical name\" of each algorithm, which implies text encoding (UTF-8, ASCII etc), case sensitivity (uppercase, lowercase), use (or not) of [\"non-word\" characters](https://www.tutorialspoint.com/Find-non-word-character-in-a-string-with-JavaScript-RegExp) (dash, space), etc.\r\n",
          "createdAt": "2023-09-06T18:30:35Z",
          "updatedAt": "2023-09-06T18:39:12Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, the canonical name is indeed my concern, too. ~(I wonder, is there a RFC that defines naming schemes for algorithms?)~\r\n\r\n**_Proposal 1_**\r\n\r\nI have the following idea:\r\n- Appendix B could describe the UUIDv5 mechanism and list SHA2, SHA3, and SHAKE as examples (and hence define their name. You have to think about if you prefer uppercase or lowercase and use dashes or hyphens).\r\n- **The naming of other algorithms (like GOST or HAVAL) would be out-of-scope**. However, people can orient on our naming scheme. For example, if we define the name to be \"SHA3\", then it is likely that people will choose \"HAVAL\" instead of \"Haval\" or \"haval\". If we choose the name \"sha3\", then it is likely that people will choose \"haval\" instead of \"HAVAL\" or \"Haval\".\r\n- If you like, you could add a note that the UUIDv5 mechanism is OPTIONAL, which means people are not forced to use it. They can still use UUIDv1 or UUIDv4 for other algorithms if they prefer it that way. (This might make sense in case a hash algorithm is already defined by a UUID)\r\n\r\nHere is a proposal (I have calculated the UUIDv5, but please double-check them):\r\n\r\n```\r\nAppendix B.  Some Hashspace IDs\r\n\r\n   This appendix lists some hashspace IDs for use with UUIDv8 name-based UUIDs.\r\n\r\n   The following UUIDs were created by using a UUIDv5 with namespace ID\r\n   \"1ee317e2-1853-64b2-8fe9-3c4a92df8582\" and the algorithm name in\r\n   upper-case and with underscores as data.  This mechanism of generating a\r\n   hashspace ID is OPTIONAL.  Any UUID can be used as a hashspace UUID.\r\n\r\n   SHA2_224     = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA2_224\")     = \"5385c476-6ffc-578a-908f-91b5cd2eac03\"\r\n   SHA2_256     = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA2_256\")     = \"f660b1c5-f2c9-5f3a-981f-8652227fc329\"\r\n   SHA2_384     = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA2_384\")     = \"43794fb1-7e34-558f-a8a5-5b4b8f8470d5\"\r\n   SHA2_512     = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA2_512\")     = \"250cb2ab-c480-5f24-83fd-16ea8b0b9e36\"\r\n   SHA2_512_224 = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA2_512_224\") = \"70bade2b-c68a-5894-b31d-7c3581b6c647\"\r\n   SHA2_512_256 = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA2_512_256\") = \"a05efbcf-0a2a-5aab-9c62-8c94d05e0760\"\r\n   SHA3_224     = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA3_224\")     = \"2862da96-f3c7-586a-8cc3-b1f424cdf040\"\r\n   SHA3_256     = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA3_256\")     = \"72727812-3cea-56bd-a57f-ed3445acca4f\"\r\n   SHA3_384     = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA3_384\")     = \"279978a1-86d1-56e6-bce2-019f5eaa3437\"\r\n   SHA3_512     = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA3_512\")     = \"33e6927a-d382-5dbd-b415-402610340bcd\"\r\n   SHAKE_128    = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHAKE_128\")    = \"8835c536-6ab4-55bc-be61-7029cdcbd1db\"\r\n   SHAKE_256    = UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHAKE_256\")    = \"311a1f8e-0a71-554a-bcdb-436c4e9f55e8\"\r\n```",
          "createdAt": "2023-09-06T20:27:16Z",
          "updatedAt": "2023-09-07T20:25:00Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "> Here is a proposal (I have calculated the UUIDv5, but please double-check them):\r\n\r\nI prefer to keep the previous defined UUIDv4-based hashspaces, but I think this UUIDv5 mechanism is a better way to define pseudo-random or \"random-looking\" hashspaces which can be easily reproduced to define new hashspaces for cryptographic hash functions that could not be included in the document.\r\n\r\nI just don't know which are the current canonical names for the SHA-2 family. For example, [Wikipedia](https://en.wikipedia.org/wiki/SHA-2) and [Java](https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#messagedigest-algorithms) use SHA-256 (with a dash), but not SHA**2**_256 (with a 2 and an underline).\r\n\r\nP.S.: can we use this document as a reference?: https://csrc.nist.gov/files/pubs/fips/180-4/upd1/final/docs/fips180-4-draft-aug2014.pdf",
          "createdAt": "2023-09-06T20:51:25Z",
          "updatedAt": "2023-09-06T20:59:29Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "**_Proposal 2_**\r\n\r\nThere is another method which does not rely on canonical names (or even English language) at all.\r\n\r\nA lot of hash algorithms are identified by OIDs. Some of them are located in this arc:\r\nhttp://oid-info.com/get/2.16.840.1.101.3.4.2\r\n\r\nWe could use a UUIDv5 with namespace OID (6ba7b812-9dad-11d1-80b4-00c04fd430c8)\r\nand the hash algorithm OID as payload.\r\n\r\nHere is my proposal:\r\n\r\n```\r\nAppendix B.  Some Hashspace IDs\r\n\r\n   This appendix lists some hashspace IDs for use with UUIDv8 name-based UUIDs.\r\n\r\n   The following UUIDs were created by using a UUIDv5 with the OID namespace ID\r\n   (\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\") and the OID identifying the\r\n   hash algorithm.  This mechanism of generating a hashspace ID is OPTIONAL.\r\n   Any UUID can be used as a hashspace UUID.\r\n\r\n   SHA-224      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.4\")  = \"e0f20710-25d9-54ab-8325-ccf2d456ad0b\"\r\n   SHA-256      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.1\")  = \"29f7f1c6-6258-5be3-b9f0-2adc24eb96c6\"\r\n   SHA-384      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.2\")  = \"728cae51-ddd4-5401-b52c-5775cd8913d8\"\r\n   SHA-512      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.3\")  = \"a5dd0c9d-04b0-5f15-9332-c0ff97053dda\"\r\n   SHA-512/224  = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.5\")  = \"3b72d097-ee4d-54e0-a3ab-cbc072d6d159\"\r\n   SHA-512/256  = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.6\")  = \"af4f3a3f-167e-53b5-8817-66d5201cb05a\"\r\n   SHA3-224     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.7\")  = \"4b5be759-1e10-56ff-9187-1a34f5773d9f\"\r\n   SHA3-256     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.8\")  = \"2eea60a9-2f2b-5d32-93b2-dc9688165cfa\"\r\n   SHA3-384     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.9\")  = \"f49d66f8-0755-5500-b747-ef5f7a18e9bc\"\r\n   SHA3-512     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.10\") = \"e3936772-aa32-5463-870b-0a05a6bb2dd3\"\r\n   SHAKE128     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.11\") = \"bd2da541-a66d-52a7-8cf7-3773e204c114\"\r\n   SHAKE256     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.12\") = \"a1a5a6ea-b4fd-5f93-91e3-a25de6121457\"\r\n```\r\n\r\n(Edit after my initial post: Changed the algorithm names as defined by [FIPS180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf%3E) and [FIPS202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf))\r\n\r\n**_(Note to self:)_** Here is a list of Algorithms/OIDs I have found:\r\n\r\n```\r\nGOST = 1.2.643.2.2.30.0\r\nGOST-CryptoProParamSet = 1.2.643.2.2.30.1\r\nGOST3410-2012-256 = 1.2.643.7.1.1.3.2\r\nGOST3410-2012-512 = 1.2.643.7.1.1.3.3\r\nHAVAL-3-128 = 1.3.6.1.4.1.18105.2.1.1.1\r\nHAVAL-3-160 = 1.3.6.1.4.1.18105.2.1.1.2\r\nHAVAL-3-192 = 1.3.6.1.4.1.18105.2.1.1.3\r\nHAVAL-3-224 = 1.3.6.1.4.1.18105.2.1.1.4\r\nHAVAL-3-256 = 1.3.6.1.4.1.18105.2.1.1.5\r\nHAVAL-4-128 = 1.3.6.1.4.1.18105.2.1.1.6\r\nHAVAL-4-160 = 1.3.6.1.4.1.18105.2.1.1.7\r\nHAVAL-4-192 = 1.3.6.1.4.1.18105.2.1.1.8\r\nHAVAL-4-224 = 1.3.6.1.4.1.18105.2.1.1.9\r\nHAVAL-4-256 = 1.3.6.1.4.1.18105.2.1.1.10\r\nHAVAL-5-128 = 1.3.6.1.4.1.18105.2.1.1.11\r\nHAVAL-5-160 = 1.3.6.1.4.1.18105.2.1.1.12\r\nHAVAL-5-192 = 1.3.6.1.4.1.18105.2.1.1.13\r\nHAVAL-5-224 = 1.3.6.1.4.1.18105.2.1.1.14\r\nHAVAL-5-256 = 1.3.6.1.4.1.18105.2.1.1.15\r\nISO/IEC 10118-2 \"Hash Function 1\" = 1.0.10118.2.0.1\r\nISO/IEC 10118-2 \"Hash Function 2\" = 1.0.10118.2.0.2\r\nISO/IEC 10118-2 \"Hash Function 3\" = 1.0.10118.2.0.3\r\nISO/IEC 10118-2 \"Hash Function 4\" = 1.0.10118.2.0.4\r\nMD2 = 1.2.840.113549.2.2\r\nMD4 = 1.2.840.113549.2.4\r\nMD5  = 1.2.840.113549.2.5  (use UUIDv3)\r\nMURMUR3C = ???\r\nMURMUR3F = ???\r\nModular Arithmetic Secure Hash 1 (MASH-1) algorithm = 1.0.10118.4.0.65\r\nModular Arithmetic Secure Hash 2 (MASH-2) algorithm = 1.0.10118.4.0.66\r\nRIPEMD128 = 1.3.36.3.2.2 or 1.0.10118.3.0.50\r\nRIPEMD160 = 1.3.36.3.2.1 or 1.0.10118.3.0.49\r\nRIPEMD256 = 1.3.36.3.2.3\r\nRIPEMD320 = ???\r\nSHA-224 = 2.16.840.1.101.3.4.2.4\r\nSHA-256 = 2.16.840.1.101.3.4.2.1\r\nSHA-384 = 2.16.840.1.101.3.4.2.2\r\nSHA-512 = 2.16.840.1.101.3.4.2.3\r\nSHA-512/224 = 2.16.840.1.101.3.4.2.5\r\nSHA-512/256 = 2.16.840.1.101.3.4.2.6\r\nSHA0 = OID = 1.3.14.3.2.18\r\nSHA1 = 1.3.14.3.2.26  (use UUIDv5)\r\nSHA3-224 = 2.16.840.1.101.3.4.2.7\r\nSHA3-256 = 2.16.840.1.101.3.4.2.8\r\nSHA3-384 = 2.16.840.1.101.3.4.2.9\r\nSHA3-512 = 2.16.840.1.101.3.4.2.10\r\nSHAKE-128 = 2.16.840.1.101.3.4.2.11\r\nSHAKE-256 = 2.16.840.1.101.3.4.2.12\r\nSM3 (ISO/IEC 10118-3) = 1.0.10118.3.0.65\r\nSNEFRU = ???\r\nSNEFRU256 = ???\r\nStreebog 256 = 1.0.10118.3.0.60\r\nStreebog 512 = 1.0.10118.3.0.59\r\nTIGER-3-128 = ???\r\nTIGER-3-160 = ???\r\nTIGER-3-192 = ??? (1.3.6.1.4.1.11591.12.2 specifies 192 bits, but rounds are unknown)\r\nTIGER-4-128 = ???\r\nTIGER-4-160 = ???\r\nTIGER-4-192 = ???\r\nWHIRLPOOL = 1.0.10118.3.0.55\r\nXXH128 = ???\r\n```",
          "createdAt": "2023-09-06T21:05:45Z",
          "updatedAt": "2023-09-07T20:26:01Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "@danielmarschall \r\n\r\nI think it's way better.\r\n\r\nWhy not using the [URN notation](https://www.ietf.org/rfc/rfc3061.txt) in lowercase mode only, e.g. `urn:oid:2.16.840.1.101.3.4.2.4`?\r\n\r\n",
          "createdAt": "2023-09-06T21:13:37Z",
          "updatedAt": "2023-09-06T21:14:03Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@fabiolimace Are you confused about my notation `UUIDv5(OID 2.16.840.1.101.3.4.2.6)` ? With this notation I meant taking the OID namespace ID (\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\") and use the OID \"2.16.840.1.101.3.4.2.6\" as payload.",
          "createdAt": "2023-09-06T21:19:29Z",
          "updatedAt": "2023-09-06T21:54:07Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "Sorry I meant the string \"urn:oid:2.16.840.1.101.3.4.2.4\" as the name input for the UUIDv5 function.\r\n\r\nThis:\r\n\r\n```\r\n   SHA2_224     = UUIDv5(urn:oid:2.16.840.1.101.3.4.2.4)  = 85eed581-369c-5931-a7fe-0d8158e83871\r\n```\r\n\r\nNot this:\r\n\r\n```\r\n   SHA2_224     = UUIDv5(OID 2.16.840.1.101.3.4.2.4)  = e0f20710-25d9-54ab-8325-ccf2d456ad0b\r\n```\r\n\r\nBut I'm not sure if it's important.",
          "createdAt": "2023-09-06T21:21:21Z",
          "updatedAt": "2023-09-06T21:22:02Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "UUIDv5 requires two parameters:  Namespace ID and Payload.  So the notation `UUIDv5(urn:oid:2.16.840.1.101.3.4.2.4)` is incomplete.\r\n\r\nThe full notation of `UUIDv5(OID 2.16.840.1.101.3.4.2.4)` would be `UUIDv5(\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\", \"2.16.840.1.101.3.4.2.4\")`, but then the line becomes too long.\r\n\r\n\r\nEdit: I have changed my proposal to `UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.4\")` . This should be more clear what I mean.",
          "createdAt": "2023-09-06T21:25:26Z",
          "updatedAt": "2023-09-06T21:27:56Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "> The full notation of UUIDv5(OID 2.16.840.1.101.3.4.2.4) would be UUIDv5(\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\", \"2.16.840.1.101.3.4.2.4\"), but then the line becomes too long.\r\n\r\nYes, I noticed that the namespace parameter was implicit.",
          "createdAt": "2023-09-06T21:28:06Z",
          "updatedAt": "2023-09-06T21:28:32Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "> The following UUIDs were created by using a UUIDv5 with the OID namespace ID\r\n   (\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\") and the OID identifying the\r\n   hash algorithm. \r\n>    SHA2_224     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.4\")  = \"e0f20710-25d9-54ab-8325-ccf2d456ad0b\"\r\n\r\nI completely agree now. \u2764\ufe0f \r\n\r\n-- \r\n\r\nP.S.\r\nIt also breaks [my implementation](https://github.com/f4b6a3/uuid-creator/blob/master/src/main/java/com/github/f4b6a3/uuid/alt/GUID.java#L342) of UUIDv8 using SHA-256. \ud83d\ude22 ",
          "createdAt": "2023-09-06T21:34:33Z",
          "updatedAt": "2023-09-06T21:53:32Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, it breaks some implementations, including mine. But after all, Internet Drafts are supposed to change. :-)\r\nI really hope my proposal gets accepted, because I think it is perfect to use OIDs. They are unambiguous and so everyone can define their own hashspace IDs.",
          "createdAt": "2023-09-06T21:57:10Z",
          "updatedAt": "2023-09-06T21:57:52Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, Your proposal of `UUIDv5(NS_OID, \"Hash_OID_NO_LEADING_DOT\")` works for the NIST ones that have OIDs. \r\nAre we to assume every cryptographic hashing function will have an OID?\r\n\r\nChecking against your list earlier:\r\n```\r\nMD2               = \"1.2.840.113549.2.2\"\r\nMD4               = \"1.2.840.113549.2.4\"\r\nMD5               = \"1.2.840.113549.2.5\" (But probably just use v3)\r\nTIGER/192         = \"1.3.6.1.4.1.11591.12.2\"\r\nRIPEMD160         = \"1.0.10118.3.0.49\" or \"1.3.36.3.2.1\"\r\nRIPEMD128         = \"1.0.10118.3.0.50\" or \"1.3.36.3.2.2\"\r\nRIMEMD256         = \"1.3.36.3.2.3\"\r\nWHIRLPOOL         = \"1.0.10118.3.0.55\"?\r\nGOST3410-2012-256 = \"1.2.643.7.1.1.3.2\"\r\nGOST3410-2012-512 = \"1.2.643.7.1.1.3.3\"\r\nHAVAL-3-128       = \"1.3.6.1.4.1.18105.2.1.1.1\"\r\nHAVAL-3-160       = \"1.3.6.1.4.1.18105.2.1.1.2\"\r\nHAVAL-3-192       = \"1.3.6.1.4.1.18105.2.1.1.3\"\r\nHAVAL-3-224       = \"1.3.6.1.4.1.18105.2.1.1.4\"\r\nHAVAL-3-256       = \"1.3.6.1.4.1.18105.2.1.1.5\"\r\nHAVAL-4-128       = \"1.3.6.1.4.1.18105.2.1.1.6\"\r\nHAVAL-4-160       = \"1.3.6.1.4.1.18105.2.1.1.7\"\r\nHAVAL-4-192       = \"1.3.6.1.4.1.18105.2.1.1.8\"\r\nHAVAL-4-224       = \"1.3.6.1.4.1.18105.2.1.1.9\"\r\nHAVAL-4-256       = \"1.3.6.1.4.1.18105.2.1.1.1\"\r\nHAVAL-5-128       = \"1.3.6.1.4.1.18105.2.1.1.1\"\r\nHAVAL-5-160       = \"1.3.6.1.4.1.18105.2.1.1.1\"\r\nHAVAL-5-192       = \"1.3.6.1.4.1.18105.2.1.1.1\"\r\nHAVAL-5-224       = \"1.3.6.1.4.1.18105.2.1.1.1\"\r\nHAVAL-5-256       = \"1.3.6.1.4.1.18105.2.1.1.1\"\r\nSNEFRU            = ???\r\n```\r\n\r\nRIPEMD may have two and SNEFRU does not have one that I can find?\r\nHow would we handle something like that?\r\n\r\n---\r\n\r\n@fabiolimace \r\n> I just don't know which are the current canonical names for the SHA-2 family. For example, [Wikipedia](https://en.wikipedia.org/wiki/SHA-2) and [Java](https://docs.oracle.com/en/java/javase/11/docs/specs/security/standard-names.html#messagedigest-algorithms) use SHA-256 (with a dash), but not SHA2_256 (with a 2 and an underline).\r\n\r\nI can change them to the NIST document items easy enough. I added the \"2\" so they were somewhat inline with SHA3 from a formatting perspective and I I swapped the \"/\" char for an underscore. Underscores were used because they matched the underscores used in the namespace items. \r\n\r\nBut I am not partial. I can change them to the following as defined by [FIPS180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf>) and [FIPS202](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf)\r\n```\r\nSHA-224      = \"...whatever we choose...\"\r\nSHA-256      = \"...whatever we choose...\"\r\nSHA-384      = \"...whatever we choose...\"\r\nSHA-512      = \"...whatever we choose...\"\r\nSHA-512/224  = \"...whatever we choose...\"\r\nSHA-512/256  = \"...whatever we choose...\"\r\nSHA3-224     = \"...whatever we choose...\"\r\nSHA3-256     = \"...whatever we choose...\"\r\nSHA3-384     = \"...whatever we choose...\"\r\nSHA3-512     = \"...whatever we choose...\"\r\nSHAKE128     = \"...whatever we choose...\"\r\nSHAKE256     = \"...whatever we choose...\"\r\n```\r\n",
          "createdAt": "2023-09-06T23:19:11Z",
          "updatedAt": "2023-09-06T23:19:11Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The new names according to FIPS180-4 and FIPS202 look good to me.\r\nI think \"SHA-512/256\" reads much better than \"SHA2_512_256\".\r\n\r\n---\r\n\r\nAbout algorithms with multiple OIDs, I would try to find the \"official\" ones.\r\nBut I know that task can be hard and it might be ambigous.\r\n\r\nAbout algorithms without known OID, I think this could be out-of-scope.\r\nSince the mechanism is optional, people would need to define own UUIDs,\r\ne.g. UUIDv1 or UUIDv4 for these hash algorithms.\r\n\r\nI am not sure if my proposal 1 (that used algorithm names in a custom namespace,\r\ne.g. `UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"SHA-512/224\")` ) would be better.\r\n@kyzer-davis  What is your opinion to my proposal 1 ?\r\nMany people and even implementations like PHP use hash algorithm names like \"GOST\",\r\nbut there are so many GOST algorithms, that we do not know what is implemented,\r\nso the risk is that someone does this:  `UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"GOST\")`\r\n",
          "createdAt": "2023-09-06T23:43:25Z",
          "updatedAt": "2023-09-06T23:52:46Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "I found a list of OIDs here (extracted from [github.com/openssl](https://github.com/openssl/openssl/blob/9537fe5757bb07761fa275d779bbd40bcf5530e4/crypto/objects/objects.txt)):\r\nhttps://version.cs.vt.edu/techstaff/linux-audit/-/blob/861ecd5cf6005a1bb1a16d840713f56c425f1039/ansible2/ansible/module_utils/crypto.py#L405\r\n\r\n<s>\r\nI also found OIDs for some GOST (GOvernment STandard, RU) digests in this document: \r\n[RFC-9215: Using GOST R 34.10-2012 and GOST R 34.11-2012 Algorithms with the Internet X.509 Public Key Infrastructure](https://www.rfc-editor.org/rfc/rfc9215.html#section-3).\r\n\r\n> The ASN.1 OID used to identify the GOST R 34.11-2012 hash function with a 256-bit hash code is: \r\n> \r\n> id-tc26-gost3411-12-256 OBJECT IDENTIFIER ::= { iso(1) member-body(2) ru(643) rosstandart(7) tc26(1) algorithms(1) digest(2) gost3411-12-256(2)}\r\n\r\n> The ASN.1 OID used to identify the GOST R 34.11-2012 hash function with a 512-bit hash code is:\r\n> \r\n> id-tc26-gost3411-12-512 OBJECT IDENTIFIER ::= { iso(1) member-body(2) ru(643) rosstandart(7) tc26(1) algorithms(1) digest(2) gost3411-12-512(3)}\r\n\r\nLinks: \r\n* GOST R 34.11-2012 hash function with 256-bit hash code: http://oid-info.com/get/1.2.643.7.1.1.2.2\r\n* GOST R 34.11-2012 hash function with 512-bit hash code: http://oid-info.com/get/1.2.643.7.1.1.2.3\r\n</s>\r\n\r\n**EDIT:** GOST OIDs are already in [kyzer's list](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143#issuecomment-1709247194).",
          "createdAt": "2023-09-07T02:09:42Z",
          "updatedAt": "2023-09-07T02:21:21Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It might be a bit off-topic, but I am very confused about the implementations in PHP.\r\n\r\n~- There is the algorithm \"gost\" which is \"GOST R 34.11-94\" (OID = 1.2.643.2.2.9); I have verified it with test vectors. [Wikipedia](https://en.wikipedia.org/wiki/GOST_(hash_function)) and other sources imply that the hash algorithm name \"GOST\" is describing the algorithm \"GOST R 34.11-94\". So, would be `UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"GOST\")` unambiguous to the majority of users?~\r\n\r\n~- And there is the \"[gost-crypto](http://docs.php.net/manual/en/migration56.new-features.php#migration56.new-features.gost)\" hash algorithm where I do not understand what it does and how it can be identified (neither as algorithm name nor as OID). My software solution gave the hashspace ID `UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"gost-crypto\")`, but I guess this is nonsense and ambigous.~\r\n\r\n~So, algorithm names are tricky..~\r\n\r\n\r\n\r\n**(Edit: Found the solution)**\r\n\r\n- PHP algorithm name \"gost\" is \"GOST R 34.11-94\" with \"Test parameter set\" (OID 1.2.643.2.2.30.0), defined in RFC 4357, section 11.2.\r\n\r\n    Hashspace ID with my proposal 1:  `UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"GOST\")` ?????\r\n    Hashspace ID with my proposal 2:  `UUIDv5(NS_OID, \"1.2.643.2.2.30.0\")`\r\n\r\n- PHP algorithm name \"[gost-crypto](http://docs.php.net/manual/en/migration56.new-features.php#migration56.new-features.gost)\" is also \"GOST R 34.11-94\", but with \"CryptoPro parameter set\" (OID 1.2.643.2.2.30.1), defined in RFC 4357, section 11.2.\r\n\r\n    Hashspace ID with my proposal 1:  `UUIDv5(\"1ee317e2-1853-64b2-8fe9-3c4a92df8582\", \"GOST-CryptoProParamSet\")` ?????\r\n    Hashspace ID with my proposal 2:  `UUIDv5(NS_OID, \"1.2.643.2.2.30.1\")`\r\n\r\n- However, the algorithm \"GOST R 34.11-94\" seems to be identified by the OID \"1.2.643.2.2.9\" and \"1.2.643.2.2.20\" too. This is confusing because this OID does not define which parameter set is used. So, with my proposal 2, the OID must not only identify the algorithm itself but also its parameters, variants, etc.\r\n\r\n",
          "createdAt": "2023-09-07T10:29:08Z",
          "updatedAt": "2023-09-07T13:35:50Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "From reading Wikipedia, `md_gost94` appears to be obsolete like MD5 or SHA-1, and `md_gost12_256`/`md_gost12_512` the counterparts of SHA-2 or SHA-3.\r\n\r\n[GOST](https://en.wikipedia.org/wiki/GOST_(hash_function)) = **go**vernment **st**andard R 34.11-94\r\n[Streebog](https://en.wikipedia.org/wiki/Streebog) = **go**vernment **st**andard R 34.11-2012\r\n\r\nIs that correct?\r\n",
          "createdAt": "2023-09-07T11:52:13Z",
          "updatedAt": "2023-09-07T11:52:13Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, personally I like proposal 2 of the OIDs because they are \"well formatted\" that is they are a set of \"numbers and a dots\".\r\n\r\nProposal 1 has the challenge that SHA256, sha256, sha-256, SHA-256 all produce different hashes and proposal 2 removes that. \r\n\r\nProposal 2 has the challenges I listed but the points may be moot as many of the items we are discussing are algos nobody will likely ever use...\r\n\r\n```bash\r\nkydavis@ubuntu-web-server:~$ echo -n \"SHA256\" | sha256sum\r\nb3abe5d8c69b38733ad57ea75e83bcae42bbbbac75e3a5445862ed2f8a2cd677  -\r\n\r\nkydavis@ubuntu-web-server:~$ echo -n \"SHA-256\" | sha256sum\r\nbbd07c4fc02c99b97124febf42c7b63b5011c0df28d409fbb486b5a9d2e615ea  -\r\n\r\nkydavis@ubuntu-web-server:~$ echo -n \"sha256\" | sha256sum\r\n5d5b09f6dcb2d53a5fffc60c4ac0d55fabdf556069d6631545f42aa6e3500f2e  -\r\n\r\nkydavis@ubuntu-web-server:~$ echo -n \"sha-256\" | sha256sum\r\n3128f8ac2988e171a53782b144b98a5c2ee723489c8b220cece002916fbc71e2  -\r\n```",
          "createdAt": "2023-09-07T18:32:36Z",
          "updatedAt": "2023-09-07T19:02:30Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> points may be moot as many of the items we are discussing are algos nobody will likely ever use...\r\n\r\n@kyzer-davis Are you referring to the small discussion(s) about HAVAL and GOST and my long OID list above? Don't worry, they were just part of my personal evaluation process to find out if proposal 1 or proposal 2 are better in regards to the Non-NIST algorithms, because you mentioned missing and ambiguous OIDs, so I was wondering if this is a serious issue or not. I don't propose that GOST, HAVAL, Tiger, ... get added to the RFC.\r\n\r\n\r\n**_To avoid confusion in this large thread, here is my proposed text (Proposal 2):_**\r\n\r\n```\r\nAppendix B.  Some Hashspace IDs\r\n\r\n   This appendix lists some hashspace IDs for use with UUIDv8 name-based\r\n   UUIDs.\r\n\r\n   The following UUIDs were created by using a UUIDv5 with the\r\n   OID namespace ID (\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\") and the\r\n   OID identifying the hash algorithm.  This mechanism of generating a\r\n   hashspace ID is OPTIONAL.  Any UUID can be used as a hashspace ID.\r\n\r\n   SHA-224      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.4\")  = \"e0f20710-25d9-54ab-8325-ccf2d456ad0b\"\r\n   SHA-256      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.1\")  = \"29f7f1c6-6258-5be3-b9f0-2adc24eb96c6\"\r\n   SHA-384      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.2\")  = \"728cae51-ddd4-5401-b52c-5775cd8913d8\"\r\n   SHA-512      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.3\")  = \"a5dd0c9d-04b0-5f15-9332-c0ff97053dda\"\r\n   SHA-512/224  = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.5\")  = \"3b72d097-ee4d-54e0-a3ab-cbc072d6d159\"\r\n   SHA-512/256  = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.6\")  = \"af4f3a3f-167e-53b5-8817-66d5201cb05a\"\r\n   SHA3-224     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.7\")  = \"4b5be759-1e10-56ff-9187-1a34f5773d9f\"\r\n   SHA3-256     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.8\")  = \"2eea60a9-2f2b-5d32-93b2-dc9688165cfa\"\r\n   SHA3-384     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.9\")  = \"f49d66f8-0755-5500-b747-ef5f7a18e9bc\"\r\n   SHA3-512     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.10\") = \"e3936772-aa32-5463-870b-0a05a6bb2dd3\"\r\n   SHAKE128     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.11\") = \"bd2da541-a66d-52a7-8cf7-3773e204c114\"\r\n   SHAKE256     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.12\") = \"a1a5a6ea-b4fd-5f93-91e3-a25de6121457\"\r\n```\r\n\r\nSince the lines are too long for RFC, here is a variant with line breaks:\r\n(Unfortunately, the line breaks are very ugly)\r\n\r\n```\r\nAppendix B.  Some Hashspace IDs\r\n\r\n   This appendix lists some hashspace IDs for use with UUIDv8 name-based\r\n   UUIDs.\r\n\r\n   The following UUIDs were created by using a UUIDv5 with the\r\n   OID namespace ID (\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\") and the\r\n   OID identifying the hash algorithm.  This mechanism of generating a\r\n   hashspace ID is OPTIONAL.  Any UUID can be used as a hashspace ID.\r\n\r\n   SHA-224      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.4\")\r\n                = \"e0f20710-25d9-54ab-8325-ccf2d456ad0b\"\r\n   SHA-256      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.1\")\r\n                = \"29f7f1c6-6258-5be3-b9f0-2adc24eb96c6\"\r\n   SHA-384      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.2\")\r\n                = \"728cae51-ddd4-5401-b52c-5775cd8913d8\"\r\n   SHA-512      = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.3\")\r\n                = \"a5dd0c9d-04b0-5f15-9332-c0ff97053dda\"\r\n   SHA-512/224  = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.5\")\r\n                = \"3b72d097-ee4d-54e0-a3ab-cbc072d6d159\"\r\n   SHA-512/256  = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.6\")\r\n                = \"af4f3a3f-167e-53b5-8817-66d5201cb05a\"\r\n   SHA3-224     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.7\")\r\n                = \"4b5be759-1e10-56ff-9187-1a34f5773d9f\"\r\n   SHA3-256     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.8\")\r\n                = \"2eea60a9-2f2b-5d32-93b2-dc9688165cfa\"\r\n   SHA3-384     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.9\")\r\n                = \"f49d66f8-0755-5500-b747-ef5f7a18e9bc\"\r\n   SHA3-512     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.10\")\r\n                = \"e3936772-aa32-5463-870b-0a05a6bb2dd3\"\r\n   SHAKE128     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.11\")\r\n                = \"bd2da541-a66d-52a7-8cf7-3773e204c114\"\r\n   SHAKE256     = UUIDv5(NS_OID, \"2.16.840.1.101.3.4.2.12\")\r\n                = \"a1a5a6ea-b4fd-5f93-91e3-a25de6121457\"\r\n```\r\n\r\nAnother format that does not use the `UUIDv5()` pseudo-method and `NS_OID` constant (line breaks are still ugly):\r\n\r\n```\r\nAppendix B.  Some Hashspace IDs\r\n\r\n   This appendix lists some hashspace IDs for use with UUIDv8 name-based\r\n   UUIDs.\r\n\r\n   The following UUIDs were created by using a UUIDv5 with the\r\n   OID namespace ID (\"6ba7b812-9dad-11d1-80b4-00c04fd430c8\") and the\r\n   OID identifying the hash algorithm.  This mechanism of generating a\r\n   hashspace ID is OPTIONAL.  Any UUID can be used as a hashspace ID.\r\n\r\n   SHA-224 (2.16.840.1.101.3.4.2.4)\r\n                = \"e0f20710-25d9-54ab-8325-ccf2d456ad0b\"\r\n   SHA-256 (2.16.840.1.101.3.4.2.1)\r\n                = \"29f7f1c6-6258-5be3-b9f0-2adc24eb96c6\"\r\n   SHA-384 (2.16.840.1.101.3.4.2.2)\r\n                = \"728cae51-ddd4-5401-b52c-5775cd8913d8\"\r\n   SHA-512 (2.16.840.1.101.3.4.2.3)\r\n                = \"a5dd0c9d-04b0-5f15-9332-c0ff97053dda\"\r\n   SHA-512/224 (2.16.840.1.101.3.4.2.5)\r\n                = \"3b72d097-ee4d-54e0-a3ab-cbc072d6d159\"\r\n   SHA-512/256 (2.16.840.1.101.3.4.2.6)\r\n                = \"af4f3a3f-167e-53b5-8817-66d5201cb05a\"\r\n   SHA3-224 (2.16.840.1.101.3.4.2.7)\r\n                = \"4b5be759-1e10-56ff-9187-1a34f5773d9f\"\r\n   SHA3-256 (2.16.840.1.101.3.4.2.8)\r\n                = \"2eea60a9-2f2b-5d32-93b2-dc9688165cfa\"\r\n   SHA3-384 (2.16.840.1.101.3.4.2.9)\r\n                = \"f49d66f8-0755-5500-b747-ef5f7a18e9bc\"\r\n   SHA3-512 (2.16.840.1.101.3.4.2.10)\r\n                = \"e3936772-aa32-5463-870b-0a05a6bb2dd3\"\r\n   SHAKE128 (2.16.840.1.101.3.4.2.11)\r\n                = \"bd2da541-a66d-52a7-8cf7-3773e204c114\"\r\n   SHAKE256 (2.16.840.1.101.3.4.2.12)\r\n                = \"a1a5a6ea-b4fd-5f93-91e3-a25de6121457\"\r\n```\r\n\r\n\r\n@kyzer-davis  If you agree, can you please add one of these to a pull request? Thank you very much!",
          "createdAt": "2023-09-07T19:11:07Z",
          "updatedAt": "2023-09-08T00:22:13Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "Another way to demonstrate the hashspaces is to show a predefined list followed by the pseudocode used to generate the list. I find it (almost) impossible to have doubts about how the list was generated. Separating the list from the steps to generate it takes less \"cognitive effort\", in my opinion.\r\n\r\nPredefined list of hashspaces:\r\n\r\n```\r\n   SHA-224     = \"e0f20710-25d9-54ab-8325-ccf2d456ad0b\"\r\n   SHA-256     = \"29f7f1c6-6258-5be3-b9f0-2adc24eb96c6\"\r\n   SHA-384     = \"728cae51-ddd4-5401-b52c-5775cd8913d8\"\r\n   SHA-512     = \"a5dd0c9d-04b0-5f15-9332-c0ff97053dda\"\r\n   SHA-512/224 = \"3b72d097-ee4d-54e0-a3ab-cbc072d6d159\"\r\n   SHA-512/256 = \"af4f3a3f-167e-53b5-8817-66d5201cb05a\"\r\n   SHA3-224    = \"4b5be759-1e10-56ff-9187-1a34f5773d9f\"\r\n   SHA3-256    = \"2eea60a9-2f2b-5d32-93b2-dc9688165cfa\"\r\n   SHA3-384    = \"f49d66f8-0755-5500-b747-ef5f7a18e9bc\"\r\n   SHA3-512    = \"e3936772-aa32-5463-870b-0a05a6bb2dd3\"\r\n   SHAKE128    = \"bd2da541-a66d-52a7-8cf7-3773e204c114\"\r\n   SHAKE256    = \"a1a5a6ea-b4fd-5f93-91e3-a25de6121457\"\r\n```\r\n\r\nPseudocode to derive hashspaces from message digest OIDs:\r\n\r\n```awk\r\n   # array of message digest OIDs\r\n   OID[\"SHA-224\"]     = \"2.16.840.1.101.3.4.2.4\"\r\n   OID[\"SHA-256\"]     = \"2.16.840.1.101.3.4.2.1\"\r\n   OID[\"SHA-384\"]     = \"2.16.840.1.101.3.4.2.2\"\r\n   OID[\"SHA-512\"]     = \"2.16.840.1.101.3.4.2.3\"\r\n   OID[\"SHA-512/224\"] = \"2.16.840.1.101.3.4.2.5\"\r\n   OID[\"SHA-512/256\"] = \"2.16.840.1.101.3.4.2.6\"\r\n   OID[\"SHA3-224\"]    = \"2.16.840.1.101.3.4.2.7\"\r\n   OID[\"SHA3-256\"]    = \"2.16.840.1.101.3.4.2.8\"\r\n   OID[\"SHA3-384\"]    = \"2.16.840.1.101.3.4.2.9\"\r\n   OID[\"SHA3-512\"]    = \"2.16.840.1.101.3.4.2.10\"\r\n   OID[\"SHAKE128\"]    = \"2.16.840.1.101.3.4.2.11\"\r\n   OID[\"SHAKE256\"]    = \"2.16.840.1.101.3.4.2.12\"\r\n   \r\n   # function do derive hashspaces from message digest OIDs\r\n   function hashspace(algo) { return UUIDv5(NAMESPACE_OID, OID[algo]) }\r\n```\r\n\r\nNote: the pseudocode is based on AWK syntax. Implementers can simply copy the pseudocode and change it to suit the target language syntax. If I was the implementer, I would appreciate it.\r\n",
          "createdAt": "2023-09-08T01:28:33Z",
          "updatedAt": "2023-09-15T09:54:58Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it @fabiolimace and @danielmarschall. \r\nI will go with the OID method for obtaining the Hashspace ID. aka \"Proposal 2\"\r\n\r\nDon't worry about formatting, I will get that figured out. Could end up as some ascii, some table, etc. \r\n\r\nPR will likely happen next week.\r\n\r\nFinally, depending on how the discussion over in #144 shakes out one could possibly add a new hashspace ID to the IANA registry without needing a full on spec to do so. Just needs to be defined by the way we say in this doc and then added to that table. \r\n`Name`, `OID`, `ID`, `Doc for Hash Algo` would be the columns in my mind \r\nThis would help when some next gen crypto comes out and somebody wants to define the hashspace for it. Much easier via an email template than a full on RFC. (Same goes for some legacy algo if somebody wanted to use it, update the registry and now anybody can leverage it.",
          "createdAt": "2023-09-08T14:56:02Z",
          "updatedAt": "2023-09-08T14:56:02Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm somewhat concerned about this OID + UUIDv5 approach because:\r\n\r\n- With this approach, any future hash function will automatically get its hash space ID when it gets an OID. Technically, such a new hash space ID will have to get ratified through a formal process, but this approach does create expectations that such a new ID will be ratified. In this way future spec authors might lose control over the hash space ID definitions.\r\n- This approach creates a use case of v5 from now on, whereas v5 and SHA1 are no way recommended for future uses.\r\n\r\nI think v4 based IDs are simpler and safer.",
          "createdAt": "2023-09-14T23:50:46Z",
          "updatedAt": "2023-09-14T23:50:46Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "> I think v4 based IDs are simpler and safer.\r\n\r\n<strike>This is a question I've been trying to answer myself for a while: how good is a 160- or 256-bit truncated hash compared to a 128-bit random number?\r\n\r\nI've tried a [few times](https://gist.github.com/fabiolimace/cd46eeaebcf9121110edfd2f1aefbd49), but I always fail miserably because I don't have the statistical knowledge to give an answer.\r\n\r\nI always end up, in my naive attempts, trusting in the principle of [Saint Thomas](https://en.wikipedia.org/wiki/Thomas_the_Apostle): seeing is believing. However, I can't see any difference with my eyes.\r\n\r\nHowever, I believe that hash-based UUIDs are still very useful for associating a binary or textual value with a relatively short ID in a permanent and (almost) univocal way.</strike>\r\n\r\n**EDIT**: I crossed out the text because I realized I misunderstood the sentence. Please ignore. (but the question still remains)",
          "createdAt": "2023-09-15T00:22:40Z",
          "updatedAt": "2023-09-15T00:32:45Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The crossed out question is a different topic but I think is a very good question, which neither do I have an answer to. Please take a look at several posts relating to FIPS stuff following [my original post about the hash space approach](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/50#issuecomment-1419980354).",
          "createdAt": "2023-09-15T00:47:32Z",
          "updatedAt": "2023-09-15T00:47:32Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'm somewhat concerned about this OID + UUIDv5 approach because:\r\n> \r\n> * With this approach, any future hash function will automatically get its hash space ID when it gets an OID. Technically, such a new hash space ID will have to get ratified through a formal process, but this approach does create expectations that such a new ID will be ratified. In this way future spec authors might lose control over the hash space ID definitions.\r\n> * This approach creates a use case of v5 from now on, whereas v5 and SHA1 are no way recommended for future uses.\r\n> \r\n> I think v4 based IDs are simpler and safer.\r\n\r\nI can understand your concern that UUIDv5 is using a deprecated hash algorithm.\r\n\r\nBut I think it is very useful that the hash space is not just random, but connected with the algorithm.\r\nLet's imagine the case when someone wants to use a Non-NIST hash algorithm, e.g. HAVAL-3-128.\r\n\r\nImagine IANA does not have that hash listed. By using random UUIDv4, someone needs to choose/generate a hash space id, and IANA needs to add it. Maybe IANA even insists that a RFC is written that defines the hash space ID. But do you think every developer who wants to use a Non-NIST hash will contact IANA or even write a RFC?\r\n\r\nA lot of algorithms have OIDs. This is important for some technologies like X.509. By having the hash space (optionally) be derivated from the OID means that two developers can hash using HAVAL-3-128, and since HAVAL-3-128 has OID \"1.3.6.1.4.1.18105.2.1.1.1\", both implementations output the same UUID. Without writing a RFC, without contacting IANA.\r\n(And yes, I know that some hash algorithms have an biguous OID or no OID at all. But my research showed that I the majority of algorithms has exactly one OID)",
          "createdAt": "2023-09-15T07:40:30Z",
          "updatedAt": "2023-09-15T08:01:18Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In my opinion, such a new hash function must be registered through a formal process (by a separate RFC or IANA registry, I don't know) unless the new UUID RFC specifies the algorithm to derive a hash space ID in a normative manner. Otherwise, the de facto hash space ID crafted by future implementers will be put on an uncertain state. So far, the name-based v8 is just an example of v8 implementation techniques, and we will have no time to put this in the normative section. With this in mind, we shouldn't create any expectations related to the future hash space IDs. UUIDv4-based hash space IDs do require a formal process to ratify new hash functions, and accordingly give the full control over the UUID specification to the future spec authors to recommend one hashing algorithm and discourage another.",
          "createdAt": "2023-09-15T15:10:35Z",
          "updatedAt": "2023-09-15T15:10:35Z"
        },
        {
          "author": "cbandy",
          "authorAssociation": "NONE",
          "body": "My naive and scattered thoughts:\r\n- v4 random can potentially collide with any other v4 value generated in the past or future.\r\n- Implicitly, the scheme will work because people use the values in a specific context: RFC 4122 hashspaces.\r\n- However, the list of meaningful values is trapped in a single RFC. After it is published, how can people in the future, outside of the RFC, know they aren't generating a v4 value that someone else has already attributed meaning to? The topic of a registry [has already been covered](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143#issuecomment-1711804042).\r\n- v5 values have a context that lives beyond/outside a v4 list in the RFC. The downside is that uniqueness must come from elsewhere: OIDs in the above examples. \r\n  - That uniqueness is, again, a list somewhere. The topic of a registry has already been covered.\r\n  - The deterministic nature of v5 also means that two different inputs _could_ (theoretically) collide in the future without recourse.<br/><br/>\r\n- I keep using the word \"future.\" Things from the past are facts and do not change. The risk of collision is in the future.\r\n- We have UUID schemes that include time. In those, values from \"the past\" are separate and discernable from values of \"the future.\"\r\n\r\nWould it be better to identify these hashspaces using v7?",
          "createdAt": "2023-09-16T21:44:21Z",
          "updatedAt": "2023-09-16T21:44:21Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "<del>v7 works, so does v4, I think though.</del>\r\n\r\n**EDIT**: v4 is better because of its randomness. Hash space IDs are passed to another hash function so should be very different from each other.",
          "createdAt": "2023-09-16T23:18:19Z",
          "updatedAt": "2023-09-17T00:14:41Z"
        },
        {
          "author": "chorman0773",
          "authorAssociation": "NONE",
          "body": "I saw the OID proposal above, and I'd like to second that.\r\n\r\nThis would allow 3rd parties can also define new Hashspace UUIDs, if they have an OID they can control (and hand out sub-OIDs from), which they can get from the IANA. It would also allow users of v9 to substitute a v5 UUID in out-of-band transport with simply the OID for the algorithm itself. The main risk of doing this, in my opinion, without a centralized registry is that one algorithm might end up with 2 different OIDs in different contexts. If this route is taken, there should be guidance to avoid anti-collisions.",
          "createdAt": "2023-09-17T21:43:59Z",
          "updatedAt": "2023-09-17T21:43:59Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Since it's v8, any third party can generate a UUID and use it in their application as a hashspace ID for any hash function. Perhaps, we should expand the following statement in Section 6.5 to clarify that any user-defined UUID value may be used as a hashspace ID within an application context. This point is not sufficiently clear in the current draft, despite #132.\r\n\r\n> These MAY leverage newer hashing protocols such as ... or _even protocols that have not been defined yet_.\r\n\r\nWithin an implementation can the implementer do whatever they want, but a standard has to focus in the coordination of such implementations. What if SHA-4 has a parameter that is not expressed in the OID? What if a widespread implementation applies SHA-5 differently than expected? These circumstances may risk the future interoperability under the OID-based hashspace scheme. Plus, observing such a situation, future RFC authors might even avoid ratifying an OID-based hashspace ID because officially specifying the meaning of widely used hashspace ID can destroy the existing implementations.\r\n",
          "createdAt": "2023-09-18T01:33:03Z",
          "updatedAt": "2023-09-18T01:33:03Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Getting caught up on these longer threads after being out unexpectedly. \r\nI see there have been lots of discussions...\r\nAs such, I will hold off on changes for the moment. We can aim for this as a topic on the interim call the chairs have requested.",
          "createdAt": "2023-09-20T19:52:08Z",
          "updatedAt": "2023-09-20T19:52:08Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If you do not have a datatracker.ietf.org login, please get one, as you'll need it for the virtual interim.  That's the only barrier to participation.   Slides uploaded to datatracker would also be appreciated.",
          "createdAt": "2023-09-22T17:08:33Z",
          "updatedAt": "2023-09-22T17:08:33Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@mcr \"Slides uploaded to datatracker would also be appreciated.\" yeah, I will get some to the chairs this week!",
          "createdAt": "2023-09-25T14:36:13Z",
          "updatedAt": "2023-09-25T14:36:13Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @mcr \"Slides uploaded to datatracker would also be appreciated.\" yeah, I will get some to the chairs this week!\r\n\r\nif @danielmarschall  or others still feel they want v9, then they also need to explain the proposal in a slide or two.",
          "createdAt": "2023-09-26T18:41:38Z",
          "updatedAt": "2023-09-26T18:41:38Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "As per #147, Hashspace IDs were removed. Which would resolve this discuss item if merged.\r\nPlease see the proposal in #147 and leave feedback on that topic there.\r\n",
          "createdAt": "2023-09-28T16:59:41Z",
          "updatedAt": "2023-09-28T16:59:41Z"
        }
      ]
    },
    {
      "number": 144,
      "id": "I_kwDOH6Ln3M5wUd0u",
      "title": "Request IANA Registry",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/144",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "From Paul Wouters:\r\n```\r\nI am not sure that I agree that no IANA registry is required for hashspace\r\nID's. If another document adds new hashspace IDs, there won't be a single\r\ndocument anymore that lists all of them, or massive duplication. This is\r\nexactly what we use IANA registries for. Reconsider creating a new IANA registry.\r\n```\r\n\r\nIANA registration encompass;\r\n\r\n1. UUID Variants\r\n2. UUID \"sub-versioning\" (as linked to a variant) \r\n   - See them all here: https://github.com/uuid6/uuid6-ietf-draft/issues/26#issuecomment-1062164457\r\n   - Nil/Max UUID\r\n4. UUID Namespace IDs\r\n5. UUID Hashspace IDs",
      "createdAt": "2023-09-06T17:01:02Z",
      "updatedAt": "2023-10-09T20:14:42Z",
      "closedAt": "2023-10-09T20:14:42Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Commenting for @ben221199 as per his vote for this under \r\nhttps://github.com/ietf-wg-uuidrev/rfc4122bis/issues/83#issuecomment-1548210298",
          "createdAt": "2023-09-06T17:01:31Z",
          "updatedAt": "2023-09-06T17:01:31Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I'm definitely planning to have IANA considerations in the historical RFC that I want to make with @kyzer-davis after RFC4122bis is published. However, if we already can add some basic IANA considerations in RFC4122bis, I'm okay with that, but we should think this out very well. I don't want a shitty table which I regret making, because in that case I prefer having the IANA considerations only in the historical RFC.",
          "createdAt": "2023-09-06T17:36:10Z",
          "updatedAt": "2023-09-06T17:36:10Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "From Francesca Palombini in IESG review:\r\n> I agree with Paul and was surprised to see no IANA registry is created (at least for var and ver), but the document does explicitly mention that \"the authors and working group have concluded that IANA is not required to track UUIDs used for identifying items such as versions, variants, namespaces, or hashspaces.\", so that makes me believe a discussion has happened around it and a conclusion reached. Without knowing much of the background behind it, I'll leave it to the responsible AD to make sure that has been the case.\r\n",
          "createdAt": "2023-09-07T18:22:22Z",
          "updatedAt": "2023-09-07T18:22:22Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Do I have access to this conversation too?",
          "createdAt": "2023-09-07T19:13:54Z",
          "updatedAt": "2023-09-07T19:13:54Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Do I have access to this conversation too?\r\n\r\nIt's on the list archives.\r\nI don't understand IANA considerations in a historical document.\r\n",
          "createdAt": "2023-09-07T20:03:46Z",
          "updatedAt": "2023-09-07T20:03:46Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I see. I also received them by mail, but it was not directly clear from the mail subject.\r\n\r\n---\r\n\r\n> I don't understand IANA considerations in a historical document.\r\n\r\nIs there a problem with it? Or should we make the \"historical\" RFC informational?",
          "createdAt": "2023-09-07T20:11:07Z",
          "updatedAt": "2023-09-07T20:11:07Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "## Proposition:\r\n\r\n_Note: I would suggest to discuss the policies in more detail. In this case I chose the policies I think suits best. For options, see Section 4 in RFC 8126._\r\n\r\n### UUID Variants\r\n\r\n> IANA is asked to create the registry \"UUID Variants\" under the \"UUID Parameters\" group. New registrations will be permitted through the IETF Review policy [BCP26]. Initial values for the UUID Variants registry are given below. Assignments consist of a variant name and its associated bitmap array indicating the variant.\r\n>\r\n> | Name | Bitmap | Definition |\r\n> | - | - | - |\r\n> | Apollo NCS | `0xxxxxxx` | [RFC4122bis] |\r\n> | OSF DCE | `10xxxxxx` | [RFC4122bis] |\r\n> | Microsoft DCOM | `110xxxxx` | [RFC4122bis] |\r\n\r\n_Note: Maybe we should add another column for variant slugs._\r\n\r\n### UUID Subtypes\r\n\r\n> IANA is asked to create the registry \"UUID Subtypes\" under the \"UUID Parameters\" group. New registrations will be permitted through the IETF Review policy [BCP26]. Initial values for the UUID Subtypes registry are given below. Assignments consist of a subtype id, the binary version of the subtype id, subtype name, subtype kind and the variant it belongs to.\r\n>\r\n> | Name | ID | Hexadecimal | Kind | Variant | Definition |\r\n> | - | - | - | - | - | - |\r\n> | Unspecified | 0 | `0x0` | family | Apollo NCS | [RFC4122bis] |\r\n> | Internet (IPv4) | 2 | `0x2` | family | Apollo NCS | [RFC4122bis] |\r\n> | Time-based | 1 | `0x1` | version | OSF DCE | [RFC4122bis] |\r\n> | DCE Security-version | 2 | `0x2` | version | OSF DCE | [RFC4122bis] |\r\n> | Name-based using MD5 | 3 | `0x3` | version | OSF DCE | [RFC4122bis] |\r\n> | Random | 4 | `0x4` | version | OSF DCE | [RFC4122bis] |\r\n> | Name-based using SHA-1 | 5 | `0x5` | version | OSF DCE | [RFC4122bis] |\r\n> | Reordered time-based | 6 | `0x6` | version | OSF DCE | [RFC4122bis] |\r\n> | Unix epoch time-based | 7 | `0x7` | version | OSF DCE | [RFC4122bis] |\r\n> | Custom | 8 | `0x8` | version | OSF DCE | [RFC4122bis] |\r\n\r\n_Note: Maybe we can do this a little bit better. Possibly using variant slugs._\r\n\r\n### UUID Special Forms\r\n\r\n> IANA is asked to create the registry \"UUID Special Forms\" under the \"UUID Parameters\" group. New registrations will be permitted through the IETF Review policy [BCP26]. Initial values for the UUID Subtypes registry are given below. Assignments consist of a name and its associated value.\r\n>\r\n> | Name | Value | Definition |\r\n> | - | - | - |\r\n> | Nil UUID | `00000000-0000-0000-0000-000000000000` | [RFC4122bis] |\r\n> | Max UUID | `FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF` | [RFC4122bis] |\r\n\r\n_Note: Seems okay to me, but maybe some columns can be added._\r\n\r\n---\r\n\r\nThis is a proposition. If you have improvements on it, please let us know. Also, lets discuss if IANA Considerations should be added in RFC4122bis, or should be done in another (seperate) RFC.",
          "createdAt": "2023-09-07T21:24:34Z",
          "updatedAt": "2023-09-07T21:25:16Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@ben I was thinking of a hierarchy like below, which would more or less use the tables you described.\r\n\r\n- Logic, main section has variants table.\r\n- Next top level sections are split by the variant (4 total)\r\n  - Each variant section has a \"subtype\" and \"special/reserved\" sub-section.\r\n    - Each of these can have sub-sections\r\n\r\n# Visualized:\r\nEdit 9-11-2023: Removed ascii/text visual\r\nSections would contain table with any required data.\r\n\r\n## What we could setup in rfc4122bis\r\n![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/867657/f9687ee7-fbb3-45e0-bbe5-742150c29bdc)\r\nNote: Special/Reserved only to slot in min/max to the correct area.\r\n\r\n## Long Term, Fully Fleshed Out and Visualized\r\n![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/867657/82d5f048-83a3-420e-b665-597bdda71e93)\r\n\r\n---\r\n\r\nAnother thing to consider is that we need to include how to update this or add new values to this registry:\r\nPersonally I would like to state in each section, something like:\r\n- `uuid-variant-apollo-ncs` and `uuid-variant-microsoft` special/reserved/subtype only requires email template request to the designated expert with supporting 3rd party document. (This could save us from needing historical doc @ben221199)\r\n- For `uuid-variant-osf-dce-ietf` \r\n  - For both `uuid-hashspace-ids`/`uuid-namespace-ids` just require email template with required items to the designated expert in order to update the table.\r\n  - For `uuid-subtype-version` require full RFC detailing algorithm e.g a future UUIDv9 would need to be explicitly defined.\r\n- For `uuid-variant-undefined` (everything) an RFC or some other formal specification (say from ITU, ISO, IEEE, ETC) would be required to flesh this out.\r\n\r\nWe should also state that we won't just reserve any random UUID as \"special/reserved\" outside of hashspace/namespace/min/max. \r\nIf somebody has a UUID value that should be explicitly reserved; it should be documented in an RFC (or equivalent doc type) detailing why this value specifically is special, how it is used, etc.\r\n\r\nEDIT: \r\nShould we include a top level table for \"UUID Representations\", updatable via email template?\r\n\r\nSecond item, should we include the Test Vector UUIDs and any UUID specified in our RFC as special/reserved? in `uuid-variant-osf-dce-ietf`\r\nThis includes All Appendix items and `f81d4fae-7dec-11d0-a765-00a0c91e6bf6` from Section 4 (AND RFC4122)\r\nEdit2: Vectors updatable via RFC or equivalent doc.",
          "createdAt": "2023-09-08T14:26:44Z",
          "updatedAt": "2023-09-11T14:44:12Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> Should we include a top level table for \"UUID Representations\"...?\r\n\r\nIt's a good idea for the future improvements of the RFC4122bis: https://github.com/uuid6/new-uuid-encoding-techniques-ietf-draft/issues/3#issuecomment-1153430817",
          "createdAt": "2023-09-08T16:28:56Z",
          "updatedAt": "2023-09-08T16:28:56Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Hi @kyzer-davis, maybe because it is late here, but your comment confuses me at the moment. I will give it a second look tomorrow, but my first impression is that it seems overcomplicated.\r\n\r\n> (This could save us from needing historical doc @ben221199)\r\n\r\nAlso, I think we cannot avoid writing a new (historical) RFC. AFAIK I thought we didn't want RFC 4122 to describe other variants than the OSF DCE one.",
          "createdAt": "2023-09-08T20:21:40Z",
          "updatedAt": "2023-09-08T20:21:40Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "A few notes:\r\n\r\n- Above you are writing \"Microsoft DCOM\" for the Microsoft Legacy UUIDs. Shouldn't it be just COM? AFAIK, the Legacy UUIDs were already existing in COM, before DCOM was invented.\r\n\r\n- For Apollo NCS, you are only listing Unspec (family 0) and IPv4 (family 2). Missing: DDS (family 13) which was also in use.\r\n\r\n- For Apollo NCS: Shouldn't the other address families be listed too? (although they were never in use)\r\n\r\n```\r\n\u00a0 | socket_$unspec (0x0)\r\n\u00a0 | socket_$unix (0x1)\r\n\u00a0 | socket_$internet (0x2)\r\n\u00a0 | socket_$implink (0x3)\r\n\u00a0 | socket_$pup (0x4)\r\n\u00a0 | socket_$chaos (0x5)\r\n\u00a0 | socket_$ns (0x6)\r\n\u00a0 | socket_$nbs (0x7)\r\n\u00a0 | socket_$ecma (0x8)\r\n\u00a0 | socket_$datakit (0x9)\r\n\u00a0 | socket_$ccitt (0xA)\r\n\u00a0 | socket_$sna (0xB)\r\n\u00a0 | socket_$unspec2 (0xC)\r\n\u00a0 | socket_$dds (0xD)\r\n\r\n```",
          "createdAt": "2023-09-08T23:39:10Z",
          "updatedAt": "2023-09-08T23:51:54Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@ben221199, \r\n> I think we cannot avoid writing a new (historical) RFC. AFAIK I thought we didn't want RFC 4122 to describe other variants than the OSF DCE one.\r\n\r\nI say \"avoid\" only if there is no other doc describing them. If that does not exist, or exist anymore; we can get them in the historical RFC those so they are down on paper and not lost to time. If there is some other doc (like UUIDv2 has) then we can just reference that vs duplicating work.\r\n\r\nAlso, as for complication, I am not opposed to \"one big subtype table\" I was just trying to bundle subtypes and special UUIDs within their own variant sections to make the variant+subtype really shine.\r\n\r\nEdit: \r\nThe section groupings also let us enforce different update methods for each so we can get a bit more granular if need be. \r\nI am open for whatever, I was just thinking about Ben's statement \"we should think this out very well. I don't want a shitty table which I regret making\" in this case maybe I thought on it too much...\r\nEdit2: Updated the format a bit, removed some items to get to the main structure of the data vs the items in the table.\r\n\r\n@danielmarschall, I didn't mean to omit them. I am just not an expert in those specific UUID areas. I would rely heavily on info like that from yourself and Ben to fill out those \"subtypes\". Thank you for helping to complete the list.. and even if they were not used I would like to list them and we can put something like \"allocated but unused\".",
          "createdAt": "2023-09-09T02:09:44Z",
          "updatedAt": "2023-09-09T02:28:41Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "@danielmarschall\r\n\r\n> Above you are writing \"Microsoft DCOM\" for the Microsoft Legacy UUIDs. Shouldn't it be just COM? AFAIK, the Legacy UUIDs were already existing in COM, before DCOM was invented.\r\n\r\nActually, I don't know which is right, but when I searched the internet, DCOM seemed the linked technology to UUID. However, I could be wrong and COM could then be linked to UUID, with DCOM only as extended COM. I think we should dive into Microsoft COM some more to find out what it is, how it works and what it has to do with UUID (and when).\r\n\r\n> For Apollo NCS, you are only listing Unspec (family 0) and IPv4 (family 2). Missing: DDS (family 13) which was also in use.\r\n\r\nI know that number 13 was used too, but at the time of writing I could find the right address family name for 13. I only came across a different name which I knew wasn't correct, or at least not correct in the UUID world. So I decided to not include it in my proposition. Also, it is a proposition; I only wanted to give a good example of how a table would look like. If records are missing, I will definitely add them. Thanks for mentioning DDS; now I remember that one was the correct one.\r\n\r\n> For Apollo NCS: Shouldn't the other address families be listed too? (although they were never in use)\r\n\r\nI want to say yes, but I think it is best to only include the used ones, so 0, 2 and 13. If we find out other ones are used too, we can include them. I think Paul Leach can tell us more about this one.\r\n\r\n---\r\n\r\n@kyzer-davis\r\n\r\n> I say \"avoid\" only if there is no other doc describing them. If that does not exist, or exist anymore; we can get them in the historical RFC those so they are down on paper and not lost to time. If there is some other doc (like UUIDv2 has) then we can just reference that vs duplicating work.\r\n\r\nI have the feeling it is better if we RFC-ify ever type and subtype in the end. We can reference to the old source docs in that RFC, but the RFC would re-define them in some way. This wil result in UUID being fully RFC-defined, which also has some advantages. That is the reason I think we cannot \"avoid\" writing one.\r\n\r\n> Also, as for complication, I am not opposed to \"one big subtype table\" I was just trying to bundle subtypes and special UUIDs within their own variant sections to make the variant+subtype really shine.\r\n\r\nHmmm, okay. \ud83e\udd14\r\n\r\n> Edit:\r\nThe section groupings also let us enforce different update methods for each so we can get a bit more granular if need be.\r\nI am open for whatever, I was just thinking about Ben's statement \"we should think this out very well. I don't want a shitty table which I regret making\" in this case maybe I thought on it too much...\r\nEdit2: Updated the format a bit, removed some items to get to the main structure of the data vs the items in the table.\r\n\r\nWell, at least you are thinking about it. \ud83d\ude01",
          "createdAt": "2023-09-09T08:17:05Z",
          "updatedAt": "2023-09-09T08:17:05Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "So, if I understand correctly, https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/144#issuecomment-1711760839 has \"registries containing registries\" and \"registries containing records\"? For 4 or 5 levels???\r\n\r\nAs far as I have seen when I looked at the IANA files (also backuped here: https://github.com/larseggert/iana-assignments), I saw only 3 levels: `Registry -> Subregistry -> Record`.\r\n\r\nIn case of the general DNS Parameters (https://www.iana.org/assignments/dns-parameters/dns-parameters.xhtml), there is a registry with multiple subregistries with multiple records.\r\n\r\nIn case of EPP Parameters (https://www.iana.org/assignments/epp-repository-ids/epp-repository-ids.xhtml), there is a registry with a single subregistry with multiple records. However, EPP has multiple top-registries:\r\n![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/12856904/5d3d1e37-8c32-436d-a089-1dbafe963e3c)\r\n\r\nIn your example, I see 4 or 5 levels. I don't even know if IANA even accepts that.\r\n\r\nThis what I have in mind:\r\n\r\n- \ud83d\udcc1 UUID Parameters (top-registry)\r\n  - \ud83d\udcc1 UUID Variants (sub-registry)\r\n    - \ud83d\udcc4 Apollo NCS\r\n    - \ud83d\udcc4 Microsoft DCOM\r\n    - \ud83d\udcc4 OSF DCE\r\n  - \ud83d\udcc1 UUID Subtypes (sub-registry)\r\n    - \ud83d\udcc4 ...\r\n  - \ud83d\udcc1 UUID Special forms (sub-registry)\r\n    - \ud83d\udcc4 ...\r\n  - \ud83d\udcc1 UUID Namespace IDs (sub-registry) [used in UUIDv3 and UUIDv5]\r\n    - \ud83d\udcc4 DNS\r\n    - \ud83d\udcc4 URL\r\n    - \ud83d\udcc4 ISO OID\r\n    - \ud83d\udcc4 X.500\r\n  - \ud83d\udcc1 UUID Hashspace IDs (sub-registry) [used in UUIDv8]\r\n    - \ud83d\udcc4 ...\r\n\r\nHere, \ud83d\udcc1 are registries and \ud83d\udcc4 are records. I only used 3 levels. @kyzer-davis, maybe if you can make something similar with these emoji's, I can understand what your idea is. At the moment I think you have a 4 or 5 level hierarchical tree and I think IANA only supports 3.",
          "createdAt": "2023-09-09T08:56:02Z",
          "updatedAt": "2023-09-09T08:56:02Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I have to say that I don't see the use of hashspaces if they are only used in UUIDv8. UUIDv8 is custom and vendor specific, so it seems to me that defining hashspaces is also up to the vendor.",
          "createdAt": "2023-09-09T09:07:41Z",
          "updatedAt": "2023-09-09T09:07:41Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "According to some code that seems to be Apollo NCS code, the following families are used:\r\n| Name | Description | Information |\r\n| - | - | - |\r\n| Unspecified | Also contains the Nill UUID | dec: `0`, hex: `0x0`, `socket_$unspec`, `AF_UNSPEC` |\r\n| IP | Internet Protocol | dec: `2`, hex: `0x2`, `socket_$internet`, `AF_INET` |\r\n| Apollo DDS | Domain Distributed Services | dec: `13`, hex: `0xD`, `socket_$dds`, `AF_DDS` |\r\n\r\nI have proof for `0` and `13`. I didn't come across a `2`.",
          "createdAt": "2023-09-09T09:54:39Z",
          "updatedAt": "2023-09-09T09:54:39Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "### Unspecified (0):\r\n\r\n```\r\n000000000000.00.00.00.00.00.00.00.00    *\r\n```\r\n\r\n(Source: https://github.com/mit-athena/lpr/blob/master/quota/ncs/nck/uuidname.txt)\r\n\r\n### IP (2):\r\n```\r\n[\r\n\tuuid(48c2314d4009.02.12.48.00.63.00.00.00),\r\n\tversion(1),\r\n\tport(ip:[3702])\r\n]\r\n```\r\n\r\n```\r\n[\r\n\tuuid(49c3f7aa8d7d.02.12.48.00.68.00.00.00),\r\n\tversion(2),\r\n\tport(ip:[3703])\r\n]\r\n```\r\n### DDS (13):\r\n```\r\n[\r\n\tuuid(333b33c30000.0d.00.00.87.84.00.00.00),\r\n\tport( dds:[12] , ip:[135] ),\r\n\tversion(4)\r\n] \r\n```\r\n\r\n```\r\n[uuid(333a22760000.0d.00.00.80.9c.00.00.00), version(3)] \r\n```",
          "createdAt": "2023-09-09T10:20:00Z",
          "updatedAt": "2023-09-09T10:20:00Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@ben221199 \r\n\r\n> I have proof for `0` and `13`. I didn't come across a `2`.\r\n\r\nAn `AF_INET` UUID can be found here:\r\nhttps://www.ibm.com/docs/en/aix/7.1?topic=u-uuid-gen-command-ncs\r\n\r\n```\r\n%pascal\r\n[\r\nuuid (458487b55160.02.c0.64.02.03.00.00.00),\r\nversion (1)\r\n]\r\ninterface INTERFACENAME;\r\n \r\nend;\r\n\r\n```\r\n\r\nHex \"c0.64.02.03\" is Dec \"192.100.2.3\".\r\n\r\n\r\n",
          "createdAt": "2023-09-09T14:17:28Z",
          "updatedAt": "2023-09-09T14:24:36Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I have to say that I don't see the use of hashspaces if they are only used in UUIDv8. UUIDv8 is custom and vendor specific, so it seems to me that defining hashspaces is also up to the vendor.\r\n\r\nI guess it is too late to make big changes, but I think it would have been better if there would be the following ( @kyzer-davis or is there a tiny chance?) :\r\n- UUIDv8 - 100% custom UUID. 100% vendor specific.\r\n- UUIDv9 - Hash based UUID (using hash spaces), as alternative to UUIDv3 and UUIDv5\r\n",
          "createdAt": "2023-09-09T14:20:17Z",
          "updatedAt": "2023-09-09T14:24:16Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/144#issuecomment-1712522204 Yes, I also found a AF_INET version.",
          "createdAt": "2023-09-09T18:16:16Z",
          "updatedAt": "2023-09-09T18:16:16Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is way over the top.  \r\nAll we need is one registry for well known namespace UUIDs.",
          "createdAt": "2023-09-09T19:56:56Z",
          "updatedAt": "2023-09-09T19:56:56Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Checking the \"Registries and sub-registries\" I see that the CSS can go as far as 6 levels deep. \r\nMy original example was actually only 3 but it can be scaled it back to 2. (Edit: revised my original comment with visual vs txt)\r\n- https://www.iana.org/assignments/smi-numbers/smi-numbers.xhtml\r\n- https://www.iana.org/assignments/_support/iana-registry.css\r\n```css\r\ndiv.level2, div.level3, div.level4, div.level5, div.level6 {\r\n    border-left: 1px dotted gray;\r\n}\r\n```\r\n\r\n# Ben's Proposal\r\n![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/867657/cd667ad7-e77d-4191-b706-741c41deb6a1)\r\n\r\n# Minimum required to meet IESG Proposal\r\n![image](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/867657/d68defe6-5046-4a99-88b5-205e0f30ce92)\r\n\r\n--- \r\nI am fine with Ben's proposal of 5 sub-registries. \r\nI am also fine with what was requested by IESG: just namespace/hashspace. (Though I think if we are doing it we might as well get var/ver along with special min/max \"special\" allocations\"\r\n\r\nBut I do agree with @mcr, I just wanted to get the page hierarchy down in a nice way so adding things later is easy; with this I would be requesting the IANA page and filling out what we have control over in this doc.\r\n\r\nIf we need add \"Families\" later in the historical RFC it is easy to slot into the sub-registry somewhere or update a table but we don't need to dive deep into those nitty gritty details here.",
          "createdAt": "2023-09-11T14:34:27Z",
          "updatedAt": "2023-09-11T14:45:29Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I'm also fine with the minimal version, if that causes us to get somewhere already. In that case, we only register `UUID Namespace IDs` and `UUID Hashspace IDs` for now. However, the only objection I have for hashspaces is that it is linked to UUIDv8, as I told in https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/144#issuecomment-1712463318. The solution could be one of the following:\r\n - Introduce a UUIDv9 that will take the time-based and name-based formats of UUIDv8 and leave UUIDv8 with only the vendor-specific custom format.\r\n - Remove the time-based and name-based formats from UUIDv8 and specify UUIDv9 in another RFC.\r\n - Leave out UUIDv8 entirely.\r\n\r\nI don't think it will work out well if we use UUIDv8 for 3 different formats.",
          "createdAt": "2023-09-11T18:27:36Z",
          "updatedAt": "2023-09-11T18:27:36Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I just had an idea in re hash space ID registry.\r\n\r\nSince hash space ID and OID are connected, maybe it would be good having a registry for hash algorithms in general, instead?\r\nI had a very hard time finding the OIDs of the most common hash algorithms (the result: see https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143#issuecomment-1709117798 ) so I think it would be super helpful if there would be a registry similar to this:\r\n\r\n- Algorithm name (prefer the NIST naming, but maybe IANA want to introduce a different naming scheme? In any case, the algorithm name becomes more standardized and less ambigous)\r\n- OID(s), optional\r\n- Hash Space ID (optional)\r\n\r\nThere might be cases where the algorithm name is known, but neither an OID nor a custom hash space is known. In this case, the fields could be left empty. Or maybe IANA could automatically generate a random Hash Space ID when adding the algorithm to the registry.\r\n\r\n**Edit: It turns out that this idea is already by kyzer-davis here https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143#issuecomment-1711804042\r\n\r\n---\r\n\r\n### In re UUIDv8 and UUIDv9\r\n\r\n> I'm also fine with the minimal version, if that causes us to get somewhere already. In that case, we only register `UUID Namespace IDs` and `UUID Hashspace IDs` for now. However, the only objection I have for hashspaces is that it is linked to UUIDv8, as I told in [#144 (comment)](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/144#issuecomment-1712463318). The solution could be one of the following:\r\n> \r\n> * Introduce a UUIDv9 that will take the time-based and name-based formats of UUIDv8 and leave UUIDv8 with only the vendor-specific custom format.\r\n> * Remove the time-based and name-based formats from UUIDv8 and specify UUIDv9 in another RFC.\r\n> * Leave out UUIDv8 entirely.\r\n> \r\n> I don't think it will work out well if we use UUIDv8 for 3 different formats.\r\n\r\nI don't think UUIDv9 should be in a new RFC, and UUIDv8 should stay, because I think it is a very good idea and important. It would mean that we have to do all the formal stuff again and it would be a lot of work. I don't think that it would be catastrophic if UUIDv8 has two use-cases (custom time-based and fully custom).\r\nI have a proposal for UUIDv9, which I have put in a new issue (#147), so that this issue can continue focussing on the IANA registration part.\r\n\r\n\r\n\r\n",
          "createdAt": "2023-09-13T15:20:33Z",
          "updatedAt": "2023-09-14T12:12:03Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://mailarchive.ietf.org/arch/msg/uuidrev/dhxgO66xkpNBrOtSy0AY8nV9bAE/ @sergeyprokhorenko @danielmarschall @ben221199 @LiosK @chorman0773  If this matters, then please participate.",
          "createdAt": "2023-09-18T18:24:49Z",
          "updatedAt": "2023-09-18T18:24:49Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@danielmarschall,    Please clarify your proposal taking into account the discussion that took place.\r\n\r\nIt would be terrible if we had to re-do the entire approval process of this long-awaited RFC because of frankly completely useless details regarding almost unused hash UUIDs.\r\n\r\n@mcr,    I completely agree with @LiosK's point of view and give him my vote",
          "createdAt": "2023-09-18T19:26:53Z",
          "updatedAt": "2023-09-18T19:26:53Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "I suggest to freeze the draft RFC and stop making any changes to it because it's too late and improvements could go on forever. There was a lot of time to make the discussed amendments in the previous stages of RFC development. Stakeholders will be able to propose changes to an already approved RFC",
          "createdAt": "2023-09-18T19:59:29Z",
          "updatedAt": "2023-09-18T19:59:29Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "For what it's worth, unless there is some specific and real-world problem these hashed UUID solve (not just \"what if maybe in the future\" stuff), _I say skip it and move on_.  If nobody has a use case, after all the time and effort that's been put into the drafts, doesn't seem worth fussing over. \r\n\r\nAnd from a logical perspective, just to mention it as part of this: One of the reasons I tend to not put too much stock in the argument that MD5 and SHA-1 are out of date and so we should have a way to replace them - is that one of the factors that makes SHA-256 and others strong hashes is because they are longer (whereas UUIDs are fixed at 128 bits).  Obviously there's more to it than that, but taking a SHA-256 value and truncating it to some smaller size and saying that it's an improvement or more collision resistant or anything because it's based on SHA-256 and not SHA-1... seems like at the very least not thoroughly researched, and at worst just flat out incorrect.  Does anyone actually know the math on collisions for just the first N bits of a SHA-256 hash?  Is it actually worse in terms of collision resistance than MD5 or the current SHA-1 implementation? - based on the math? (Not just the \"well everyone knows MD5 is broken\" - like exactly how many collisions are we talking about...)\r\n\r\nAnd that conundrum is another reason I (and I think a lot of other people on this thread would agree) just go back to: **Is there any practical these hash UUIDs would solve?  (What specifically, with some examples showing how the work done so far on this RFC doesn't cover it...)  If so, great, let's discuss _that_ specifically in more detail.  If there's no good answer to that question, then I don't see any reason we can't ignore it, and I vote let's move on and get this RFC approved.**",
          "createdAt": "2023-09-18T21:37:43Z",
          "updatedAt": "2023-09-18T21:37:58Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I have drafted text around this under https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/162",
          "createdAt": "2023-10-02T20:08:45Z",
          "updatedAt": "2023-10-02T20:08:45Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I reviewed #162.",
          "createdAt": "2023-10-02T22:15:01Z",
          "updatedAt": "2023-10-02T22:15:01Z"
        }
      ]
    },
    {
      "number": 145,
      "id": "I_kwDOH6Ln3M5wb7Ra",
      "title": "OPSDIR Review",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/145",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\n----------------------------------------------------------------------\r\nCOMMENT:\r\n----------------------------------------------------------------------\r\n\r\nMinor level comments:\r\n\r\n(2) p 14, sec 4.2.  Version Field\r\n\r\n      Table 2: UUID variant 10x versions defined by this specification\r\n   An example version/variant layout for UUIDv4 follows the table where\r\n   M represents the version placement for the hexadecimal representation\r\n   of 0x4 (0b0100) and the N represents the variant placement for one of\r\n   the four possible hexadecimal representation of variant 10x: 0x8\r\n   (0b1000), 0x9 (0b1001), 0xA (0b1010), 0xB (0b1011)\r\n\r\nTable 1 only defines 3 bits and doesn't obviously mention a 4th bit, and yet\r\nthe examples below are displaying 4 bits, where I assume that the 4th bit is\r\neffectively arbitrary data in the UUID definition.  Please consider whether it\r\nwould be helpful to clarify this.\r\n\r\n(3) p 16, sec 5.3.  UUID Version 3\r\n\r\n   UUIDv3 values are created by computing an MD5 [RFC1321] hash over a\r\n   given name space value concatenated with the desired name value after\r\n   both have been converted to a canonical sequence of octets in network\r\n   byte order.  This MD5 value is then used to populate all 128 bits of\r\n   the UUID layout.  The UUID version and variant then replace the\r\n   respective bits as defined by Section 4.2 and Section 4.1.\r\n\r\nPresumably the MD5 is only actually used to populate 122 bits, since the other\r\n6 are already spoken for with 'ver' and 'var'.\r\n\r\n(4) p 29, sec 6.2.  Monotonicity and Counters\r\n\r\n      For example, let's assume a system timestamp of 1 Jan 2023\r\n      12:34:56.1234567.  Taking the precision greater than 1ms gives us\r\n      a value of 0.4567, as a fraction of a millisecond.  If we wish to\r\n      encode this as 12 bits, we can take the count of possible values\r\n      that fit in those bits (4096, or 2 to the 12th power) and multiply\r\n      it by our millisecond fraction value of 0.4567 and truncate the\r\n      result to an integer, which gives an integer value of 1870.\r\n      Expressed as hexadecimal it is 0x74E, or the binary bits\r\n      0b011101001110.  One can then use those 12 bits as the most\r\n      significant (left-most) portion of the random section of the UUID\r\n      (e.g., the rand_a field in UUIDv7).  This works for any desired\r\n      bit length that fits into a UUID, and applications can decide the\r\n      appropriate length based on available clock precision, but for\r\n      UUIDv7, it is limited to 12 bits at maximum to reserve sufficient\r\n      space for random bits.\r\n\r\nWould a valid alternative way of achieving this be to just directly write the\r\n10 bits of the timestamp, giving 2 extra bits of randomness and a slightly\r\ncheaper calculation?\r\n```",
      "createdAt": "2023-09-07T18:12:48Z",
      "updatedAt": "2023-09-27T20:21:51Z",
      "closedAt": "2023-09-27T20:21:51Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "On the 122 vs 128, in example of appendix C2 (and review of existing v3/v5 implementations) one simply modify the bits in the right position via some bit operations. \r\nSo 128 are generated and 6 bits are modified to the correct value vs creating 122 then shifting them apart to insert the 6 new bits.\r\nThe first method is how current implementations are operating on RFC4122 verbiage/guidance so we have to carry that into this draft or it will break many implementations.\r\n\r\nEdit: I may add some text pointing to C.2 to state there is an example of how this bit modification is done so folks can see this. \r\nRepeat for v5 section to C.4 to show bit modification (and discard)",
          "createdAt": "2023-09-07T18:20:18Z",
          "updatedAt": "2023-09-07T19:01:26Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Would a valid alternative way of achieving this be to just directly write the 10 bits of the timestamp, giving 2 extra bits of randomness and a slightly cheaper calculation?\r\n\r\n\"just directly write the 10 bits of the timestamp\" does not really make sense here unfortunately because the timestamp here is a sub-millisecond fraction. There is no canonical or natural way (as far as I know) to take the most significant 10 bits (or whatever bits) of a fractional number unless we dig deep into IEEE 754 floating-point numbers. Computationally, the example calculation is equivalent to the following integer arithmetics and is not so expensive as one might think from the example code that relies on floating-point math.\r\n\r\n```python\r\n# take submillisecond fraction from nanosecond timestamp\r\n(456_700 << 12) // 1_000_000\r\n```",
          "createdAt": "2023-09-08T00:29:05Z",
          "updatedAt": "2023-09-08T00:31:22Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "> Would a valid alternative way of achieving this be to just directly write the\r\n10 bits of the timestamp, giving 2 extra bits of randomness and a slightly\r\ncheaper calculation?\r\n\r\nThe 2 extra bits can be populated with bits from a higher precision timestamp. If the system timestamp has a precision of 9 decimal digits, say \"0.123456789\", instead of the 7 digits of Windows, we can do this:\r\n\r\n```python\r\n>>> nanos = int(0.123456789 * 1_000_000_000)\r\n>>> msecs = int(nanos / 1_000_000)\r\n>>> rand1 = int(nanos % 1_000_000 / 100)\r\n>>> \r\n>>> print( nanos )\r\n123456789\r\n>>> print( msecs )\r\n123\r\n>>> print( rand1 )\r\n4567\r\n```\r\n\r\nor this by avoiding divisions:\r\n\r\n```python\r\n>>> nanos = int(0.123456789 * 1_000_000_000)\r\n>>> msecs = nanos >> 20 \r\n>>> rand1 = nanos >> 8 & 0xfff\r\n>>> \r\n>>> print( hex( nanos ) )\r\n0x75bcd15\r\n>>> print( hex( msecs ) )\r\n0x75\r\n>>> print( hex( rand1 ) )\r\n0xbcd\r\n```\r\n\r\nThe first example is more intuitive, so it is preferred in my opinion. The second one is more accurate as it produces a 60-bit timestamp with 100-nanosecond precision and no loss due to IEEE 754 arithmetics.\r\n\r\nP.S.: However, I'm not sure anymore whether prescription of a formula or algorithm for shifting the bits should be included in the document. Perhaps it is beyond the scope of the document as it's hard to put this into words.\r\n",
          "createdAt": "2023-09-08T03:38:33Z",
          "updatedAt": "2023-09-08T04:19:08Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think we should include the `(456_700 << 12) / 1_000_000` technique in the document because it's just an implementation detail! In low-level languages, it is very natural to get a nanosecond timestamp from `clock_gettime()` and perhaps many implementers reaches the same technique. Plus, the `/ 1_000_000` is expected to be eliminated by compilers through division-by-constant optimization, so in reality, the current example algorithm does not need to involve floating-point math or integer division.",
          "createdAt": "2023-09-08T04:04:47Z",
          "updatedAt": "2023-09-08T04:04:47Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Pushed https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/8b2e967ed543d235d285ab34058894af7f24d9f9\r\nOnly changed the item calling out the bit swapping operation (and discard for v5).\r\nEdit2: I split the variant item into #153 ",
          "createdAt": "2023-09-20T18:47:29Z",
          "updatedAt": "2023-09-20T21:14:26Z"
        }
      ]
    },
    {
      "number": 146,
      "id": "I_kwDOH6Ln3M5wb92t",
      "title": "IESG Grammar",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/146",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\n### S6.2\r\n\r\n* \"which is sorts\" -> \"which is sorted\"?\r\n\r\n### S6.10\r\n\r\n* \"UUIDs formats\" -> \"UUID formats\"\r\n ```",
      "createdAt": "2023-09-07T18:21:19Z",
      "updatedAt": "2023-09-27T20:21:52Z",
      "closedAt": "2023-09-27T20:21:52Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "First item caught by tracker item 140. Second was fixed in this https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/4cab17d4f20c7ba28b4cad026de76595b0541de5",
          "createdAt": "2023-09-20T19:32:56Z",
          "updatedAt": "2023-09-20T19:32:56Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "I_kwDOH6Ln3M5w77zb",
      "title": "Simplify UUIDv8 Hash-based Example",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147",
      "state": "CLOSED",
      "author": "danielmarschall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "(Continuation of a discussion in #144)\r\n\r\nI want to propose that part of UUIDv8 gets split in a new format UUIDv9. I hope there is a slight chance that it is still possible at this stage.\r\n\r\nCurrent situation: UUIDv8 has three functions:\r\n1. Fully custom UUID (defined by vendor)\r\n2. Custom time-based\r\n3. New name-based\r\n\r\nProposal:\r\n1. Fully custom UUID stays UUIDv8\r\n2. Custom time-based stays UUIDv8\r\n3. New name-based UUID becomes UUIDv9\r\n\r\n\r\n**_Why do I handle custom time-based and custom name-based differently?_**\r\n\r\nWith Section C.8 (name-based example) and Appendix B (hash spaces, #143), we have a pretty clear definition of how such a name-based UUID is calculated.  We know the OIDs of a lot of algorithms and have a mechanism for how to convert the OID in hash space ID (#143). Even if we don't know the hash space ID, then IANA will probably have it in their registry (#144). The calculation of the UUID is defined very well, and therefore, if the hash space ID is unambiguous, then the UUID is unambiguous.\r\n\r\nIn opposite to custom time-based (which is very custom, because the vendor can define the length of time-part, clock sequence, random part, etc.), the new name-based version does not allow changing any contents/fields.\r\n\r\nSo, I do not think that these new name-based UUIDs should be considered '\"custom\". They are not \"custom\" in my opinion. Therefore I think they should have their own format, UUIDv9.\r\n\r\nSince custom time-based and fully custom UUID are very custom, I don't think it would be an issue if they both share the same version (UUIDv8). After all, people who create custom UUIDs (either by defining a custom time-format, or a fully custom UUID) know that their custom definition is not standardized and might cause collissions.\r\n\r\n\r\n--- \r\n_By the way (personal opinion): I really dislike the time-based example (in section C.7), because the nanoseconds-resolution is rather extreme, causing a wrap-around of the time very quickly. I would have lowered the resolution to make the wrap-around take ~100 years. But on the other hand, the text \"It should be noted that this example is just to illustrate one scenario for UUIDv8.\" is clear that this is not a fixed definition._\r\n",
      "createdAt": "2023-09-13T15:18:24Z",
      "updatedAt": "2023-10-05T13:34:52Z",
      "closedAt": "2023-10-05T13:34:51Z",
      "comments": [
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "Maybe off-topic, but...\r\n\r\nIt is too late to replace the compound adjective \u201cname-based\u201d with \u201chash-based\u201d in v3, v5 (and v9); or at least treat them as interchangeable terms in the document? I see both when I inspect some implementations.\r\n",
          "createdAt": "2023-09-13T15:29:12Z",
          "updatedAt": "2023-09-13T15:30:20Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hm\u2026 i think I used both terms, but without intention. I think it is okay if UUIDv9 gets named like UUIDv3 and UUIDv5 (i.e. name-based)",
          "createdAt": "2023-09-13T15:52:56Z",
          "updatedAt": "2023-09-13T15:52:56Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "I still have no opinion on the creation of UUIDv9. But we should be careful with expressions like \"fully custom UUIDv8\" and \"time-based UUIDv8\" as if they were side by side in the hierarchy. \r\n\r\nThere should be only one UUIDv8, which is \"Fully Custom UUID\" (if I'm correct). The time-based example is just one instance of a possible implementation of UUIDv8.\r\n\r\nI think the confusion remains because UUIDv8 was originally a time-based UUID with custom timestamp precision. There is a lot of outdated webpages that still say that UUIDv8 is, in essence, a time-based version. \r\n\r\nHowever, all UUIDv8 requirements have been eliminated except the variant and version bits, making it fully custom/free form/proprietary format.\r\n\r\nPlease, see the original discussion about UUIDv8: https://github.com/uuid6/uuid6-ietf-draft/issues/31.\r\n",
          "createdAt": "2023-09-13T15:57:19Z",
          "updatedAt": "2023-09-13T16:41:02Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Uhm. It's really about six months too late for this suggestion.\r\n",
          "createdAt": "2023-09-13T17:39:14Z",
          "updatedAt": "2023-09-13T17:39:14Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> It is too late to replace the compound adjective \u201cname-based\u201d with \u201chash-based\u201d in v3, v5 (and v9); or at least treat them as interchangeable terms in the document? I see both when I inspect some implementations.\r\n\r\nThat is probably a tolerable change at this point.\r\n",
          "createdAt": "2023-09-13T17:41:16Z",
          "updatedAt": "2023-09-13T17:41:16Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Uhm. It's really about six months too late for this suggestion.\r\n\r\nActually, I do feel terrible for making a proposal at this point. But maybe there is a slight chance that it is possible. I really wish I had known about the UUID-Rev group 6+ months ago, then I would have contributed much more :-)\r\n\r\nIn theory (if the proposal is accepted in substantially), the editing steps are rather small:\r\n- Rename section 5.9 (Nil UID) and 5.10 (Max UID) to 5.10 and 5.11.\r\n- Move section C.8 (Example of UUIDv8) and rename it to 5.10 \"UUID Version 9\".\r\n- Section 3.2 (Abbreviations): Add UUIDv9\r\n- Section 5.5 (UUIDv5): Recommendation for other hashes change UUIDv8 to UUIDv9.\r\n- Section 6.5 (Best practises): Change Named bed UUIDs using UUIDv8 to UUIDv9\r\n- Appendix B: Change UUIDv8 to UUIDv9.\r\n- Check references still valid after renaming sections? (But I guess the Editor will do it in the finalization?)\r\n\r\nIf my proposal could be formally and substantially accepted, then I would like to help as good as I can by reading the whole draft from top to bottom to verify all references.",
          "createdAt": "2023-09-13T18:53:55Z",
          "updatedAt": "2023-09-13T18:57:02Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "> Custom time-based stays UUIDv8\r\n\r\nI don't agree on this one yet.",
          "createdAt": "2023-09-13T22:05:07Z",
          "updatedAt": "2023-09-13T22:05:07Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In theory (if the proposal is accepted in substantially), the editing steps are rather small:\r\n\r\nThen, get all the formal reviews that have occurred to redo their work.  That's what we've been doing for the past six months.\r\nYour list is too detailed and half of it would be mechanical.\r\nAs I understand it, the substantive part would seem to be that we would making Appendix C.8 into UUID Version 9.\r\nThat would make the text normative rather than informative, and would chew up another vX number, of which we have only 8 left.\r\n\r\nI am still not in anyway convinced I understand why this matters.\r\nPlease take this to the list.\r\n\r\n",
          "createdAt": "2023-09-14T01:45:18Z",
          "updatedAt": "2023-09-14T01:45:18Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "If UUIDv8 is FULLY custom, we shouldn't give implementation examples in my opinion. So, I think that the time-based version has to go.\r\nAlso, adding a `UUID Hashspace IDs` registry only makes sense when there is a version using them, but I also don't think UUIDv8 should be that version.",
          "createdAt": "2023-09-14T07:31:29Z",
          "updatedAt": "2023-09-14T07:31:29Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If UUIDv8 is FULLY custom, we shouldn't give implementation examples in my opinion.\r\n\r\nNo, I think examples are always good.\r\n\r\n> Also, adding a `UUID Hashspace IDs` registry only makes sense when there is a version using them, but I also don't think UUIDv8 should be that version.\r\n\r\nI agree with that.\r\n\r\nI have expressed my concerns earlier (#127) that I think it is weird that the only use of the non-example-section \"hash spaces\" is in an example-section - and now, even an IANA registry is planned (#144). Why should IANA register hash spaces, when they are only used in an \"example\" of our draft? So I agree with @ben221199 that there should be UUIDv9 in case we want the hashspace thing to be recognized by IANA. An Exception would be if the idea of hash spaces (i.e. UUID identifying an algorithm that is not already defined by an OID) might be useful in future standards.\r\n\r\n> I am still not in anyway convinced I understand why this matters.\r\n\r\nI think one of the main reasons is the question  \"Why should IANA (or anyone else) care about hash spaces when they are only used in an \"example\" of our draft?\"\r\n\r\nAlso, don't you think that modern hash algorithms aren't important enough to get their own version? It is a strong signal for people to stop using UUIDv3 and UUIDv5.\r\n\r\n> That would make the text normative rather than informative\r\n\r\nI have no idea what you are talking about. UUIDv9 behaves the same as UUIDv3 and UUIDv5, just with different algorithm and a hash space.\r\n\r\n> Please take this to the list.\r\n\r\nI don't understand. Which list are you referring to?\r\n\r\n---\r\n\r\nBut in any case, I want to say that it is very important for me that the custom name-based (i.e. non-MD5/SHA1) stay, especially since both MD5 and SHA1 are insecure. Please do not remove the name-based example or the hash-space appendix. They are an amazing idea, even if they use the wrong UUID version in my opinion :-) \r\n",
          "createdAt": "2023-09-14T08:44:55Z",
          "updatedAt": "2023-09-15T07:28:49Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "> No, I think examples are always good.\r\n\r\nExamples are, but for me it now seems more like a version definition than an example. I think we should be more clear about that. Don't understand the test vectors of UUIDv8 either.\r\n\r\nFor all other parts, I think that @danielmarschall and I are mostly on the same line.",
          "createdAt": "2023-09-14T08:51:37Z",
          "updatedAt": "2023-09-14T08:51:37Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'd point out one thing that seems to be missed in the recent discussion around the new name-based scheme: the uniqueness of hashspace-based UUIDs is absolutely dependent on the hash function used.\r\n\r\nThe current draft allows arbitrary hash functions chosen by implementers, and thus the uniqueness is dependent on the application-specific choice of hash functions. This application-specific nature makes the hashspace approach a very good example of v8.\r\n\r\nIn my opinion, it isn't really useful or meaningful to spare a separate version number without eliminating this application-specific nature, and to achieve that, we have to do at least the following work:\r\n\r\n- Select the appropriate hash functions to be allowed\r\n- Substantiate a reasonable level of uniqueness guarantee between UUIDs created from the selected hash functions\r\n\r\nPerhaps, it's considerably late to complete these.\r\n\r\nIn addition, the above bullet points pose a subtle question relating to #143 and #144: what hash functions should we officially list in the specification? The current hashspace approach accepts whatever hash function (because it's v8), but it doesn't make sense to list and promote _unsafe_ hash functions in the specification. I don't know how IANA works, but if it doesn't have a mechanism to reject nonsensical hash functions from being listed, IANA will not be a good choice. The OID-based hashspace IDs would make noise because it allows any hash function to get an official-ish hashspace ID without selection.",
          "createdAt": "2023-09-17T23:45:48Z",
          "updatedAt": "2023-09-17T23:45:48Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I'd point out one thing that seems to be missed in the recent discussion around the new name-based scheme: the uniqueness of hashspace-based UUIDs is absolutely dependent on the hash function used.\r\n> \r\n> The current draft allows arbitrary hash functions chosen by implementers, and thus the uniqueness is dependent on the application-specific choice of hash functions. This application-specific nature makes the hashspace approach a very good example of v8.\r\n> \r\n\r\nI am not sure if I understood what you mean. Yes, if different hash methods are used, the resulting UUIDv9 is different. However, you need to think about the hash algorithm be an input of the hash function.\r\n\r\n```\r\nUUIDv3(Namespace, Value) := MD5(Namespace || Value)\r\nUUIDv5(Namespace, Value) := SHA1(Namespace || Value)\r\nUUIDv9(Hash, Namespace, Value) := Hash(HashId || Namespace || Value)\r\n```\r\n\r\nAs I mentioned above, if we stay at UUIDv8, then we do not know \"which\" UUIDv8 was chosen. Was it a fully custom, a custom time format, or a custom hash format? We don't know.\r\n\r\nFor UUIDv9, if the hash is unambiguous, then the UUIDv9 is unambiguous.\r\n\r\n> The current hashspace approach accepts whatever hash function (because it's v8), but it doesn't make sense to list and promote _unsafe_ hash functions in the specification. I don't know how IANA works, but if it doesn't have a mechanism to reject nonsensical hash functions from being listed, IANA will not be a good choice. The OID-based hashspace IDs would make noise because it allows any hash function to get an official-ish hashspace ID without selection.\r\n\r\nIf a hash algorithm is \"unsafe\" is dependant of the time. We know a few hash functions which are unsafe today. But we don't know if SHA2 or SHA3 might become unsafe tomorrow, if someone finds a flaw. So safe/unsafe should be out of scope for the RFC. However, the requirement of the hash function should be that it has at least 122 bits output (or it needs to be zero-padded).\r\n\r\nI think the selection of hash algorithms in the current draft is good. It contains the NIST algorithms which are VERY well-known and are currently (2023) safe to use. If other hash algorithms emerge in the future and/or SHA2 and SHA3 become very insecure, then there can be a revision of the RFC with a different Appendix B. But this is not mandatory because the mechanism of hash spaces and/or the IANA registry of hashes allows the developer to simply choose a different algorithm.",
          "createdAt": "2023-09-18T10:15:44Z",
          "updatedAt": "2023-09-18T10:20:24Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> As I mentioned above, if we stay at UUIDv8, then we do not know \"which\" UUIDv8 was chosen. Was it a fully custom, a custom time format, or a custom hash format? We don't know.\r\n\r\nYes, and we don't care at all. This hash UUID was not the intent of this RFC. And now this hash UUID is delaying the approval of everyone's expected UUIDv7. The uniqueness of the hash UUID is questionable not only because of problems with satisfactory hash functions, but also because the hash functions argument is not unique. Worse, the variability of the hash functions argument leads to variability in the hash UUID, but a volatile key is unsuitable for databases and other information systems. And hash UUIDs are also unordered, so they are no better than UUIDv4. We should throw hash UUID into the UUIDv8 category as soon as possible and stop delaying final RFC approval.",
          "createdAt": "2023-09-18T12:36:35Z",
          "updatedAt": "2023-09-18T12:45:18Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Yes, and we don't care at all.\r\n\r\nWho is \"we\"?\r\n\r\n> This hash UUID was not the intent of this RFC.\r\n\r\nAnd why did it end up in the latest draft then?\r\n\r\n> a volatile key is unsuitable for databases and other information systems\r\n\r\nThen you also need to strike UUIDv4.",
          "createdAt": "2023-09-18T13:43:10Z",
          "updatedAt": "2023-09-18T13:43:58Z"
        },
        {
          "author": "chorman0773",
          "authorAssociation": "NONE",
          "body": "> Worse, the variability of the hash functions argument leads to variability in the hash UUID, but a volatile key is unsuitable for databases and other information systems\r\n\r\nThen you don't use them for databases. \r\n\r\nI would like for a standardized mechanism for non-SHA-1 hash UUIDs for sure. I use UUIDs as device identifiers in the operating system I'm working on, and standard device names get fixed IDs assigned by using namespace UUIDS. Using something other than SHA-1 or md5 would be nice.",
          "createdAt": "2023-09-18T13:58:59Z",
          "updatedAt": "2023-09-18T13:58:59Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@danielmarschall\r\n\r\nThe current hashspace method accepts an arbitrary hash function, so I can define one as follows, give it a hashspace ID, and generate UUIDv8 name-based UUIDs.\r\n\r\n```go\r\nfunc MiracleHash(message []byte) []byte {\r\n    digest := make([]byte, 16, 16) // prepare zero-filled byte sequence\r\n    time.Sleep(42 * time.Second)   // wait for a miracle to compute digest\r\n    return digest\r\n}\r\n```\r\n\r\nThis `MiracleHash` function is obviously nonsense, but it's absolutely fine within the v8 space if it meets the application-specific needs.\r\n\r\nHowever, out of the v8 space, in my opinion, the spec must reject _unsafe_ (in terms of uniqueness) hash functions. UUID isn't an almighty identifier framework but is just a universally unique identifier standard. All the versions provided in the document (except for v8, which is clearly marked as implementation-specific) must provide a reasonable guarantee of universal uniqueness, because that is exactly what general readers of the standard are looking for. This is my personal opinion, but I believe this way of thinking maximizes the utility of the UUID standard.\r\n\r\nThe hashspace approach as in the current draft should be good enough as an informative guidance, but there are several questions we have to answer to make it a normative definition that gives a reasonable uniqueness guarantee. For example:\r\n\r\n- What hash functions should we allow? Do we really need all the SHA-2 and SHA-3 items? We have to pick one not just because it has some users but because it provides uniqueness.\r\n- Is it safe to truncate a digest to 128 bits? FIPS 180-4 explicitly allows truncation while other standards do not.\r\n- Is it safe to mix multiple hash functions in one version space? Do similar SHA functions not correlate with each other? SHA functions are each designed not to produce the same value, but the collision resistance across multiple algorithms shouldn't have been a primary design goal.\r\n- What if a hash function is proven unsafe in the future? How do we remove from a list of name-based UUIDs an unsafe algorithm-based UUID that may collide with other values generated in the future?\r\n\r\nThese questions are kept on hold when the current hashspace approach was first introduced because it was expected to be just an informative example. Thinking twice, we might conclude this approach is not the best option to deal with the above questions. Perhaps, we need to reconsider the other ideas of name-based schemes [we have explored before](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/50). Anyway, developing a normative name-based scheme isn't that easy, and perhaps we have run out of time.\r\n\r\nBtw, I don't really care the delay caused. I am thankful to @danielmarschall for raising this discussion.\r\n",
          "createdAt": "2023-09-18T14:28:05Z",
          "updatedAt": "2023-09-18T14:28:05Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "If you say UUIDv8 is fully custom, is not good to give an example which is the only example where hashspaces are used and then register those hashspaces at IANA. Then the only right to exist of hashspaces are based on an example; and then you are actually not talking about a example anymore, but about a new format.\r\n\r\nUUIDv8 is fully custom. You are able to give implementation examples, but know that giving examples can give the suggestion that it are real formats that need to implemented, which should not be the case. So caution is advised.\r\n\r\nMy advise options for time-based UUIDv8 example:\r\n - Remove it to avoid confusion\r\n - Revise the text to be FULLY clear about it being an example\r\n\r\nMy advise options for name-based UUIDv8 example:\r\n - Remove it to avoid confusion\r\n - Move it to UUIDv9",
          "createdAt": "2023-09-18T14:38:11Z",
          "updatedAt": "2023-09-18T14:38:11Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> > Yes, and we don't care at all.\r\n> \r\n> Who is \"we\"?\r\n> \r\n> > This hash UUID was not the intent of this RFC.\r\n> \r\n> And why did it end up in the latest draft then?\r\n> \r\n> > a volatile key is unsuitable for databases and other information systems\r\n> \r\n> Then you also need to strike UUIDv4.\r\n\r\n@danielmarschall\r\n\r\nThe goals of this RFC are well stated in [2.1. Update Motivation](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-11.html#name-update-motivation)\r\nEssentially the main goal is to replace UUIDv1 and UUIDv4 with UUIDv7 as a key in databases. All other goals are secondary",
          "createdAt": "2023-09-18T14:39:33Z",
          "updatedAt": "2023-09-18T14:39:33Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "> The goals of this RFC are well stated in [2.1. Update Motivation](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-11.html#name-update-motivation)\r\nEssentially the main goal is to replace UUIDv1 and UUIDv4 with UUIDv7 as a key in databases. All other goals are secondary\r\n\r\nI'm fine with UUIDv6 and UUIDv7 as far as I know. So if we fix or drop UUIDv8, the RFC could be published in my opinion. However, I think many also want UUIDv8 in the same RFC, but not with the chaotic definition it has now.",
          "createdAt": "2023-09-18T14:44:25Z",
          "updatedAt": "2023-09-18T14:44:25Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@LiosK   In re your `MiracleHash`: I didn't read the definition of \"Hash\", but I think one very strong requirement is that it is deterministic?",
          "createdAt": "2023-09-18T14:52:23Z",
          "updatedAt": "2023-09-18T14:52:23Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@ben221199\r\n\r\nI agree that the UUIDv8 examples should be removed completely as they can be taken as a guide to action.\r\nI don't mind UUIDv6 and the fixed UUIDv8 without examples",
          "createdAt": "2023-09-18T14:59:17Z",
          "updatedAt": "2023-09-18T14:59:17Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Removing UUIDv8 examples (without introducing UUIDv9) would mean that we strike the complete SHA2/SHA3 functionality and we are left with MD5 and SHA1. That would be horrible.",
          "createdAt": "2023-09-18T15:17:59Z",
          "updatedAt": "2023-09-18T15:17:59Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@danielmarschall\r\n\r\n> Removing UUIDv8 examples (without introducing UUIDv9) would mean that we strike the complete SHA2/SHA3 functionality and we are left with MD5 and SHA1. That would be horrible.\r\n\r\nYou can simply list depricated technologies and accepted technologies for UUIDv8 without examples. You can also specify a list of UUIDv8 categories (time-based, hash-based and so on)",
          "createdAt": "2023-09-18T15:31:41Z",
          "updatedAt": "2023-09-18T15:32:54Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://mailarchive.ietf.org/arch/msg/uuidrev/dhxgO66xkpNBrOtSy0AY8nV9bAE/ @sergeyprokhorenko @danielmarschall @ben221199 @LiosK @chorman0773  If this matters, then please participate.",
          "createdAt": "2023-09-18T18:23:38Z",
          "updatedAt": "2023-09-18T18:23:38Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@danielmarschall,    Please clarify your proposal taking into account the discussion that took place.\r\n\r\nIt would be terrible if we had to re-do the entire approval process of this long-awaited RFC because of frankly completely useless details regarding almost unused hash UUIDs.\r\n\r\n@mcr,    I completely agree with @LiosK's point of view and give him my vote",
          "createdAt": "2023-09-18T19:21:21Z",
          "updatedAt": "2023-09-18T19:21:21Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> @danielmarschall, Please clarify your proposal taking into account the discussion that took place.\r\n\r\nOkay. I will carefully read through the discussion and adjust the initial post of this GitHub issue. Maybe also re-phrasing some parts for better understanding.\r\n\r\n> It would be terrible if we had to re-do the entire approval process of this long-awaited RFC ......\r\n\r\nIs it true that the approval process needs to be done again, or is this change something that just needs a Re-review of the ADs (i.e. they only re-review the changes, not everything?)\r\n\r\n> ....... because of frankly completely useless details regarding almost unused hash UUIDs.\r\n\r\nIt depends on the use-cases. I understand that UUIDv7 is very important for databases because of their order. But that doesn't mean that the other UUID versions are useless for everyone. I have worked on a lot of projects where hash based UUIDv3 and UUIDv5 were required. Having SHA2/3 or Any-Hash would be an important improvement for the UUIDv3 and UUIDv5 use-cases.",
          "createdAt": "2023-09-18T19:45:40Z",
          "updatedAt": "2023-09-18T19:45:40Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "I suggest to freeze the draft RFC and stop making any changes to it because it's too late and improvements could go on forever. There was a lot of time to make the discussed amendments in the previous stages of RFC development. Stakeholders will be able to propose changes to an already approved RFC",
          "createdAt": "2023-09-18T19:58:40Z",
          "updatedAt": "2023-09-18T19:58:40Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall I tend to agree with the others here about UUIDv8 seeming sufficient and not needing UUIDv9.\r\n\r\nUUIDv6, 7, 8 and each have very specific purposes and problems they solve. v6 is a low-effort way to adapt v1 to be time ordered when treated opaquely (good for easily adapting existing systems).  v7 is time ordered plus random data removes some unnecessary restrictions (best choice for new time-ordered values). And v8 is a catchall so you are not forced to use one of these others if it doesn't suit you.\r\n\r\nThat said, **is there is a specific clear use case - like something you actually are trying to get done right now or in the foreseeable future which needs the distinctions you're describing for UUIV9?** If so please describe what that use case is.",
          "createdAt": "2023-09-18T21:17:58Z",
          "updatedAt": "2023-09-18T21:21:52Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That said, **is there is a specific clear use case - like something you actually are trying to get done right now or in the foreseeable future which needs the distinctions you're describing for UUIV9?** If so please describe what that use case is.\r\n\r\n@bradleypeabody  The discussion here at GitHub has already become very busy. I do not want to discuss various use cases and whether they are good or bad, this would be very off-topic and the discussion would never end. Personally I have used name-based UUIDs very often and I think they are useful. However, I can understand that some people never used them at all.\r\n\r\n\r\nI have revised my proposal, added more arguments, and added explanations/context in case some readers (or the October meeting members) are not familiar with these GitHub discussions. Feel free to skip to the \"Reasons\" section.\r\nhttps://1drv.ms/w/s!Aq8PcXiGvLchiJozKQxKX-C5RSlH8g?e=YBePzy\r\n\r\n\r\nAdditional information (and maybe a trade-off?):\r\n\r\n- Like I explained in my proposal, one of the things that bothers me the most is that the \"name-based UUIDv8\" are just an example. Examples are no programming requirements, so everybody could implement SHA2 UUIDs differently.\r\nIf UUIDv9 will not be accepted, then I would be at least happy if the name-based UUIDs become ANYTHING other than an example. Maybe make a distinction between \"Name-Based UUIDv8\" and \"Custom UUIDv8\", or something like that. SHA2 and SHA3 are too important to be just an example.\r\n\r\n- And I recommend to strike or change that time-based example (section C.7). An UUID which wraps its time after 78 hours is a very bad example.",
          "createdAt": "2023-09-18T22:28:18Z",
          "updatedAt": "2023-09-18T22:57:46Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall Thanks for that information, the link definitely helps explain things more.  I do think it's extremely important to discuss specific examples of intended uses, and if you're going to propose changes this is a suitable place to discuss. Waiting until the meeting to hash these things out (pun not intended) will not improve the situation.\r\n\r\nJust to recap my understanding of that doc, you're basically saying:\r\n\r\n* **Hash based UUIDs are useful because they are deterministic** (whereas all of the time-based UUIDs are of course not deterministic).  Specifically, and just to be 100% clear - \"deterministic\" means here that there is some sort of name being fed into a UUID generation function and given the exact same name it will produce the exact same UUID value.\r\n* **UUIDv3 and UUIDv5 are deterministic but insecure, because they use insecure hash algorithms.**\r\n* **Therefore we should replace them** in the new spec with a more secure hash algorithm while updating this document.\r\n\r\nCorrect?\r\n\r\nIf that's the case, I have the following questions/points:\r\n\r\n* Please provide some examples of how these are used - **like specifically what is a case where you've used name-based UUIDs?**  (I'm not challenging that there are some useful cases, I'm sure there are, but please say what exactly you're trying to do and why you need that deterministic property.)\r\n* **What does \"insecure\" mean in this context?**  MD5 is considered \"insecure\" because the effort required to find a collision is too low for various security purposes.  More specifically and by way of example, if you hash a document with MD5 (e.g. maybe an ISO file with a CD image on it), and then an bad actor wants to substitute another document (a bad ISO file infected with a virus) that results in the same hash, this is potentially possible to do with a reasonable amount of effort.  However, in the case of UUIDs, we only have a maximum of 128 bits total, minus version and variant (7 bits).  So if the entire premise of your proposal is that someone cannot use UUIDv3 or UUIDv5 because they are insecure, please give a specific example of a security problem created by using these UUID values.  Does your name-based example from the bullet above include a necessity to be resistant against a bad actor attempting to use a different name to hash to the same UUID? If so, I would like to A) know about that specific example, and B) understand how UUIDv9 would address that problem, considering the fact that the output of e.g. a SHA-256 hash would need to be truncated, thus greatly increasing the probability of collision (and thus making it \"less secure\").",
          "createdAt": "2023-09-18T22:58:10Z",
          "updatedAt": "2023-09-18T23:41:36Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Is it true that the approval process needs to be done again, or is this change something that just needs a Re-review of the ADs (i.e. they only re-review the changes, not everything?)\r\n\r\nIt doesn't really matter.  You have to get into their Q, and it matters little if it takes them 2 minutes or 10 minutes. What matters if the latency to get to the front of the queue.\r\n",
          "createdAt": "2023-09-18T23:04:31Z",
          "updatedAt": "2023-09-18T23:04:31Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@bradleypeabody\r\n\r\nI can guess that hash UUIDs are used so that legacy IDs (not originally UUIDs) can be written to the same database table field as new IDs, such as UUIDv7. For example, PostgreSQL has a UUID data type. The UUID of any version can be written to a field with this UUID data type and it will work correctly, although there will be performance issues. Correct me if my assumption is wrong.\r\n\r\nI think that @danielmarschall\u2019s concerns could be addressed with a couple of phrases about acceptable hashing algorithms in the description of UUIDv8 (along with mention of time-based UUIDv8), deprecation of UUIDv3 and UUIDv5 and the exclusion of any intrusive examples of UUIDv8.",
          "createdAt": "2023-09-18T23:25:15Z",
          "updatedAt": "2023-09-18T23:41:14Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "> I think that @danielmarschall\u2019s concerns could be addressed with a couple of phrases about acceptable hashing algorithms in the description of UUIDv8 (along with mention of time-based UUIDv8), deprecation of UUIDv3 and UUIDv5 and the exclusion of any intrusive examples of UUIDv8.\r\n\r\nI don't know if @danielmarschall meant \"**deprecating**\". I think he meant \"**discouraging**\" the use of UUIDv3 and UUIDv5. However, maybe I'm just nit picking about some words.\r\n\r\n> https://1drv.ms/w/s!Aq8PcXiGvLchiJozKQxKX-C5RSlH8g?e=YBePzy\r\n\r\nI love how good this is document is written. I'm not a native English speaker, but I agree about more than 90% of the document and it is written better than I am able to do at the moment.",
          "createdAt": "2023-09-19T09:22:03Z",
          "updatedAt": "2023-09-19T09:22:03Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bradleypeabody \r\nOk, I can give you an example where I used name-based UUIDs. I don't claim that my use case is a good example; some people might agree, and some people might disagree. But maybe it helps to understand why I am using name-based UUIDs for some projects instead of random or time-based UUIDs.\r\n\r\nOne of our projects is a communication interface between an invoicing software solution and an accounting software solution. The data from the invoicing software should be transferred to the accounting software. We don't have permission to write or extend the databases of these third-party solutions.\r\n\r\n- The invoicing software has invoices and each invoice has a lot of item lines. The volume (all items of all invoices of all clients) is approximately 220 million item lines.\r\n\r\n- The accounting software needs a UUID for each item line.\r\n\r\nThere are two solutions:\r\n\r\n**_Solution A_**: Either we generate a UUID (v4, v7, etc.) and create a database lookup table that contains a link between \"Item line\" and the UUID.\r\n\r\n![solution_a](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/28412477/78270e42-ed9d-44c9-be16-755bf957d0ad)\r\n\r\n**_Solution B_**: Or we generate the UUID \"on the fly\" by using a name-based UUID:\r\n\r\n`AccountingUUID := UUIDv3(CustomNamespace, ClientId || MandatorId || InvoiceId || LineId)`\r\n\r\n![solution_b](https://github.com/ietf-wg-uuidrev/rfc4122bis/assets/28412477/8a7eb716-9f14-4528-89b4-b998aa6113db)\r\n\r\nWe have chosen solution B.\r\n\r\n\ud83d\udc4d Pro: It is very easy to implement and we don't need a database.\r\n\r\n\ud83d\udc4e Con: However, if there would be a hash conflict, we would be in big trouble. This is why I am a bit anxious about a hash conflict happening between the 220 million lines. I do know that 220,000,000 is much smaller than 2^122, but still...\r\n\r\n\r\n\r\n\r\n@ben221199\r\nActually, I meant \"deprecate\" since I use that term in development very often. But thinking about it, the term is not correct, because deprecation means that the feature will be removed in future releases. However, since UUIDv3 and UUIDv5 are standardized, they will never be removed. So yes, \"discouraging\" is better. Thanks for that hint.  (By the way, I am also not a native speaker.)",
          "createdAt": "2023-09-19T10:02:31Z",
          "updatedAt": "2023-09-19T10:35:19Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bradleypeabody \r\nSorry, I missed some of your questions.\r\n\r\nIn re the term \"**_deterministic_**\", yes, I meant that the same input results in the same output:\r\n\r\n    UUIDv8_ImplementationA(SHA3_256, \"hello world\") == UUIDv8_ImplementationB(SHA3_256, \"hello world\")\r\n\r\nIn re the term \"**_secure_**\", I meant that collisions are more likely. **_MAYBE_** if an attacker could control the hash-input, they might be able to create a duplicate UUID that might be security-relevant. But that's just a theory, I don't have such a use case. So, I don't say that this is important.\r\n\r\n---\r\n\r\nPS: Another argument, but I think it is a rather unimportant one, MD5 and SHA1 are simply old-fashioned. Some code-analysis tools like Snyk even mark your source code as \"risky\" if the functions MD5 and SHA1 are used. I know that's not accurate because the usage of MD5 and SHA1 is just discouraged if it is used for security-relevant stuff. But your boss might not understand that technical detail and just say you did a bad job if the security software raises an alert about insecure functions used in the source code.",
          "createdAt": "2023-09-19T10:35:35Z",
          "updatedAt": "2023-09-19T11:01:31Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@danielmarschall\r\n\r\nSo far, no hash function, including SHA2 and SHA3, is intended to produce 122 bits for UUID. Arbitrarily cutting off extra bits increases the likelihood of a collision in an unknown way. Therefore, **none of the current hash functions, including SHA2 and SHA3, should be recommended in the new RFC.** Current hash UUIDs definitely fall into the category of custom UUIDv8 for the risk-taking guys. Someone will have to invent a custom hash function specifically for UUIDs.",
          "createdAt": "2023-09-19T13:06:10Z",
          "updatedAt": "2023-09-19T13:06:10Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> In re your `MiracleHash`: I didn't read the definition of \"Hash\", but I think one very strong requirement is that it is deterministic?\r\n\r\nThat's not the point. I mean the current Appendix C.8 doesn't preclude use of a nonsense hash function, and thus C.8 won't be helpful even if it's renamed to v9 without substantial effort to narrow down hash function options and to conduct collision resistance research. IMO, the hashspace approach as currently described in the draft isn't of quality worth a separate version number. It started from [my quick idea](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/50#issuecomment-1419980354) and is not battle-tested or scientifically reviewed. I am aware of potential issues of this approach as well as other alternative approaches that must be taken into consideration before publishing as a normative v9 definition.\r\n\r\n> 2. Remove appendix C.7 (Example of a UUIDv8 Value time-based), or at least use a better example.\r\n\r\nPerhaps, we can tweak this example to make it more sensible, though I don't necessarily believe this example is very bad. It's weird, but it clearly demonstrates an identifier design that will never be achieved by v1 through v7 (e.g., nanosecond precision, wrapping timestamp, non-sortable).\r\n\r\nHowever, I don't agree to remove this example. The draft is clear that v8 is the fully custom version and that time-based and name-based are just examples. If you find these examples confusing, we can also add more examples like:\r\n\r\n- time-based\r\n- name-based\r\n- node ID-based (Section 6.4)\r\n- little endian-based (Section 6.10)\r\n\r\nWith multiple examples, perhaps readers will be sure they are just implementation examples.\r\n\r\n> **_Solution B_**: Or we generate the UUID \"on the fly\" by using a name-based UUID:\r\n\r\nIt's actually the very use case of v8. Before v8, the name-based versions were the only solution to map a set of external identifiers to those within the UUID space. With v8, you can simply embed your ClientId || MandatorId || InvoiceId || LineId in v8's 122-bit payload. v8 is introduced to solve this kind of problems. If the external identifier is larger than 122 bits, then you'll need to truncate, compress and/or scramble it, but SHA is not mandatory.\r\n",
          "createdAt": "2023-09-19T13:21:26Z",
          "updatedAt": "2023-09-19T13:21:26Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> So far, no hash function, including SHA2 and SHA3, is intended to produce 122 bits for UUID. Arbitrarily cutting off extra bits increases the likelihood of a collision in an unknown way. Therefore, none of the current hash functions, including SHA2 and SHA3, should be recommended in the new RFC. Current hash UUIDs definitely fall into the category of custom UUIDv8 for the risk-taking guys. Someone will have to invent a custom hash function specifically for UUIDs.\r\n\r\nI haven't read the NIST recommendations, but I think someone in that discussion mentioned that cutting off bits is OK by NIST. (And SHA512/224 does this).\r\n\r\nYes, the probability of collissions raises. In the example of SHA3-512 from 1/2^512, up to 1/2^122. But it would not become greater than 1/2^122, since the entropy is equal across the 512 bits, AFAIK.\r\n\r\n> With v8, you can simply embed your ClientId || MandatorId || InvoiceId || LineId in v8's 122-bit payload. \r\n\r\nYes, I know. That would be perfect (and this is why I think fully custom UUID are very useful). Unfortunately for my case, the identifiers altogether are longer than 122 bits, so I needed to use a hash.",
          "createdAt": "2023-09-19T13:34:34Z",
          "updatedAt": "2023-09-19T13:42:47Z"
        },
        {
          "author": "chorman0773",
          "authorAssociation": "NONE",
          "body": "Keccack and blake3 as general algorithms could likely be recommended - you\r\ncan generate 128 bits from the sponge construction.\r\n\r\nYou could also use something like SipHash128 if you had a way to derive the 128-bit key.\r\n",
          "createdAt": "2023-09-19T13:40:54Z",
          "updatedAt": "2023-09-19T13:56:36Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I mean the current Appendix C.8 doesn't preclude use of a nonsense hash function\r\n\r\nOk, I can understand the problem. Some people might decide to use UUIDv9 with \"CRC32\" as a hash function. (Extreme case)\r\n\r\nIn that case, the only thing we can do is to recommend \"strong algorithms\" but leave the definition of \"strong algorithms\" out-of-scope of the RFC. Maybe the list of SHA2/SHA3/SHAKE in Appendix B is enough recommendation? In any case, I don't think it is good to recommend any algorithm, because it lets the document \"age\" faster if the recommended algorithms become unsafe. So I think it should be the obligation of the developer to choose an algorithm that is secure at the time they are developing their app.",
          "createdAt": "2023-09-19T13:52:59Z",
          "updatedAt": "2023-09-19T13:52:59Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> the only thing we can do is to recommend \"strong algorithms\" but leave the definition of \"strong algorithms\" out-of-scope of the RFC\r\n\r\nIf there are implementation-specific options, then v8 is sufficient. A standard exists to coordinate implementations. If one is not specific, then it's useless. As for the current hash space approach specifically, the choice of hash function is critical to ensure uniqueness, so once a CRC32-based value sneaks into a primary key column of a database, you can no longer insert another name-based value without a risk of collision. You can't even remove CRC32-based values from the column due to the design of the hash space scheme. You will be able to handle name-based values very well if you carefully control the hash functions used in your application, but that is a sort of care that only v8 may require, in my opinion.\r\n\r\nAt this stage, I am not convinced that a separate version number is necessary for the hash space scheme. There are a plenty of alternatives to explore before standardizing a name-based scheme. Limiting the hash function to SHAKE, as mentioned by @chorman0773, would be an option. If you are concerned about the aging of algorithms, we could introduce a `hash_function` field to distinguish algorithms used. SipHash128 and other algorithms used to implement hash tables would also be interesting because the key problem in the use case mentioned above is the compression of external identifiers to fit into the 122-bit payload.\r\n\r\nI am also concerned about the inactive discussion over name-based UUIDs. It has been seriously inactive for the last couple of years, and accordingly we haven't even been able to identify a clear-cut use case of name-based UUIDs. With the very low level of feedback, we won't be able to evaluate multiple name-based scheme ideas, or won't even be able to identify metrics to evaluate such ideas.\r\n\r\nI would recommend to establish a new RFC project just like [the new textual encoding](https://github.com/uuid6/new-uuid-encoding-techniques-ietf-draft) and [the 111 variant](https://github.com/uuid6/uuid6-ietf-draft/issues/26) to discuss the name-based scheme. We'll need focused time and discussion to develop a right name-based approach. Plus, once the hash space approach is published as a v8 example, we'll be able to observe how implementers deal with the approach and collect feedback to improve the name-based arrangement.\r\n",
          "createdAt": "2023-09-20T00:42:20Z",
          "updatedAt": "2023-09-20T00:42:20Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall Thanks for the information, that data makes sense.\r\n\r\nBased on your use case, it seems like:\r\n\r\n* **UUIDv3 or UUIDv5 would still work perfectly well.**  MD5 and SHA-1 are broken for cryptographic purposes, but in terms of collision resistance for a use case like you describe, it seems perfectly suitable.\r\n* **Since you control all of the code** putting data into the existing storage that needs a UUID, you could also use UUIDv8 without any issues - since you don't have to interoperate with any other system.\r\n\r\nFor these reasons I don't see the necessity of creating a UUIDv9.  If there is a use case where UUID v3, v5 or v8 are all unsuitable, please let me know what that is and why.\r\n\r\nOtherwise, based on this, do you agree that we do not need to address creating a UUIDv9 in this document?  (I'm not sure if you realize that this discussion is blocking literally years of work at this point, right at the finish line. So I'm just trying to narrow this down here and see if we can get some agreement on whether we actually need to keep going on this UUIDv9 idea.)\r\n\r\nP.S.  I understand the concern about MD5 and SHA-1 being \"old-fashioned\", but I think we'd need a stronger argument (and use cases) to invent a new UUID version.  If UUID were not limited to 122 available bits and we could just update the hash function to SHA-512 or similar, I would say sure this makes sense let's do it.  But we have to truncate those to fit into 122 bits and so the value in saying that we're now using a secure hash algorithm just goes way down.  We can't follow only part of the recommendations for how to handle hashes and claim that we've now made the system more secure. ",
          "createdAt": "2023-09-20T01:07:52Z",
          "updatedAt": "2023-09-20T01:09:20Z"
        },
        {
          "author": "chorman0773",
          "authorAssociation": "NONE",
          "body": "So I should note my use case, using UUIDs as well-known device ids, does have issue with collisions - in the OS, device drivers, both those running in user space *and* in kernel space can register their own devices, and as part of that, they can either ask for a UUID (which would be v1 or v7 most likely, or maybe v4) or they can specify one of their own. While malicious collisions don't pose a security risk (attempting to register over an existing device returns an error rather than overwriting the existing device), accidental collisions would cause an error the code may not expect, particularily if it's a kernel-mode driver that's run during startup. I would consider that enough of an issue to avoid using a fully custom v8 for well-known devices, but a standardized extended name-based UUID would be useful IMO. Additionally, there are a few other things in the OS involving dynamic computation of name-based UUIDs that I would like to switch to an algorithm other than md5 or SHA-1, but would not want to use v8 for. For example, legacy unix group and user ids are mapped to principal UUIDs using a hash of a particular OID ending in the group/user id number by default. That could use Keccack or SipHash (SipHash particularily if there's a well-defined way for keyed hash functions, for example using the namespace as the key rather than part of the message, as it's incredibly efficient to compute and I've recently made it faster than llvm's codegen on x86 - overall it's far faster than md5).",
          "createdAt": "2023-09-20T01:39:33Z",
          "updatedAt": "2023-09-20T01:40:41Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Btw SipHash (or whatever non-SHA algorithm) really draws my attention. Security shouldn't usually be the primary property sought for a hash function in the context of name-based UUIDs. SHA series is overkill where security isn't the issue; rather, it's complicating the situation. v5 perfectly works even as of now because it doesn't rely on SHA-1's security, but many people believe v5 is obsolete. If there is a non-cryptographic hash function that fully focuses on collision resistance, a name-based UUID based on it won't become obsolete in the future....\r\n\r\n(This is just an off-topic note. This doesn't change my conclusion in the previous post. I'd recommend to discuss this kind of stuff in a separate repository. Name-based schemes aren't mature or worth another six months for formal review at this stage.)",
          "createdAt": "2023-09-20T03:46:21Z",
          "updatedAt": "2023-09-20T03:46:21Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "Alright, to summarize and suggest a possible solution based on the above info:\r\n\r\nThe problems we're trying to solve:\r\n\r\n* **Determinism** - as above, same input should lead to the same output\r\n* **Interoperability** - it needs to be standardized \"enough\" so that two implementations can point to some place in the document and get the same behavior (note that this does not necessarily require a new UUID version)\r\n* **Collision resistance** - most well-studied hash functions are \"well distributed\", meaning changing a single bit of input results in roughly half of the bits in the output being changed.  I'm pretty sure CRC32 has poor distribution, but most of the newer hash functions have addressed this.\r\n* **Simplicity**: If we can accomplish this without adding a new UUID version, that will make this whole thing go a lot faster. It also means we don't use up UUIDv9 without thinking this all the way through and giving it more time to be studied carefully.\r\n\r\nThe problems we're **not** trying to solve:\r\n\r\n* **Preventing deliberate collisions** (given input X hashes to Y, finding another value Z that also hashes to Y)\r\n* **Preventing guessing the input based on the output** (given hash Y, the difficulty of guessing input X)\r\n* Specifically these security concerns seem fundamentally conflicted with the fact that UUID is limited to an exact size.  It is unlikely there is any hashing solution that is currently and will continue to be secure in the face of this restriction (and changing size of UUID or making it variable length has already been discussed at length and dismissed as out of scope for this document). As such, this tends to point in the direction of not using a cryptographic hash function at all, since this A) sends a signal to other people that cryptographic security is implied and B) will likely suffer the same fate as MD5 and SHA-1 given enough time.\r\n\r\n**Okay, so with all that said, it seems to me like we could address all this by simply providing a suggestion for an implementation of UUIDv8 that uses a specific (non-cryptographic) hash function.**  Since UUIDv8 is by definition unrestricted, I don't think we can really make any arguments about collision resistance against other implementations (i.e. trying to guess how often a hash function might collide with someone else's implementation seems unlikely to be fruitful).  So why not simply have a short section under UUIDv8 that says something like:\r\n\r\n> **For implementations requiring a deterministic UUID that uses a modern hashing function, UUIDv8 can be used.  A suggested implementation is to compute a xxhash-128 value from the input and then write the version and variant bits appropriately.**\r\n\r\nAnd then whoever needs this can just point to the document and say \"our implementation uses UUIDv8 with the suggestion specified at (link to section of the doc with text above)\" and they get all of the benefits above: determinism, interoperability, collision resistance, and it doesn't require us to commit to UUIDv9 right now.\r\n\r\nCould this help point us in the right direction here?  If so, I think we just need to pick the specific hash function and tweak the text to ensure it's specific enough.\r\n\r\n---\r\n\r\nAlso just dropping a few notes on specific non-cryptographic hash algorithms if we go this route:\r\n* xxhash is noted for its run-time speed\r\n* fnv is noted for its simplicity of implementation\r\n* SipHash looks interesting but still seems crypto focused and requires a separate secret key. @LiosK \r\n* I haven't looked into which hash algorithms are specified in RFCs or other standards documents, something standardized might be better than not.",
          "createdAt": "2023-09-20T07:13:02Z",
          "updatedAt": "2023-09-20T07:20:43Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bradleypeabody\r\nThank you so much for analyzing/evaluating all this and spending so much time on this topic!\r\n\r\nI fully agree with all your points except for one detail: I do not like the idea of selecting a single hash algorithm. Maybe just say the hash algorithm needs at least 128 bits in size.\r\n\r\n\r\nI have an approach that only affects the section UUIDv8 and does not require UUIDv9. I am not familar with the IETF procedures, so I don't know if this change is acceptable or if it also needs a large re-do of all the reviews. I do not want to destroy the work of many years.\r\n\r\n\r\n\r\nWhat about the following proposal?:\r\n\r\n---\r\n\r\nIn section 5.8 (UUIDv8) we could explicitly state that there are three possibilities:\r\n\r\n1. UUIDv8 custom time-based (and mention that this UUIDv8 variant is required by section 6.1)\r\n2. UUIDv8 name-based (and mention that this UUIDv8 variant is required by section 5.5. Intentionally I do NOT call this \"custom name-based\" because I would like this name-based approach to be defined, see below.)\r\n3. Misc/Fully custom UUIDv8  (we need to agree on a fitting name)\r\n\r\nThen write some explanations for each of these three possibilities.\r\n\r\n**_1. In re \"UUIDv8 custom time-based\":_**\r\n\r\nWe can give some clues about what could be customized:\r\n\r\n- Timing resolution\r\n- Starting point / Epoch\r\n- Additional fields such as clock sequence, random bits, node ID\r\n- Order of the fields\r\n- etc. (Did I forget something?)\r\n\r\nWe can refer to example C.7, but I still think the one nanosecond is a very bad example and should be adjusted, so that the UUID does not wrap around at 78 hours.\r\n\r\nI wouldn't mind if example C.7 is removed, but I leave that up to you.\r\n\r\n\r\n**_2. In re \"UUIDv8 name-based\":_**\r\n\r\nI would be very happy if we could DEFINE how a UUIDv8 name-based is calculated, rather than just naming it an \"example\", otherwise this would allow different implementations.\r\n\r\nDefine (most of this definition can be taken from section C.8):\r\n\r\n1. You can use any hash algorithm, but it should have at least 128 bits in size. (Optionally, you can recommend one specific algorithm, but I think the developer should be able to choose any algorithm with size >= 128 bits)\r\n\r\n2. Create a hash like `UUIDv8 = Hash(HashspaceId || NamespaceId || Data)`\r\nThough I am not sure why HashspaceId does exist at all... does it make the hash any better?\r\nIf the requirement is to avoid that two hash algorithms collide, the approach should rather be:\r\n`UUIDv8 = HashspaceId XOR Hash(NamespaceId || Data)`\r\nBut if we allow the risk that two hash algorithms collide, then the solution can be much simpler:\r\n`UUIDv8 = Hash(NamespaceId || Data)`\r\nIn that case, name-based UUIDv8 behaves exactly like UUIDv3/5, and Appendix B (hash spaces) could be removed, and this simplifies the document and IANA would not need to create a registry for Hashspace IDs.\r\nI am okay with it either way. I just want a fixed definition of name-based UUIDv8 instead of an example.\r\n\r\n3. Cut off any additional bits on the right side.\r\n\r\n4. Replace the variant and version (\"8\") bits.\r\n\r\n\r\n**_3. In re \"Misc/Fully custom UUIDv8\"_**\r\n\r\nWe can keep the sentence:\r\n\"_Fully custom UUIDv8 provides an RFC-compatible format for experimental or vendor-specific use cases_.\"\r\n\r\nI don't think we should provide any examples of fully custom UUIDv8, since there are so many possible things people can do.\r\n\r\n---\r\n\r\nThe advantages of this proposal:\r\n\r\n- The proposal only modifies a single section: UUIDv8.\r\n- We don't need a new UUID version\r\n- People can now say \"I implemented UUIDv8 name-based with hash SHA3 according to RFC xxxx\" and it is 100% clear what they have implemented, since the construction of \"UUIDv8 name based\" is clearly defined and not an example anymore.\r\n- As of the current draft, in sections 5.5 and 6.1 we are already stating \"_MUST use UUIDv8_\". So it is very fitting that the UUIDv8 section addresses these two cases from sections 5.5 and 6.1 (in addition to the fully custom case).\r\n\r\nDisadvantage of this proposal:\r\n\r\n- There is a theoretical risk that name-based, custom time-based, and fully custom UUIDv8 collide. But since hash algorithms usually have a high entropy, I think this chance is so tiny, that it can be ignored.\r\n\r\nWhat do you think?",
          "createdAt": "2023-09-20T10:23:46Z",
          "updatedAt": "2023-09-20T10:26:06Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I think UUIDv8 is suitable for the name-based solution @danielmarschall chose to use, so if he uses his own custom vendor-specific name-based format, I don't think there is any problem. He could share the exact generator function with us, but that exact format shouldn't be in the RFC. That is the whole point of UUIDv8 being there.\r\n\r\nIn that case, UUIDv9 isn't needed to be introduced, because the outside the world of @danielmarschall, people use other UUIDv8 types and not neccessary need his format in their software. I think it is clear to us all that we don't introduce UUIDv9 for the upcoming RFC. If we uniformly see a need to define some name-based UUID later, we can come back together and talk about UUIDv9 or UUIDv10 or which other version-nibble is still availble at that time.\r\n\r\nSo, in my opinion:\r\n - @danielmarschall, use UUIDv8 for the time being with your custom format. In the future there maybe is a new version that will introduce a improved version of UUIDv3 and UUIDv5 that is available for us all. There will be no UUIDv9 in this spec and #147 can be closed.\r\n - We should take a big look at the examples for UUIDv8. We rewrite or remove them. If we rewrite them, we could add the sentence `These examples MUST not be implemented, because they only show what UUIDv8 is capable of. It isn't a defined format to use in production code.` or something. I don't say we shouldn't have examples, but we should be extremely carefull with having them. For me, the example section at the moment seems a very big call to action to implement these examples, but that is exactly what we don't want. I suggest we continue the conversation about that in #150.\r\n - Because the UUIDv8 examples are just examples, and because there is no UUIDv9 yet, we will not ask IANA to make a registry for hashspaces. We also don't list them in the RFC, so #143 can be closed. Making those registries will cause people to see the examples as implementation requirements and we don't want that, see my point above. Other registries could be added to IANA, see #144. Talking about IANA will continue in #144.",
          "createdAt": "2023-09-20T10:35:22Z",
          "updatedAt": "2023-09-20T10:36:52Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "at least 122 bits in size \n\nnot 128, because 6 bits are used for version and variant\n",
          "createdAt": "2023-09-20T11:37:56Z",
          "updatedAt": "2023-09-20T11:37:56Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "The word \"name-based\" is misleading because it could be hash from integer. Hash-based is  unambiguous and specific",
          "createdAt": "2023-09-20T11:46:02Z",
          "updatedAt": "2023-09-20T11:46:02Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yes, hash-based is the better word. I just thought to match the naming with UUIDv3 and UUIDv5\r\n\r\nIn re 122/128 bits: Is it easier to implement to choose 128 bit hash and then overwrite the variant + version bits rather than inserting the bits between the 122 bits.",
          "createdAt": "2023-09-20T11:47:59Z",
          "updatedAt": "2023-09-20T11:48:05Z"
        },
        {
          "author": "chorman0773",
          "authorAssociation": "NONE",
          "body": "I wouldn't say easier (it's a few bit shifts, so it is trivial either way) but it's more efficient and more obvious IMO than truncating an extra 6 bits and doing a the bit splitting.",
          "createdAt": "2023-09-20T12:06:30Z",
          "updatedAt": "2023-09-20T12:06:30Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "I have the feeling the thread is getting a bit off-topic.",
          "createdAt": "2023-09-20T12:18:09Z",
          "updatedAt": "2023-09-20T12:18:09Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "It would be wrong to prohibit 122 bits\n",
          "createdAt": "2023-09-20T12:35:44Z",
          "updatedAt": "2023-09-20T12:35:44Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Initially, I thought that a name-based UUIDv9 would be very simple because section C.8 already had a very nice implementation (and was already accepted by most?). The only discussion there was the choice of hash space IDs which was also [already solved/decided](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143#issuecomment-1711804042).\r\n\r\n\r\nOk \ud83c\udff3\ufe0f .... due to this discussion, I come to the conclusion that there are a lot of implementation possibilities and opinions about the details of such a name/hash-based UUID that allows modern hash algorithms.\r\n\r\nSome of the implementation possibilities and things to consider are:\r\n\r\n- Requirements for a hash? (Allow \"all\"? Allow only \"secure\"?)\r\n\r\n- Write 128 bits and overwrite bits with variant/version (like UUIDv3/5), or write 122 bits and insert the variant/version bits?\r\n\r\n- Cut off bits at the \"right\" side (LSB, like UUIDv3/5) or at the \"left\" side (MSB)?\r\n\r\n- Allow hash algorithms that are too short? If yes:\r\n\r\n\t- Fill the missing bits with zeros or with a bit pattern?\r\n\r\n\t- Fill at the \"right\" side (LSB) or the \"left\" side (MSB)?\r\n\r\n- How to create the hash?\r\n\r\n\t`UUIDv9 = Hash(HashspaceId || NamespaceId || Data)` (= example in appendix C.8)\r\n\tor\r\n\t`UUIDv9 = HashspaceId XOR Hash(NamespaceId || Data)`\r\n\tor\r\n\t`UUIDv9 = Hash(NamespaceId || Data)`\r\n\tor\r\n\t`UUIDv9 = HashNumber || Hash(NamespaceId || Data)` where `HashNumber` might be 1, 2, 3 for algo X, Y, Z\r\n\tor\r\n\tsomething completely different?\r\n\r\n- If Hashspace IDs are used, how are they chosen?\r\n\r\n\t- Use a UUIDv4? (as of uuidrev draft 11)\r\n\t- Calculate it using a custom UUIDv5 namespace and a canonical hash name? (proposal [here](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143#issuecomment-1709057651))\r\n\t- Calculate it using the OID UUIDv5 namespace and the [most common] algorithm OID? (proposal [here](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143#issuecomment-1709117798) and decided [here](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/143#issuecomment-1711804042))\r\n\t- Use UUIDv1/6/7?\r\n\t- Don't use UUID as hash space id and rather use the [most common] algorithm OID in dot notation?\r\n\t- Don't use UUID as hash space id and rather use the [most common] algorithm OID in DER notation?\r\n\t- or something completely different?\r\n\r\n- If Hashspace IDs are used, register them at IANA? Register OIDs and algorithm names, too? (#144)\r\n\r\n- Call it \"name-based\" as of UUIDv3/5 or hash-based? (And maybe even rename UUIDv3/5 to \"hash-based\"?)\r\n\r\n- ...\r\n\r\n---\r\n\r\nI do still think that UUIDv9 should be introduced in the future and that it should be a successor to UUIDv3 and UUIDv5 (similarly like UUIDv6 is a successor to UUIDv1), but I understand that the questions I mentioned above need to be answered and that this cannot be done in this RFC.\r\n\r\nIf an RFC is planned in the future featuring these \"name/hash-based any-hash UUIDs\" aka UUIDv9, I hope I will notice it it in time (or get notified if possible); then I will contribute as much as possible. I wish I had noticed this ongoing UUID revision sooner - I found it by accident while Googling UUID implementations.\r\n\r\n---\r\n\r\n**_For this RFC I propose [Proposal version 4, aka ultra light version of my initial proposal]:_**\r\n\r\n- I suggest thinking about the examples; at least change the time resolution of C.7 time-based. (#150)\r\n\r\n- In section 5.8 (UUIDv8) please mention these cases:\r\n\r\n\t- UUIDv8 custom time-based (\"as required by section 6.1\")\r\n\t- UUIDv8 **_custom_** name-based (\"as required by section 5.5\")\r\n\t- UUIDv8 misc/other/fully custom [TODO: decide about name]\r\n\r\n\r\n_Annotation about my suggested 3 cases:_\r\n\r\n_- Now, I do use the word \"custom\" in \"custom name-based\", because the developer needs to decide about the various implementation details._\r\n\r\n_- You could argue that \"custom time-based\" and \"custom name-based\" are both \"custom\", so mentioning three things might be redundant. However, since sections 5.5 and 6.5 both refer to section 5.8 (UUIDv8), I think these references should be addressed. Also, it gives the developer an idea \"Hey, I could use SHA3 in my UUID\" :-)_",
          "createdAt": "2023-09-20T14:10:42Z",
          "updatedAt": "2023-09-20T16:50:56Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall\r\n\r\n> except for one detail: I do not like the idea of selecting a single hash algorithm\r\n\r\nIf we don't specify exactly how it's done, then we lose the interoperability requirement, which is essentially what @chorman0773 brought up for that use case.\r\n\r\n---\r\n\r\nAnd there's the point about the examples for UUIDv8 too easily becoming an implementation suggestion.\r\n\r\nI haven't looked at it in detail recently, but **what if we simply replace the UUIDv8 examples with one example of a hash based UUID** - specify it in detail so it can actually be referred to inter-operably if needed, but then that's it.  UUIDv8 remains completely open ended, there's just one example that happens to be a hash based one that solves the uses brought up here.  @chorman0773 you get what you're after, @danielmarschall you can use this or do anything else you want with UUIDv8.\r\n\r\n**I'd like to see how much consensus there is on that idea,** and if we're starting to agree, then we can look at some specific changes and start getting a pull request put together.\r\n",
          "createdAt": "2023-09-20T18:25:57Z",
          "updatedAt": "2023-09-20T18:25:57Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "Please no more additional proposals )",
          "createdAt": "2023-09-20T18:49:52Z",
          "updatedAt": "2023-09-20T18:49:52Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If we don't specify exactly how it's done, then we lose the interoperability requirement, which is essentially what @chorman0773 brought up for that use case.\r\n\r\n@bradleypeabody Sorry, I am a bit confused. Do you mean [this post](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1726756421) by @chorman0773 ? My (initial) idea was to specify the mechanism/construction itself, but leaving the algorithm to the developer. Of course, this would mean that the algorithm is required for describing the UUID, i.e. there is not one \"Hash-Based-UUIDv8\" instead there is a \"SHA3-Hash-Based-UUIDv8\", or a \"SipHash-Hash-Based-UUIDv8\", or simply `UUIDv8_Namebased(Hash, Namespace, Data)` ...  Sorry if I misunderstood something.",
          "createdAt": "2023-09-20T18:59:30Z",
          "updatedAt": "2023-09-20T19:06:05Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@sergeyprokhorenko keep in mind there also https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/150, and so I was thinking  we might be able to address both of these issues with a relatively small change just to the examples of UUIDv8.  If the goal is to have completely zero changes to the doc so it can be approved as-is, that's one thing.  But if there will be any changes at all, then I think editing the UUIDv8 examples to address these concerns could be workable. ",
          "createdAt": "2023-09-20T18:59:35Z",
          "updatedAt": "2023-09-20T18:59:35Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> I haven't looked at it in detail recently, but **what if we simply replace the UUIDv8 examples with one example of a hash based UUID** - specify it in detail so it can actually be referred to inter-operably if needed, but then that's it.\r\n\r\n@bradleypeabody  This sounds great!",
          "createdAt": "2023-09-20T19:01:08Z",
          "updatedAt": "2023-09-20T19:01:08Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "> I haven't looked at it in detail recently, but **what if we simply replace the UUIDv8 examples with one example of a hash based UUID** - specify it in detail so it can actually be referred to inter-operably if needed, but then that's it.\r\n\r\nI don't know if I agree on that one, but I think it's discussion belongs to #150. At least we have to review them to see what exactly is wrong and what can be changed.",
          "createdAt": "2023-09-20T19:22:45Z",
          "updatedAt": "2023-09-20T19:22:45Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall \r\n\r\n> My (initial) idea was to specify it the mechanism/construction itself, but leaving the algorithm to the developer. \r\n\r\nTo clarify my concerns, the main issue I have with that approach is that without a specific hash algorithm and specific way to fit the result into the UUID 128 bits, we lose interoperability.  Specifically, what I mean is that if person A wants to implement a hash-based UUIDv8 and person B wants to do the same thing and ensure that the same input hashes to the same output UUID - we don't get that result unless there is something specific enough to clearly describe exactly how it's done.  For this to work, we need a section of the doc where these two people can just say \"the implementation is per (link)\". (And although an example is less set in stone than a separate version, you can still link to it and refer to it as a specific implementation if you want to.)  If we provide any less detail, we lose interoperability.  And if we're not trying to be interoperable, then what is the point of providing any detail at all?  If you are only concerned about your own implementation, then you can just do whatever you want with UUIDv8, that's its entire purpose, we don't need to change the spec to make it address that scenario, it's already covered.",
          "createdAt": "2023-09-20T19:28:41Z",
          "updatedAt": "2023-09-20T19:32:54Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> For this to work, we need a section of the doc where these two people can just say \"the implementation is per (link)\".\r\n\r\n@bradleypeabody Yes, this is what I intend, to have a reference for interoperability. Maybe there was a misunderstanding. Of course, the example should show a specific example, e.g. to construct the hash using SHA3, and then describe how the bits are placed to form the resulting UUID.",
          "createdAt": "2023-09-20T20:00:45Z",
          "updatedAt": "2023-09-20T20:12:21Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall Okay understood.  So then if we went down the route you suggest there would just be a lot of variation that would require specification - what to do with hash algorithms that have more or less bits (e.g. 64bit hashes are very common), where is the specification for each hash algorithm (some are more/less standardized than others), are there any limitations of what we allow e.g. is a 16 bit hash allowed? how about 256 bits truncated? Or should they be XORed together, etc., etc.  It's possible to specify, but it doesn't seem simple.\r\n\r\nThat said, **as the original poster of this thread, do you agree that we can address the concerns in this thread through one or more examples of UUIDv8?**  If you agree, and there are no other objections, then we can fold this discussion into #150 and start looking at specific UUIDv8 examples and start narrowing this down into some specific actionable edits to the doc.",
          "createdAt": "2023-09-20T20:12:21Z",
          "updatedAt": "2023-09-20T20:12:21Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> @sergeyprokhorenko keep in mind there also #150, and so I was thinking we might be able to address both of these issues with a relatively small change just to the examples of UUIDv8. If the goal is to have completely zero changes to the doc so it can be approved as-is, that's one thing. But if there will be any changes at all, then I think editing the UUIDv8 examples to address these concerns could be workable.\r\n\r\n@bradleypeabody\r\n\r\nI completely agree with you.\r\n\r\nThe best option would be to leave everything as is, and not slow down the RFC approval process.\r\n\r\nTrue, the quality of the RFC would benefit if all UUIDv8 examples were removed, leaving everything to the will and responsibility of the implementers. If we add any UUIDv8 example, then we are responsible for its quality, and we would not like that. This could now lead to endless discussions to improve this example.\r\n\r\nIf this is not possible, then the best solution would be to replace all UUIDv8 examples with one hash-based example.",
          "createdAt": "2023-09-20T20:33:37Z",
          "updatedAt": "2023-09-20T20:33:37Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> That said, **as the original poster of this thread, do you agree that we can address the concerns in this thread through one or more examples of UUIDv8?** If you agree, and there are no other objections, then we can fold this discussion into #150 and start looking at specific UUIDv8 examples and start narrowing this down into some specific actionable edits to the doc.\r\n\r\nYes, absolutely!\r\n\r\n> So then if we went down the route you suggest there would just be a lot of variation that would require specification - what to do with hash algorithms that have more or less bits (e.g. 64bit hashes are very common), where is the specification for each hash algorithm (some are more/less standardized than others), are there any limitations of what we allow e.g. is a 16 bit hash allowed? how about 256 bits truncated? Or should they be XORed together, etc., etc. It's possible to specify, but it doesn't seem simple.\r\n\r\nThe [long list of questions](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1727814436) were all the implementation variations I could imagine. Specifying/explaining them all in the doc would be complicated and probably also unnecessary. For example, if Hashspace IDs get removed, then the readers of the final RFC won't know that hashspaces existed in the first place.\r\n\r\n**_My approach would be:_**\r\n\r\n1. Make one (good) example that can be used as a reference for interoperability.\r\n\r\n2. Try making the UUIDv8 example as simple as possible, so I would recommend not using hashspace IDs and re-use as many implementation details from UUIDv3 and UUIDv5 as possible, rather than defining new ones. People are familiar with UUIDv3/5.\r\n \r\nMy **_personal preference_** for the implementation variations in the [long list of questions](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1727814436) would be the following.\r\n(But the important thing is the consensus and not my personal opinion!)\r\n\r\n- Allow all hashes (and hope that developers are not stupid and use CRC16). [To clarify: I mean \"allow\" all hashes, and the example demonstrates it using a specific test vector, e.g. SHA3]\r\n\r\n- If the hash output size is < 128 bits, fill the right side with zero bits until 128 bits are reached.\r\n\r\n- If the hash output size is > 128 bits, cut the extra bits from the right side. (= same implementation as UUIDv3/5)\r\n\r\n- Write 128 bits and then overwrite the bits with UUID variant/version (= same implementation as UUIDv3/5)\r\n\r\n- Create the hash using `UUIDv8(Hash, Namespace, Data) := Hash(NamespaceId || Data)` , because this is the easiest way and it matches the UUIDv3/5 specification.\r\n\r\n- Call it name-based to match the naming scheme UUIDv3/5.\r\n",
          "createdAt": "2023-09-20T20:35:45Z",
          "updatedAt": "2023-09-20T20:45:14Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall\r\n> Ok \ud83c\udff3\ufe0f .... due to this discussion, I come to the conclusion that there are a lot of implementation possibilities and opinions about the details of such a name/hash-based UUID that allows modern hash algorithms.\r\n\r\nFor those that are curious, this thread is a good example as to why it has taken ~3 years to create v6, v7, v8 and deliver this doc. There have been many long threads like this when we were going through the [data, implementation prototypes, discovering corner cases, and many other item](https://github.com/uuid6/uuid6-ietf-draft/issues?q=is%3Aissue). Creating and defining a widely used spec such as this one is no easy task.\r\n\r\n[Though I postulated a SHA256v9 back when I was drafting rfc4122bis](https://github.com/ietf-wg-uuidrev/rfc4122bis/blob/main/editor-files/UUIDv3-v5-Testing.md#sha256-testing-a-v9---5c146b14-3c52-9afd-938a-375d0df1fbf60); I was never able to find a strong use case to assign it a version number. As such I voted, with others, at one of our interim meetings to put it in the v8 category of \"design it if you need it and do it under v8\".\r\n\r\n---\r\n\r\nAs for the latest comment and what I assume is the final verdict of the thread: \r\nWould a single v8 hash-based UUID using SHA-256 (but allowing other options) , www.example.com, and the DNS Namespace without Hashspace IDs be suitable? \r\nBasically v5 SHA-1 but with SHA-256 plugged in and version bits flipped to v8.\r\n\r\nAlso I can change the items in this doc from \"name-based\" to \"hash-based\" which I agree, is a better descriptor.",
          "createdAt": "2023-09-20T20:47:48Z",
          "updatedAt": "2023-09-20T20:48:02Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> As for the latest comment and what I assume is the final verdict of the thread: Would a single v8 hash-based UUID using SHA-256 (but allowing other options) , [www.example.com](http://www.example.com), and the DNS Namespace without Hashspace IDs be suitable? Basically v5 SHA-1 but with SHA-256 plugged in and version bits flipped to v8.\r\n\r\nYes, this sounds perfect!\r\n\r\n> Also I can change the items in this doc from \"name-based\" to \"hash-based\" which I agree, is a better descriptor.\r\n\r\nI think \"name-based\" came due to the fact that OIDs and URIs are \"names\" rather than the resulting format which is a hash.\r\nI am fine either way (name-based or hash-based).\r\nBut if it gets changed to hash-based, isn't there a backward compatibility problem, if implementations use the word \"name based\"?",
          "createdAt": "2023-09-20T20:52:43Z",
          "updatedAt": "2023-09-20T20:53:00Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall Thanks for that, makes sense.  I agree with your points 1 and 2 and the rest also make sense to me.  Let's try to narrow this into what specific edit(s) to propose.\r\n\r\nLooking at the doc, there's this whole [Named-based UUID section](https://github.com/ietf-wg-uuidrev/rfc4122bis/blob/main/draft-ietf-uuidrev-rfc4122bis.md#name-based-uuid-generation-name_based_uuid_generation) that will likely need to be updated.  However, I strongly recommend starting from the simplest, most basic text for this, and then add what's missing, instead of starting with a large long explanation that then needs to be whittled down.\r\n\r\nSo with that in mind, can you please propose some text which describes this example UUIDv8 - so myself others can give specific feedback on that?  (Again, I urge you to start simple, try for a couple/few paragraphs if you can.)",
          "createdAt": "2023-09-20T20:53:03Z",
          "updatedAt": "2023-09-20T20:53:03Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> https://mailarchive.ietf.org/arch/msg/uuidrev/dhxgO66xkpNBrOtSy0AY8nV9bAE/ @sergeyprokhorenko @danielmarschall @ben221199 @LiosK @chorman0773 If this matters, then please participate.\r\n\r\n@mcr\r\n\r\nWe were put in terrible conditions that we must ensure consensus. This is incorrect because responsibility for the quality of the RFC rests with the three authors who submitted the RFC for approval. But now one belated and picky person from the outside can impose his will on everyone else, and it is not clear how to please him. We are forced under pressure to add into the RFC a deliberately risky technical solution, the quality of which is below any criticism, because it\u2019s easier for someone to make a workaround in his information system.\r\n\r\nI transfer my vote to @LiosK at the virtual interim meeting in early October.\r\n",
          "createdAt": "2023-09-20T21:00:43Z",
          "updatedAt": "2023-09-20T21:00:43Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "> We were put in terrible conditions that we must ensure consensus. This is incorrect because responsibility for the quality of the RFC rests with the three authors who submitted the RFC for approval. But now one belated and picky person from the outside can impose his will on everyone else, and it is not clear how to please him. We are forced under pressure to add into the RFC a deliberately risky technical solution, the quality of which is below any criticism, because it\u2019s easier for someone to make a workaround in his information system.\r\n\r\nAnd to be clear on my position on this, if there is a path where there are zero edits required and we can get the doc approved as-is, then I absolutely think we need to seriously consider that option and weigh things appropriately.  However, if there are any edits required for anything and thus it needs to be looked at again by various people, then I don't see the harm in adding/editing this UUIDv8 example stuff as described above.",
          "createdAt": "2023-09-20T21:08:56Z",
          "updatedAt": "2023-09-20T21:09:28Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Should I now write a draft for an UUIDv8 example as @bradleypeabody requested, or wait for the interim meeting in early October as @sergeyprokhorenko recommends?\r\n\r\nI think the interim meeting was scheduled because of the decision if UUIDv9 should be considered or not. But the UUIDv9 topic is now solved. UUIDv9 will not come. The change/merge/deletion of section C.7 and C.8 is not a change that requires the reviews to be re-done, therefore I do not think the interim meeting is required at this point? (Correct me if I'm wrong, I am not an expert in this standardization procedure)\r\n",
          "createdAt": "2023-09-20T21:10:05Z",
          "updatedAt": "2023-09-20T21:11:36Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall If you want changes, the earlier you arrive at what exactly they are (like the actual text edits) and show other people so there can be feedback, the more likely you will get them.  The meeting is already being scheduled, so you might as well use the time until then to figure out exactly what it is that you're proposing and try to gain consensus on it as soon as possible.  Then the meeting can just confirm exactly what we're doing.\r\n\r\nIf you don't want any changes, then by all means, feel free to just say that.  But if you want something changed, please get to it (provide specific text changes so we can work through that), and no don't cancel the meeting after it's already been requested unless you completely withdraw this entire thing and don't want any changes to the document.",
          "createdAt": "2023-09-20T21:18:06Z",
          "updatedAt": "2023-09-20T21:18:06Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall and @bradleypeabody, based on my comment https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1728404540\r\nI think I have an idea of what needs to be edited to address this. I can whip it up in a PR under a new branch and let @danielmarschall review. Then we can use the interim to discuss if this should replace the current Hashspace ID text or if any further edits need to be made.\r\n\r\nEdit: I would also like to use the Interim to discuss the IANA topic again as the last interim voted no IANA registry and now there seems to be strong consensus to have IANA registry.",
          "createdAt": "2023-09-20T21:21:50Z",
          "updatedAt": "2023-09-20T21:24:37Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> But if you want something changed, please get to it (provide specific text changes so we can work through that), and no don't cancel the meeting after it's already been requested unless you completely withdraw this entire thing and don't want any changes to the document.\r\n\r\nSorry. There was a big misunderstanding. I did not suggest, intend or request any cancellation of the meeting, nor the change of the UUIDv8 example as discussed. I was just very confused by the previous comment... and the language-barrier makes it not easy for me.\r\n\r\n> @danielmarschall and @bradleypeabody, based on my comment [#147 (comment)](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1728404540) I think I have an idea of what needs to be edited to address this. I can whip it up in a PR under a new branch and let @danielmarschall review. Then we can use the interim to discuss if this should replace the current Hashspace ID text or if any further edits need to be made.\r\n\r\nSounds good!",
          "createdAt": "2023-09-20T21:29:21Z",
          "updatedAt": "2023-09-20T21:29:50Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kyzer-davis \r\n\r\nHere is a small draft I have written:\r\nFeel free to use parts of it if you like. Or just use the test-vector.\r\nI'm looking forward to your Pullrequest / branch!\r\n\r\n```\r\n(This section replaces C.7 and C.8 and deletes Appendix B)\r\n\r\nC.7. Example of a UUIDv8 Value\r\n\r\nThis example shows one of many use cases of a custom UUID.\r\nIt implements a name-based UUID based on an arbitrary hash function,\r\nsimilar to UUIDv3 (using MD5) and UUIDv5 (using SHA1).\r\n\r\nA hash value is calculated in the same way UUIDv3 and UUIDv5 are calculated,\r\nby concatenating the namespace (from Appendix A) with a name identifier.\r\n\r\nIf the output length of the hash function is smaller than 128 bits,\r\nthen zero bits will be filled to the right (LSB) side until 128 bits are reached.\r\n\r\nIf the output length of the hash function is greater than 128 bits,\r\nthen the extra bits will be removed from the right (LSB) side,\r\nlike done in UUIDv3 and UUIDv5.\r\n\r\nThe computation from is detailed in Figure 27 using the DNS\r\nNameSpace and the Name \"www.example.com\", while figure 28 shows the\r\nbit swapping for version and variant and the unused/discarded\r\npart of the SHA-256 value.\r\n\r\n\r\n   Namespace (DNS):       6ba7b810-9dad-11d1-80b4-00c04fd430c8\r\n   Name:                  www.example.com\r\n   ----------------------------------------------------------------\r\n   SHA-256:\r\n   5c146b143c524afd938a375d0df1fbf6fe12a66b645f72f6158759387e51f3c8\r\n\r\n                      Figure 27: UUIDv8 Example SHA-256\r\n\r\n\r\nA: 5c146b14-3c52-4afd-938a-375d0df1fbf6-fe12a66b645f72f6158759387e51f3c8\r\nB: xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx\r\nC: 5c146b14-3c52-8afd-938a-375d0df1fbf6\r\nD:                                     -fe12a66b645f72f6158759387e51f3c8\r\n\r\n  Figure 28: UUIDv8 Example Ver/Var bit swaps and discarded SHA-256\r\n                               segment\r\n\r\n\r\n\r\n\r\n\r\n   -------------------------------------------\r\n   field     bits value\r\n   -------------------------------------------\r\n   custom_a  48   0x5c146b143c52\r\n   ver        4   0x8\r\n   custom_b  12   0xafd\r\n   var        2   0b10\r\n   custom_c  62   0b00, 0x38a375d0df1fbf6\r\n   -------------------------------------------\r\n   total     128\r\n   -------------------------------------------\r\n   final: 5c146b14-3c52-8afd-938a-375d0df1fbf6\r\n\r\n          Figure 29: UUIDv8 Example Name-Based SHA-256 Test Vector\r\n\r\n\r\n\r\n   Examining Figure 29:\r\n\r\n   *  Line A details the full SHA-256 as a hexadecimal value with the\r\n      dashes inserted.\r\n   *  Line B details the version and variant hexadecimal positions which\r\n      must be overwritten.\r\n   *  Line C details the final value after the ver/var have been\r\n      overwritten.\r\n   *  Line D details the discarded, leftover values from the original\r\n      SHA-256 computation.\r\n\r\n```\r\n\r\n\r\nInternal script to calculate the test vector:\r\n\r\n```\r\n<?php\r\nconst UUID_NAMEBASED_NS_DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\r\n$namespace_uuid = str_replace('-', '', UUID_NAMEBASED_NS_DNS);\r\n$namespace_uuid = hex2bin($namespace_uuid);\r\n$hash = hash('sha256', $namespace_uuid.'www.example.com');\r\necho \"$hash\\n\";\r\n$hash[12] = '8'; // version 8\r\n$hash[16] = dechex(hexdec($hash[16]) & 0b0011 | 0b1000); // Set variant to \"10xx\" (RFC4122)\r\necho $hash;\r\n\r\n```",
          "createdAt": "2023-09-20T21:52:14Z",
          "updatedAt": "2023-09-20T22:04:03Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "(The PHP script is not part of the draft. Just in case someone wants to verify the test-vector.)",
          "createdAt": "2023-09-20T21:56:13Z",
          "updatedAt": "2023-09-20T21:56:13Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall @kyzer-davis Some notes on the text above:\r\n* I think it would be more clear to make the example very specific to one hash function, and fill in any details so it's exact, and then after that is explained it can say that this same idea could be applied to other hash functions.  This also gives it the property that you can just link to this section of the doc and say \"implement this\" and nobody will be confused about which hash function is intended. (I.e. this change will improve interoperability).\r\n* I think we need to make sure we vet which hash function we're using more carefully.  Based on my earlier post about how we're not trying for cryptographic strength, then why use SHA-256?  (And if we were, why not SHA-512?). Avoiding hashes intended for cryptographic use also avoids the example becoming obsolete if/when the chosen algorithm becomes insecure - again, a property which we specifically are not trying to achieve here.   Does anyone have an objection to using https://xxhash.com/ ?  It's fast, evenly distributed, reasonably well-studied and standardized, and has implementations in a plethora of languages, and a version that outputs 128 bits.  And it is very specifically not intended for security use.\r\n* I'm not sure if it's better to truncate longer hashes, or XOR them, or how much it matters.  Something to consider in the additional text that talks about this.\r\n* For shorter UUIDs filling with zeros seems like not a great choice, since we're just wasting very precious bits of entropy.  I don't have a better idea off the top of my head but it feels like something that should be addressed (e.g. maybe we suggest using two different 64-bit hashes together to always fill the required space).\r\n\r\nSpecifically, how about this:\r\n\r\n```\r\nC.7. Example of a UUIDv8 Value using Name-based xxHash\r\n\r\nThis example shows one of many use cases of a custom UUID.\r\nIt implements a name-based UUID based on the XXH3_128bits\r\nhash function (link to external reference - xxhash.com).\r\nThis provides functionality similar to UUID v3 and v5 but using a\r\nmodern non-cryptographic hash.\r\n\r\nA hash value is calculated in the same way UUIDv3 and UUIDv5 are calculated,\r\nby concatenating the namespace (from Appendix A) with a name identifier.\r\n\r\nThe version and variant fields replace the hash output to form a full 128-bit UUID...\r\n```\r\n\r\nAnd then after the detailed example, the additional explanation can be made about other hash functions:\r\n\r\n```\r\nThe same technique can be used effectively with other hash functions,\r\nincluding those with more or less than 128 bits.\r\n\r\n(FIXME: can we do better than zero filling?) If the output length of the\r\nhash function is smaller than 128 bits, then zero bits can be filled to\r\nthe right (LSB) side until 128 bits are reached.\r\n\r\nIf the output length of the hash function is greater than 128 bits, then\r\nthe extra bits can be truncated from the right (LSB) side, as is done\r\nin UUIDv3 and UUIDv5.\r\n```",
          "createdAt": "2023-09-20T22:34:08Z",
          "updatedAt": "2023-09-20T22:54:31Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bradleypeabody Your changes look good!\r\n\r\nI have no objections in re xxHash128.\r\n\r\n> I'm not sure if it's better to truncate longer hashes, or XOR them, or how much it matters. Something to consider in the additional text that talks about this.\r\n\r\nI think since [for of modern hashes] the entropy between the bits is equal, it shouldn't make a difference if you just cut 128 bits out of it or XORing the bits together. But disclaimer, I am no expert in that mathematical topic.\r\n\r\n> For shorter UUIDs filling with zeros seems like not a great choice, since we're just wasting very precious bits of entropy. I don't have a better idea off the top of my head but it feels like something that should be addressed (e.g. maybe we suggest using two different 64-bit hashes together to always fill the required space).\r\n\r\nUnfortunately, currently, I have no better idea for the <128 bits hashes than to append zero bits.",
          "createdAt": "2023-09-20T22:55:48Z",
          "updatedAt": "2023-09-20T23:01:22Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@bradleypeabody @kyzer-davis \r\nHere are test-vectors for xxHash128:\r\n\r\nRaw:\r\nde20549b5ca285224513a89c3a4d399a\r\n\r\nWith var/ver applied:\r\nde20549b5ca285228513a89c3a4d399a\r\n\r\nScript:\r\n\r\n```\r\n<?php\r\nconst UUID_NAMEBASED_NS_DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\r\n$namespace_uuid = str_replace('-', '', UUID_NAMEBASED_NS_DNS);\r\n$namespace_uuid = hex2bin($namespace_uuid);\r\n$hash = hash('xxh128', $namespace_uuid.'www.example.com');\r\necho \"$hash\\n\";\r\n$hash[12] = '8'; // version 8\r\n$hash[16] = dechex(hexdec($hash[16]) & 0b0011 | 0b1000); // Set variant to \"10xx\" (RFC4122)\r\necho $hash;\r\n```\r\n",
          "createdAt": "2023-09-20T23:05:27Z",
          "updatedAt": "2023-09-20T23:05:36Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> We were put in terrible conditions that we must ensure consensus. This is incorrect because responsibility for the quality of the RFC rests with the three authors who submitted the RFC for approval. But now one belated and picky person from the outside can impose his will on everyone else, and it is not clear how to please him. We are forced under pressure to add into the RFC a deliberately risky technical solution, the quality of which is below any criticism, because it\u2019s easier for someone to make a workaround in his information system.\r\n\r\nHi you can read https://www.rfc-editor.org/rfc/rfc7282 to understand what rough consensus means.\r\nIt is @jimfenton and my job to judge whether or not the various proposals here are in the rough or not.\r\nWe can't really do this in a github issue.  Thus the virtual interim meeting, at which, btw, there are no votes.\r\n\r\n",
          "createdAt": "2023-09-20T23:53:58Z",
          "updatedAt": "2023-09-20T23:53:58Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It makes sense to remove the hash space approach and put a single hash-based UUIDv8 example that naively follows the v3/v5 procedure with a modern hash algorithm (SHA256 in mind). That's simple, clear, useful, and sufficient as an example.\r\n\r\nBtw, what is the fate of the time-based UUIDv8 example? I think it's also useful as an example. If we spare 60 bits (`custom_a` + `custom_b`) for the nanosecond timestamp, now it takes 36 years to wrap around. If we also employ a custom epoch (e.g., nanoseconds elapsed since 1 Jan 2020), then the time-based example would be a simple and compact example that clearly demonstrates the properties that v1-v7 can not provide.\r\n\r\nWe can also add another example where a 64-bit external identifier is simply embedded in v8's payload, with implementation-specific `external_system_id` and `database_table_id` allocated in the remaining space.\r\n\r\nExamples are good. They illustrate when v1-v7 can not help and why v8 is introduced.\r\n",
          "createdAt": "2023-09-21T00:27:58Z",
          "updatedAt": "2023-09-21T00:27:58Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> Btw, what is the fate of the time-based UUIDv8 example?\r\n\r\n@LiosK\r\n\r\nI'm against UUIDv8 examples. With their help, we can hastily add unexplored Frankensteins to the RFC that we ourselves do not believe in. If we believed in them, they would be described in UUIDv7 and other non-custom versions, which have been carefully discussed. Implementers will implement these carelessly concocted examples as if these examples had undergone careful and expensive testing and development.\r\n\r\nAs for the nanosecond timestamp, it was rejected in the discussions because even with a time source with nanosecond precision, the counter is superior to the nanosecond timestamp in terms of space savings with the same monotonicity even with distributed generation.",
          "createdAt": "2023-09-21T06:28:40Z",
          "updatedAt": "2023-09-21T06:28:40Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's an extreme. The same logic holds for the hash-based v8 too and will ultimately remove all the v8 examples from the document. Examples are helpful for readers as they concisely convey our intention to introduce v8, which can't be expressed in the succinct normative description. Examples won't confuse readers as long as they are present clearly labeled as implementation examples.",
          "createdAt": "2023-09-21T12:43:39Z",
          "updatedAt": "2023-09-21T12:43:39Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> That's an extreme. The same logic holds for the hash-based v8 too and will ultimately remove all the v8 examples from the document. Examples are helpful for readers as they concisely convey our intention to introduce v8, which can't be expressed in the succinct normative description. Examples won't confuse readers as long as they are present clearly labeled as implementation examples.\r\n\r\nIn this case the examples of UUIDv8 (only!) must be accompanied by a disclaimer that the implementer can use these examples at his/her own risk, but the examples themselves are not recommended by the standard, have not been properly tested or examined, and their use may lead to errors in the information system.",
          "createdAt": "2023-09-21T13:00:55Z",
          "updatedAt": "2023-09-21T13:45:12Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI, in line with #150 thinking, I was planning to move the v8 \"test vectors\" to a new appendix titled \"illustrative examples\".\r\nThen put some leading text around how they are simply showing how one can use v8 and are not meant to be implemented (unless somebody really likes that logic.) and prefix with lots of \"use at your own risk\" text.\r\n\r\n@bradleypeabody, @bradleypeabody \r\n- My only suggestion for SHA-256 example over some other hashing library is that it is in the same NIST/FIPS specs as SHA-1 and easily transposable. That is, just like our v1 to v6 modification. There is little that needs to be done to illustrate the points and get the topic across.\r\n- Why not SHA-512 or some other? Luck of the draw I guess. That is what I already have a [test vector on in my notes](https://github.com/ietf-wg-uuidrev/rfc4122bis/blob/main/editor-files/UUIDv3-v5-Testing.md#sha256-testing-a-v9---5c146b14-3c52-9afd-938a-375d0df1fbf6). But I will be clear that this isn't the only possible option, just an illustrative example of how somebody could do this with a next gen hashing function in lieu of MD5/SHA-1. Plus [SHA-256 is PQC safe](https://datatracker.ietf.org/doc/html/draft-ar-pquip-pqc-engineers-03#name-recommendations-for-securit) so it should be okay for a while.\r\n- XOR/Filling zeros: Out of Scope, do what you must since it's v8. I am not sure we need to provide guidance explicit to this (there are also many other places in the doc where we truncate, modify, fill/pad, etc.) So folks who are inspired can find some helpful examples even if it is not explicitly for hash-based functions. \r\n\r\n---\r\n\r\nTimeline: Let me finish out some of these other early draft-12 tracker items for easier things. Then I will branch this off of the new draft 12 base. ETA Monday/next week as I let those other items in PR #152 bake.",
          "createdAt": "2023-09-21T13:38:50Z",
          "updatedAt": "2023-09-21T13:38:50Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Then put some leading text around how they are simply showing how one can use v8 and are not meant to be implemented (unless somebody really likes that logic.) and prefix with lots of \"use at your own risk\" text.\r\n\r\nIf it is not meant to be implemented, can it then be used as a reference for interoperability? (Well, technically, it can, if it gets its own appendix/section number that someone can refer to)\r\n\r\n> * My only suggestion for SHA-256 example over some other hashing library is that it is in the same NIST/FIPS specs as SHA-1 and easily transposable. That is, just like our v1 to v6 modification. There is little that needs to be done to illustrate the points and get the topic across.\r\n\r\n(Personal opinion) I am fine with either SHA-X or xxHash; I don't have a preference.  SHA-X is a bit more well-known and the truncation of extra bits could be illustrated in the example.  xxHash on the other hand is very fast and might be good for UUIDs.\r\n\r\n> * Why not SHA-512 or some other? Luck of the draw I guess. That is what I already have a [test vector on in my notes](https://github.com/ietf-wg-uuidrev/rfc4122bis/blob/main/editor-files/UUIDv3-v5-Testing.md#sha256-testing-a-v9---5c146b14-3c52-9afd-938a-375d0df1fbf6). But I will be clear that this isn't the only possible option, just an illustrative example of how somebody could do this with a next gen hashing function in lieu of MD5/SHA-1. Plus [SHA-256 is PQC safe](https://datatracker.ietf.org/doc/html/draft-ar-pquip-pqc-engineers-03#name-recommendations-for-securit) so it should be okay for a while.\r\n\r\n> * XOR/Filling zeros: Out of Scope, do what you must since it's v8. I am not sure we need to provide guidance explicit to this (there are also many other places in the doc where we truncate, modify, fill/pad, etc.) So folks who are inspired can find some helpful examples even if it is not explicitly for hash-based functions.\r\n\r\nSince it would be great to have it as a reference for interoperability, it would be good if it could be defined for hash algorithms < 128 bits. The developer needs to decide if they want to use that algorithm, though.\r\n\r\n> Timeline: Let me finish out some of these other early draft-12 tracker items for easier things. Then I will branch this off of the new draft 12 base. ETA Monday/next week as I let those other items in PR #152 bake.\r\n\r\nSounds good!\r\n",
          "createdAt": "2023-09-21T14:26:45Z",
          "updatedAt": "2023-09-21T14:26:45Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> https://mailarchive.ietf.org/arch/msg/uuidrev/dhxgO66xkpNBrOtSy0AY8nV9bAE/ @sergeyprokhorenko @danielmarschall @ben221199 @LiosK @chorman0773 If this matters, then please participate.\r\n\r\nhttps://notes.ietf.org/notes-ietf-interim-2023-uuidrev-04-uuidrev\r\n",
          "createdAt": "2023-09-21T17:58:14Z",
          "updatedAt": "2023-09-21T17:58:14Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> - XOR/Filling zeros: Out of Scope, do what you must since it's v8. I am not sure we need to provide guidance explicit to this (there are also many other places in the doc where we truncate, modify, fill/pad, etc.) So folks who are inspired can find some helpful examples even if it is not explicitly for hash-based functions.\r\n\r\nAgreed. Examples don't need to contain information for interoperability.\r\n\r\n@mcr, I cannot make the interim, unfortunately.\r\n",
          "createdAt": "2023-09-21T23:51:53Z",
          "updatedAt": "2023-09-21T23:51:53Z"
        },
        {
          "author": "chorman0773",
          "authorAssociation": "NONE",
          "body": "FTR, I do not consider a completely custom v8 useful for my identified use case, regardless of the examples provided for it.\r\nMy issue is with the fact it cannot be considered unique in the face of non-malicious uncontrolled code.",
          "createdAt": "2023-09-22T00:09:28Z",
          "updatedAt": "2023-09-22T00:11:42Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> FTR, I do not consider a completely custom v8 useful for my identified use case, regardless of the examples provided for it.\r\n> My issue is with the fact it cannot be considered unique in the face of non-malicious uncontrolled code.\r\n\r\nNo wonder. Huge efforts have been put into making UUIDv7 perfect. Therefore, there are no more useful ideas left for UUIDv8. The only purpose of UUIDv8 is not to limit the imagination of implementers. And it would be strange to advise them on this using examples.",
          "createdAt": "2023-09-22T05:48:36Z",
          "updatedAt": "2023-09-22T05:48:36Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "> My issue is with the fact it cannot be considered unique in the face of non-malicious uncontrolled code.\r\n\r\n@chorman0773 I don't follow. If you direct implementations to use UUIDv8 following the hash example provided, it should have approximately the same uniqueness probabilities as any other UUID (while also being hash-based).  What aspect of this makes the resulting UUID not/less unique?",
          "createdAt": "2023-09-22T06:38:21Z",
          "updatedAt": "2023-09-22T06:38:21Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "> > https://mailarchive.ietf.org/arch/msg/uuidrev/dhxgO66xkpNBrOtSy0AY8nV9bAE/ @sergeyprokhorenko @danielmarschall @ben221199 @LiosK @chorman0773 If this matters, then please participate.\r\n> \r\n> https://notes.ietf.org/notes-ietf-interim-2023-uuidrev-04-uuidrev\r\n\r\nI have to dive into how these meetings work. Don't know if I have time to participate, because I also have other work to do.",
          "createdAt": "2023-09-22T08:26:01Z",
          "updatedAt": "2023-09-22T08:27:10Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI, I have changed the title of the issue so it reflects the current state of this tracker item. ",
          "createdAt": "2023-09-22T13:59:49Z",
          "updatedAt": "2023-09-22T13:59:49Z"
        },
        {
          "author": "chorman0773",
          "authorAssociation": "NONE",
          "body": "> @chorman0773 I don't follow. If you direct implementations to use UUIDv8 following the hash example provided, it should have approximately the same uniqueness probabilities as any other UUID (while also being hash-based). What aspect of this makes the resulting UUID not/less unique?\r\n\r\nThe point of using UUIDs is that I don't need to provide any guidance to driver implementors beyond the UUID RFC except that they should not use the namespace `db4ec4af-a7b7-315b-8c02-bb928e3d4281` (which is the UUID for the OS itself) or UUIDs derive from it to derive (via any method) device IDs, as they may collide with future \"well-known\" devices. My main worry is that they'd use v8 time-based, or some other custom method for generating v8 IDs that ends up with the same result.",
          "createdAt": "2023-09-22T16:12:08Z",
          "updatedAt": "2023-09-22T16:12:24Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@chorman0773\r\n\r\nThe draft is clear that the UUIDv8's uniqueness MUST NOT be assumed, so in your case, if you do not provide guidance to driver implementers, then you must reject a v8 value from registering. You are also free to provide driver implementers with detailed v8 guidance specifying the structure and hash functions, just like you would provide namespace guidance for v3/v5. That's the \"implementation-specific\" exactly means.\r\n\r\nI see your case might want (though not require) a standardized hash-based ID definition, but it seems considerably difficult to achieve consensus for such a scheme, and in my opinion it needs a separate RFC project.",
          "createdAt": "2023-09-23T01:27:13Z",
          "updatedAt": "2023-09-23T01:27:13Z"
        },
        {
          "author": "chorman0773",
          "authorAssociation": "NONE",
          "body": "> The draft is clear that the UUIDv8's uniqueness MUST NOT be assumed, so in your case, if you do not provide guidance to driver implementers, then you must reject a v8 value from registering\r\n\r\nWell, strictly speaking, unless the device id is already in use or it's one of the two sentinel values (full is explicitly reserved, nil is \"Don't care, kernel assign device id\", the ID isn't going to be rejected, either for kernel mode drivers or user mode drivers. It's up to the individual drivers if they. The question is whether the kernel itself would use the IDs, not whether they'd be available for anything else to use.",
          "createdAt": "2023-09-23T02:33:16Z",
          "updatedAt": "2023-09-23T02:33:16Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@chorman0773 Since, from what I gather, you control at least the recommendation of what you're suggesting drivers do when generating a UUID, it seems like just providing a specific suggestion of what kind of UUID you recommend would work.\r\n\r\n> The point of using UUIDs is that I don't need to provide any guidance to driver implementors beyond the UUID RFC...\r\n\r\nWhy?  What prevents you from simply telling people who make drivers that the recommendation is to use UUID v3, 5 or v8 following the hash example, and they do something else there is a very small chance that the probability of collision increases. \r\n\r\n> My main worry is that they'd use v8 time-based, or some other custom method for generating v8 IDs that ends up with the same result.\r\n\r\nKeep in mind that there's only so much uniquness you're gong to get in a 128 bit value.  There physically no guarantees with any of the UUID versions that fully absolutely prevent collisions, all you can do is reduce the probability.  And if we assume that whatever other weird stuff people do with UUIDv8 is going to be roughly evenly distributed, it's easy to make the argument that your collision probabily doesn't increase.\r\n\r\nAnyway, this UUID v8 example looks like what we'll realistically be able to get into the RFC.  So if you want to help shape that, great, if not, that's fine too.\r\n\r\nALSO: Keep in mind that it takes various implementations and experience in order to end up with a new standard.  If enough people get behind it, then this v8 example could end up being v9 in a later update to the document, another reason to put effort into this v8 example - it's a starting point.",
          "createdAt": "2023-09-23T02:44:46Z",
          "updatedAt": "2023-09-23T03:43:19Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I have greatly reduced the complexity of the UUIDv8 Name/Hash based example in https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/a4f5693dc22513ac67dc059781f0fced5765db8e\r\n\r\nTo summarize this commit:\r\n- Removes Hashspace IDs and scrubs the document of their verbiage.\r\n- Changes the illustrative example in the final appendix to use JUST SHA-256 (e.g UUIDv5 with the only swaps being SHA-256 and the version bit to be v8)\r\n- Removes all text in name-based examples except that of UUIDv5 pointing to the illustrative example as guidance.\r\n\r\nAll-in-All this checks the box of:\r\n- Providing an implementor who may not be able to use SHA1/MD5 and still wants a UUID guidance on how to do so.\r\n- Provides some examples of how to do this (without as much heavy text in official name-based UUID generation sections.)\r\n- Provides a much simpler solution that somebody with knowledge of UUIDv5 can pick up easily. (I modified Python3 UUID.py in two lines and had this example running.)",
          "createdAt": "2023-09-28T16:58:22Z",
          "updatedAt": "2023-09-28T16:58:22Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kyzer-davis  Thank you very much for your work! I think it is very good to have this appendix with examples, and that the UUIDv8 are simplified by removing the hash-space.\r\n\r\nI have a few thoughts about https://github.com/ietf-wg-uuidrev/rfc4122bis/blob/hash-based-uuids/draft-ietf-uuidrev-rfc4122bis.md :\r\n\r\n> The examples below are not meant to be implemented\r\n\r\nI am not sure... doesn't this conflict with the idea of a reference for interoperability (which was discussed earlier)?\r\n\r\nIn other words: If one decides to implement SHA-256 UUIDv8 according to RFC xxx Appendix xxx, will they do a \"bad job\" if they implement something that is \"not meant to implemented\"?\r\n\r\n> These MAY leverage newer hashing protocols such as SHA-256 or SHA-512 defined by {{FIPS180-4}}, SHA-3 or SHAKE defined by {{FIPS202}}, or even protocols that have not been defined yet.\r\n\r\nI think it should mean hash algorithms and not hash protocols.\r\n\r\n> This UUIDv8 illustrative example utilizes a well-known 64 bit Unix epoch timestamp with nanosecond precision, truncated to the least-significant, right-most, bits to fill the first 48 bits through version.\r\n\r\nThe horrible example with \"one nanosecond in 48 bits\" is still there... Can't we assign more bits, or anything so that it wraps at least in each 35 years instead of just a few hours?\r\n",
          "createdAt": "2023-09-28T19:28:15Z",
          "updatedAt": "2023-09-28T19:45:18Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "For the time-based example, here are alternatives (I am keeping 1 nano second):\r\n\r\nA. `tttttttt-tttt-Xttt-rrrr-Xrrrrrrrrrrr` : 1 nano second in 60 bits = wraps after 36 years (`2^60/(1000*1000*1000*60*60*24*365)`), and has 62 bits are left for random (i.e. chance to collide is 1/2^62)\r\n\r\nB. `tttttttt-tttt-Xttt-trrr-Xrrrrrrrrrrr` : 1 nano second in 64 bits = wraps after 584 years (`2^64/(1000*1000*1000*60*60*24*365)`), and has 58 bits are left for random (i.e. chance to collide is 1/2^58)\r\n\r\nC. `tttttttt-tttt-Xttt-ttrr-Xrrrrrrrrrrr`: 1 nano second in 68 bits = wraps after 9359 years (`2^68/(1000*1000*1000*60*60*24*365)`), and has 54 bits are left for random (i.e. chance to collide is 1/2^54)\r\n\r\nD. `tttttttt-tttt-Xttt-tttt-Xrrrrrrrrrrr` : 1 nano second in 76 bits = wraps after 2395924 years (`2^76/(1000*1000*1000*60*60*24*365)`), and has 46 bits are left for random (i.e. chance to collide is 1/2^46)\r\n\r\nMy preferrence would be >=100 years, so 64 bit.\r\n",
          "createdAt": "2023-09-28T19:39:23Z",
          "updatedAt": "2023-09-28T19:50:30Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "In terms of hash-based items on https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1739887805\r\n- I can remove the \"The examples below are not meant to be implemented\" and change it to simply \"The examples below have not been through...\" Edit: changed in https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/158/commits/2a29aa0ef2b8f708ee38d3a849348bf9c2add8ef\r\n- Yeah, I should use algorithms, let me change that in a commit. Edit: changed in https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/158/commits/815fa114be66689a659b37881a6568f62fc28784\r\n\r\nTime comment: https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1739901324\r\n- I will take the convo about changing that to a different issue. I don't want threads to start crossing. Hang tight. Edit: Forked to #159 ",
          "createdAt": "2023-09-28T20:36:24Z",
          "updatedAt": "2023-09-28T20:45:23Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kyzer-davis Thank you! Looks good to me.",
          "createdAt": "2023-09-28T20:53:10Z",
          "updatedAt": "2023-09-28T20:53:10Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "I_kwDOH6Ln3M5xfNjq",
      "title": "Revise 16-bit MAC Node Usage",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/149",
      "state": "CLOSED",
      "author": "tgross35",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "> For systems with no IEEE address or utilizing an IEEE 802.15.4 16 bit address, a randomly or pseudo-randomly\r\ngenerated value MUST be used; see {{unguessability}} and {{unidentifiable}}.\r\nFor systems utilizing a 64 bit MAC address the least significant, right-most 48 bits MAY be used.\r\n\r\nWould it be better to say that 16-bit MACs and other MACs may use those 16 bits plus 32 random bits? Or otherwise weaken the `MUST`  such that shorter nonstandard MACs that still want a node identifier don't technically violate the spec.",
      "createdAt": "2023-09-20T02:57:08Z",
      "updatedAt": "2023-09-27T20:21:52Z",
      "closedAt": "2023-09-27T20:21:52Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, you could include the 16-bit mac.\r\nWe would need to provide some guidance around where somebody would place the extra 32 bits of random.\r\nE.g at the front  (Random+MAC) or at the end (MAC+Random) \r\nAnd with this in place does an implementation need to flip the MCAST bit?",
          "createdAt": "2023-09-20T17:57:41Z",
          "updatedAt": "2023-09-20T17:57:41Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "So, 16-bit MACs are assigned centrally (00,01,02,) so that they are easily compressible.\r\nEvery 802.15.4 system that might use a 16-bit MAC also has a 64-bit MAC, which is \"factory assigned\", so for UUIDs they should always use that.\r\n",
          "createdAt": "2023-09-20T18:50:39Z",
          "updatedAt": "2023-09-20T18:50:39Z"
        },
        {
          "author": "tgross35",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Maybe that defeats the purpose then. \"Must\" just seemed a bit strong for devices that do have an identifier but not a 32/64-bit MAC",
          "createdAt": "2023-09-20T19:04:14Z",
          "updatedAt": "2023-09-20T19:04:22Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Would it be better to remove it from the first sentence and leave the MUST for those with no identifier and add a new line that states something like:\r\n> Devices utilizing an IEEE 802.15.4 16 bit address SHOULD instead utilize their 64-bit MAC address where least significant, right-most 48 bits MAY be used. An alternative is to generate 32 bits of random data and postfix at the end of the 16 bit MAC address to create a 48 bit value.",
          "createdAt": "2023-09-20T19:41:54Z",
          "updatedAt": "2023-09-20T19:41:54Z"
        },
        {
          "author": "tgross35",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That sounds reasonable to me, as long as it doesn't throw a monkey wrench into the ongoing approval process",
          "createdAt": "2023-09-20T21:40:16Z",
          "updatedAt": "2023-09-20T21:40:16Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Modified in https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/602dbacbff2789185b7b8d9c94cf0f96199217e7\r\n",
          "createdAt": "2023-09-21T13:34:55Z",
          "updatedAt": "2023-09-21T13:34:55Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "For formatting/readability purposes via https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/a749513acf572e91517cf17de12226334871aa2f:\r\n- I removed this unneeded line: \"The lowest addressed octet (octet number 10) contains the global/local bit and the unicast/multicast bit, and is the first octet of the address transmitted on an 802.3/802.11 LAN.\" Edit, mostly because this is covered in 6.9 with better text.\r\n- In the previous text's place I cited section 6.8/6.9 since it was only called out at the end of the v1 section.\r\n- I moved the topic about selecting multiple addresses to the section grouping we have for no address, 16 bit and 64 bit. \r\n- I modified this ending section to a list which I think reads a bit better. \r\n\r\nLet me know what you all think.",
          "createdAt": "2023-09-21T15:53:45Z",
          "updatedAt": "2023-09-21T15:57:21Z"
        }
      ]
    },
    {
      "number": 150,
      "id": "I_kwDOH6Ln3M5xh167",
      "title": "Move UUIDv8 Examples out of Test Vectors",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/150",
      "state": "CLOSED",
      "author": "ben221199",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As seen in #144 and #147, the examples of UUIDv8 are a big issue. We should do something about it and rewrite or remove them. The reason is that the examples can now be seen as some call to action to implement them literally, and that is not what they are for.",
      "createdAt": "2023-09-20T10:34:49Z",
      "updatedAt": "2023-10-05T13:34:52Z",
      "closedAt": "2023-10-05T13:34:52Z",
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@ben221199 I'd like to see how #147 plays out, and then from there we can see if there is a new example that addresses the concerns from that issue, and/or if we want to remove or adjust any other examples.   Regarding #144, I'm hoping that if we are not going to create UUIDv9 as an official hash-based UUID version right now, and just stick with UUIDv8 example(s), then it should simplify the matter, hopefully.",
          "createdAt": "2023-09-20T19:45:08Z",
          "updatedAt": "2023-09-20T19:45:08Z"
        },
        {
          "author": "ben221199",
          "authorAssociation": "NONE",
          "body": "Okay clear. We will see.",
          "createdAt": "2023-09-20T19:53:27Z",
          "updatedAt": "2023-09-20T19:53:27Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Copying from the other thread:\r\n\r\n> I was planning to move the v8 \"test vectors\" to a new appendix titled \"illustrative examples\".\r\nThen put some leading text around how they are simply showing how one can use v8 and are not meant to be implemented (unless somebody really likes that logic.) and prefix with lots of \"use at your own risk\" text.",
          "createdAt": "2023-09-22T13:58:35Z",
          "updatedAt": "2023-09-22T13:58:35Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I have moved these out of test vectors and into their own appendix as per https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/150#issuecomment-1731471692, and added lots of \"here be dragons\" text in https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/020137452be6dcc225637f246319553e4c7ec384 and https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/2a29aa0ef2b8f708ee38d3a849348bf9c2add8ef",
          "createdAt": "2023-09-28T16:27:03Z",
          "updatedAt": "2023-09-28T20:59:20Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "I_kwDOH6Ln3M5xlRKM",
      "title": "Fix Randomized Node value's mcast bit in Appendix",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/151",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "I split this from from #140 and while I was reviewing the following statement I think there is a mistake in my test vector?\r\nWould somebody double-check? \r\n\r\n> Section 6.9: The discussion of the local/global bit here would be a good place to reference RFC 7042 or, even better, draft-ietf-intarea-ref4042bis.\r\n\r\nhttps://datatracker.ietf.org/doc/html/rfc7042\r\nNote: I am also not sure where/what to cite from this document.\r\n\r\nDraft-11 Text:\r\n> Implementations MUST set the least significant bit of the first octet of the node ID set to 1, to create a 48 bit node id. This bit is the unicast/multicast bit, which will never be set in IEEE 802 addresses obtained from network cards. Hence, there can never be a conflict between UUIDs generated by machines with and without network cards.\r\n> For compatibility with earlier specifications, note that this document uses the unicast/multicast bit, instead of the arguably more correct local/global bit because MAC addresses with the local/global bit set or not are both possible in a network. This is not the case with the unicast/multicast bit. One node cannot have a MAC address that multicasts to multiple nodes.\r\n\r\nCould somebody double check me here:\r\nFor the appendix examples, is `0x9E6BDECED846` okay for node or should I change to `0x9F6BDECED846`?\r\n```\r\n9E = 10011110\r\n9F = 10011111\r\n```\r\n\r\ntl;dr, the hex value should be x3, x7, xB, xF if that bit is set to 1 right? Bottom right square of this table:\r\nhttps://en.wikipedia.org/wiki/MAC_address#Ranges_of_group_and_locally_administered_addresses\r\n\r\n---\r\n\r\nPersonal Note: This section of RFC4122 has always confused me. I am open to change proposals that make those two paragraphs easier to understand by implementors. They currently stand as mostly the same from 4122 in draft-11.",
      "createdAt": "2023-09-20T19:27:44Z",
      "updatedAt": "2023-09-27T20:21:52Z",
      "closedAt": "2023-09-27T20:21:52Z",
      "comments": [
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Could somebody double check me here:\r\n> For the appendix examples, is 0x9E6BDECED846 okay for node or should I change to 0x9F6BDECED846?\r\n\r\n0x9**_E_**6BDECED846 = SAI (Unicast)\r\nhttps://misc.daniel-marschall.de/tools/uuid_mac_decoder/interprete_mac.php?mac=9E%3A6B%3ADE%3ACE%3AD8%3A46\r\n\r\n0x9**_F_**6BDECED846 = SAI (Multicast)\r\nhttps://misc.daniel-marschall.de/tools/uuid_mac_decoder/interprete_mac.php?mac=9F%3A6B%3ADE%3ACE%3AD8%3A46\r\n\r\nIt turns out that your example is a Standard Assigned Identifier (SAI), which only IEEE may use.\r\n\r\nThe correct \"legal\" way would be Administrative Assigned Identifier (AAI) which have the second nibble set to x2 (Unicast) or x3 (Multicast)\r\n\r\n0x9**_2_**6BDECED846  = AAI (Unicast)\r\nhttps://misc.daniel-marschall.de/tools/uuid_mac_decoder/interprete_mac.php?mac=92%3A6B%3ADE%3ACE%3AD8%3A46\r\n\r\n0x9**_3_**6BDECED846  = AAI (Multicast)\r\nhttps://misc.daniel-marschall.de/tools/uuid_mac_decoder/interprete_mac.php?mac=93%3A6B%3ADE%3ACE%3AD8%3A46",
          "createdAt": "2023-09-20T19:48:50Z",
          "updatedAt": "2023-09-21T14:28:02Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> Personal Note: This section of RFC4122 has always confused me. I am open to change proposals that make those two paragraphs easier to understand by implementors. They currently stand as mostly the same from 4122 in draft-11.\r\n\r\n@kyzer-davis What exactly are you confused about in this section? Maybe I can help simplify it.",
          "createdAt": "2023-09-20T22:02:38Z",
          "updatedAt": "2023-09-20T22:03:11Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, I modified `_random_getnode()` over on [Python's UUIDv1](https://github.com/python/cpython/blob/main/Lib/uuid.py#L607) Implementation so it always uses random.\r\nLine: https://gist.github.com/kyzer-davis/45cd2815b6c0bb9861a2a4f7de6d798a#file-uuid-py-L705\r\n\r\nI ran 40 or so UUIDv1 generations and they always had a value of 1 in that multicast bit section which was the entire bottom row of that Wikipedia table. Values `x1`, `x3`, `x5`, `x7`, `x9`, `xB`, `xD`, `xF` at the least significant bit of the first octet in the node.\r\nTesting File: https://gist.github.com/kyzer-davis/45cd2815b6c0bb9861a2a4f7de6d798a#file-testing-txt\r\nNote: I also printed the before/after modification so I could see if there was a change to the random data.\r\n\r\n---\r\n\r\nI then spoofed the `random.getrandbits` call to be that of my integer value for `9E6BDECED846` which is `174186136787014`\r\nThe result was then `174186136787014 | (1 << 40)` which converted to `175285648414790`\r\nWhen converting to hex it was in fact xF: `9F6BDECED846`\r\nLine: https://gist.github.com/kyzer-davis/45cd2815b6c0bb9861a2a4f7de6d798a#file-uuid-py-L613\r\n\r\n```\r\n>>> import uuid\r\n>>> print(uuid.uuid1())\r\n174186136787014\r\n175285648414790\r\n2aa8994f-588a-11ee-acef-9f6bdeced846\r\n>>>\r\n```\r\n\r\n---\r\nI whipped up a proposal below. \r\nThe text addition to Appendix C aims to make this a bit modification more clear. Then I can cite this up in the earlier text as a helper. Edit, added citation to RFC7042 like IESG wanted. Edit2. Forgot some modifications.\r\n```\r\ninformative:\r\n  RFC7042: RFC7042\r\n\r\n## UUIDs That Do Not Identify the Host {#unidentifiable}\r\n[..truncated..]\r\nThis bit is the unicast/multicast bit, which will never be set in IEEE 802\r\naddresses obtained from network cards.  Hence, there can never be a\r\nconflict between UUIDs generated by machines with and without network\r\ncards. \r\nAn example of this modification can be observed in {{test_vectors}} appendix.\r\nFor more information about IEEE 802 address and the unicast/multicast or local/global bits please review {{RFC7042}}.\r\n\r\n# Test Vectors {#test_vectors}\r\n[..truncated..]\r\nBoth UUIDv1 and UUIDv6 utilize the same values in clock_seq, and node. \r\nAll of which have been generated with random data. \r\nFor the randomized node, the least significant bit of the first octet set to a value of 1 as per {{unidentifiable}}. \r\nThus the starting value 0x9E6BDECED846 was changed to 0x9F6BDECED846. \r\nFigure {{randomizedNodeModify}} details the bit position and conversion of this bit where X is the value of the bit being modified from 0 to 1.\r\n\r\n~~~~\r\nOctet:      0        1        2        3        4        5 \r\nModify Bit: -------X -------- -------- -------- -------- --------\r\nStart:      10011110 01101011 11011110 11001110 11011000 01000110\r\nAfter:      10011111 01101011 11011110 11001110 11011000 01000110\r\n~~~~\r\n{: id='randomizedNodeModify' title='Example Bit Modification of Randomized Node'}\r\n\r\n## Example of a UUIDv1 Value {#uuidv1_example}\r\n[..truncated..]\r\nnode       48   0x9F6BDECED846\r\n\r\n## Example of a UUIDv6 Value {#uuidv6_example}\r\n[..truncated..]\r\nnode        48   0x9F6BDECED846\r\n```\r\nUpdate: starting octet to 0",
          "createdAt": "2023-09-21T14:49:08Z",
          "updatedAt": "2023-09-25T13:29:38Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Personally, I feel the most confusing thing in Section 6.9 is the word \"low\" in:\r\n\r\n> Implementations obtain a 47 bit cryptographic-quality random number as per Section 6.8 and use it as the *low* 47 bits of the node ID.\r\n\r\nIt's from the original RFC 4122, but still I don't really understand it.\r\n\r\n- - -\r\n\r\nThe C code in RFC 4122 suggests that `0x9E6BDECED846` should be `0x9F6BDECED846` for v1. But at the same time, I'm afraid that emphasizing the unicast/multicast bit too much in the test vector might mislead readers as if the unicast/multicast bit must be set to 1 for v6, too. My understanding is that the primary option for v6 is a fully random node ID that doesn't care the unicast/multicast bit.\r\n\r\nIs it possible to use `0x9E6BDECED846` for v6 and `0x9F6BDECED846` for v1? Saying like: \"Both UUIDv1 and UUIDv6 utilize the same random number, 0x9E6BDECED846, for node, but for UUIDv1 the least significant bit of the first octet is set to a value of 1 to illustrate Section 6.9.\" \r\n\r\n- - -\r\n\r\nNits: The octet number in the table should start from zero to follow the convention in the document or from 10 to indicate the actual location in the 128-bit space.",
          "createdAt": "2023-09-22T15:00:15Z",
          "updatedAt": "2023-09-22T15:00:15Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Personally, I feel the most confusing thing in Section 6.9 is the word \"low\" in:\r\n\r\nYeah, and Python just generates 48 then swaps the right one... I think I can edit that text to be as follows. \r\nThis is in line with how it is done in v4. e.g Generate 128 and change the 6 bits that matter.\r\n\r\n---\r\n\r\nv1/v6 follow same rules on Node ID so they both adhere to 6.9 for random. More specifically that bit.\r\n\r\nAs for over-emphasizing, I get it. I can skip that diagram. I was hoping to help clarify exactly where but if the text is clear to others (minus some minor changes proposed here.) I can simply skip all that fluff and just fix the value.\r\n\r\n---\r\n\r\nAs for 0 vs 1. I updated the proposed text to start at 0.\r\n\r\n",
          "createdAt": "2023-09-25T13:37:42Z",
          "updatedAt": "2023-09-25T14:19:20Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, I fixed this in https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/152/commits/db976a54fe261176502f8ed39891b21afc1d432c\r\n\r\nNote: I opted to drop my ASCII bit table. I think the bit modification is sufficiently covered now (and fixes my error in the test vector) and cites the RFC the IESG wanted.",
          "createdAt": "2023-09-25T14:25:00Z",
          "updatedAt": "2023-09-25T14:25:00Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> v1/v6 follow same rules on Node ID so they both adhere to 6.9 for random. More specifically that bit.\r\n\r\nThough I don't have a strong opinion on the test vectors, using `0x9E6BDECED846` for v6 will help clarify Section 5.6. It reads v6 SHOULD use full 48-bit random refreshed every time for node but MAY follow Section 5.1 (and 6.9 accordingly). So v6 MAY follow Section 6.9 but SHOULD depart from it, right?",
          "createdAt": "2023-09-25T18:13:10Z",
          "updatedAt": "2023-09-25T18:13:10Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@LiosK, that is interpretation is correct as the text currently reads in draft-11 (and current draft-12) section 5.6.",
          "createdAt": "2023-09-26T14:43:23Z",
          "updatedAt": "2023-09-26T14:43:23Z"
        }
      ]
    },
    {
      "number": 153,
      "id": "I_kwDOH6Ln3M5xlyDi",
      "title": "Add MSB3 to Variant Table",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/153",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Split from #145, obviously this spec only cares about two-bits `1` and `0` but re-uses the table from RFC4122.\r\nThe final value of the \"three bit variant\" is don't care. thus `10x`\r\nHowever, the hex that gets converted is a 4 bit value. Thus later some text I wrote discussed the possible Hex values for the `10x` variant. Which is really `10xx`\r\n\r\nI was reviewing the comment from OPSDIR and trying to figure out how to call out this 4th \"don't care bit\"...\r\n\r\n```\r\n(2) p 14, sec 4.2.  Version Field\r\n\r\n      Table 2: UUID variant 10x versions defined by this specification\r\n   An example version/variant layout for UUIDv4 follows the table where\r\n   M represents the version placement for the hexadecimal representation\r\n   of 0x4 (0b0100) and the N represents the variant placement for one of\r\n   the four possible hexadecimal representation of variant 10x: 0x8\r\n   (0b1000), 0x9 (0b1001), 0xA (0b1010), 0xB (0b1011)\r\n\r\nTable 1 only defines 3 bits and doesn't obviously mention a 4th bit, and yet\r\nthe examples below are displaying 4 bits, where I assume that the 4th bit is\r\neffectively arbitrary data in the UUID definition.  Please consider whether it\r\nwould be helpful to clarify this.\r\n```\r\n\r\nMy solution \r\n- Add another don't care bit to the table in MSB3 position (and call out the possible hex Values in a column as well.)\r\n  - As far as I can see this wouldn't cause any problems as it does not change any values.\r\n\r\nThus:\r\n```\r\n{{table1}} lists the contents of the variant field, where the letter \"x\" indicates a \"don't-care\" value.\r\n\r\n| Msb0 | Msb1 | Msb2 | Msb3 | Hex     |Description                                                                    |\r\n|    0 |    x | x    | x    | 1-7     |Reserved, NCS backward compatibility and includes Nil UUID as per {{niluuid}}. |\r\n|    1 |    0 | x    | x    | 8-9,A-B |The variant specified in this document.                                        |\r\n|    1 |    1 | 0    | x    | C-D     |Reserved, Microsoft Corporation backward compatibility.                        |\r\n|    1 |    1 | 1    | x    | E-F     |Reserved for future definition and includes Max UUID as per {{maxuuid}}.       |\r\n```\r\n",
      "createdAt": "2023-09-20T21:13:53Z",
      "updatedAt": "2023-09-27T20:21:53Z",
      "closedAt": "2023-09-27T20:21:53Z",
      "comments": []
    },
    {
      "number": 154,
      "id": "I_kwDOH6Ln3M5xqr9z",
      "title": "Clarify  \"Name-Based\" is the same as \"Hash-Based\"",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/154",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Tracker item so I don't forget",
      "createdAt": "2023-09-21T13:41:12Z",
      "updatedAt": "2023-10-05T13:34:52Z",
      "closedAt": "2023-10-05T13:34:52Z",
      "comments": [
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "Also don't forget to include a note that they are synonymous in the context of UUIDs and \"name-based\" is still a valid word to maintain \"historical correspondence\" (I don't know what to call it) with the old RFC-4122.\r\n\r\nThe only difference between the two adjectives is the concept referenced by each term. The first refers to the input argument, that is, the \u201cname\u201d; while the new one makes reference to the mechanism employed, that is, the hash algorithm.\r\n\r\nSome very popular libraries use the old term in method names. A notable example is JUG's [`Generators.nameBasedGenerator()`](https://javadoc.io/doc/com.fasterxml.uuid/java-uuid-generator/4.0.1/com/fasterxml/uuid/impl/NameBasedGenerator.html).\r\n",
          "createdAt": "2023-09-21T22:05:25Z",
          "updatedAt": "2023-09-21T22:19:21Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, good point.",
          "createdAt": "2023-09-22T13:11:46Z",
          "updatedAt": "2023-09-22T13:11:46Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Mauling this over a bit more. Its a matter of semantics and IMO, I am not entirely sure it is worth the change (at least this far into the doc.)\r\nThis is similar to how we didn't change \"nil uuid\" to \"min uuid\" back under some other issue tracker. \r\nHistorically speaking we wanted to keep things consistent and I think we should use the same approach here.",
          "createdAt": "2023-09-22T13:55:50Z",
          "updatedAt": "2023-09-22T14:01:38Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "My personal opinion is keeping it name-based (including the name of the UUIDv8 example), because the term is very old and used in a lot of implementations.\r\n\r\nGoogling `\"name based\" uuid` results in 37.100 pages.\r\n",
          "createdAt": "2023-09-22T14:14:28Z",
          "updatedAt": "2023-09-22T14:14:28Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "So let's keep the old name. I completely agree, although I believe hash-based is clearer. Perhaps a small footnote that both terms are acceptable would suffice.\r\n\r\nP.S.: we don't want to anger the implementers of existing solutions. \ud83d\ude04 ",
          "createdAt": "2023-09-22T14:31:18Z",
          "updatedAt": "2023-09-22T14:38:24Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "Suggestion:\r\n\r\n_Although some prefer to use the word \u201chash-based\u201d, we use the adjective \u201cname-based\u201d here to maintain consistency with previous documents and existing implementations. However, we do not distinguish between the two terms since they both refer to the same thing._\r\n\r\nWell, it doesn\u2019t fall into the \u201csmall footnote\u201d category, as it is a long paragraph. But it's just an idea.",
          "createdAt": "2023-09-22T15:06:08Z",
          "updatedAt": "2023-09-23T18:23:01Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> The only difference between the two adjectives is the concept referenced by each term. The first refers to the input argument, that is, the \u201cname\u201d; while the new one makes reference to the mechanism employed, that is, the hash algorithm.\r\n\r\nBut input argument may be integer or multiple fields, including date, not name at all. In this case \"name-based\" is wrong\r\n\r\n\"Name-based\", in turn, does not necessarily mean using a hash function. It could just be a concatenation\r\n\r\nI'm against having sugar label on a can of lentils, even if that's historically the case. Let there be a name that matches the meaning: hash-based",
          "createdAt": "2023-09-22T20:42:08Z",
          "updatedAt": "2023-09-22T20:59:16Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "> But input argument may be integer...\r\n\r\nYes, it can be anything.\r\n\r\n> I'm against having sugar label on a can of lentils, ...\r\n\r\nI also hate it when I find beans in a tub of ice cream in the fridge. But in this case, the benefit obtained from the change is irrelevant. At the end of the day, it's just a name, and most of us are used to it. Furthermore, it's not cool to fall into yet another endless semantic discussion in the final minutes of the match.\r\n\r\nP.S. IMHO.",
          "createdAt": "2023-09-22T21:55:00Z",
          "updatedAt": "2023-09-22T22:11:11Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> > But input argument may be integer...\n> \n> \n> \n> Yes, it can be anything.\n> \n> \n> \n> > I'm against having sugar label on a can of lentils, ...\n> \n> \n> \n> I also hate it when I find beans in a tub of ice cream in the fridge. But in this case, the benefit obtained from the change is irrelevant. At the end of the day, it's just a name, and most of us are used to it. Furthermore, it's not cool to fall into yet another endless semantic discussion in the final minutes of the match.\n> \n> \n> \n> P.S. IMHO.\n\nNot everyone has such a habit of the name. They read the standard literally, and this can lead to errors",
          "createdAt": "2023-09-23T11:35:26Z",
          "updatedAt": "2023-09-23T11:35:26Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I can add a line about hash-based vs name-based meaning the same thing. I will do it in the branch with all the other hash-based/named-based changes.\r\nGive me a sec. Does it work if I place it at the start of \"Name-Based UUID Generation\" section that way I don't have to double text?",
          "createdAt": "2023-09-25T14:15:33Z",
          "updatedAt": "2023-09-25T14:15:33Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Added, https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/154#issuecomment-1731579688,  to new branch via https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/11fecf8b634720a378eef5377ab4b76f1798e954",
          "createdAt": "2023-09-28T15:56:45Z",
          "updatedAt": "2023-09-28T15:56:45Z"
        }
      ]
    },
    {
      "number": 155,
      "id": "I_kwDOH6Ln3M5xsKos",
      "title": "Discuss why v3/v5 are bad for Database Usage",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/155",
      "state": "CLOSED",
      "author": "sergeyprokhorenko",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "I propose to add this paragraph to the Section 2.1. Update Motivation:\r\n\r\n> 7. Hash-based UUID versions such as UUIDv3 (described in Section 5.3) and UUIDv5 (described in Section 5.5) can change their value over time as the hash function argument can unexpectedly change. This makes it difficult to use them as primary keys, including in the Data Vault modeling method.",
      "createdAt": "2023-09-21T17:02:27Z",
      "updatedAt": "2023-10-20T13:55:31Z",
      "closedAt": "2023-10-20T13:55:31Z",
      "comments": [
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "FYI, [Daniel Linstedt](https://en.wikipedia.org/wiki/Dan_Linstedt), author of the Data Vault modeling method, is considering replacing hash keys with UUIDv7 if the following conditions are met:\r\n1. UUIDv7 is available cross-platform in the database management systems that people use around the world\r\n2. Technical spec sheets are provided\r\n3. Large-scale performance testing done\r\n4. The results are published on the forums (https://github.com/uuid6/uuid6-ietf-draft/issues/128)\r\n5. There must be open list as to which platforms support this, and which don't (https://github.com/uuid6/uuid6-ietf-draft/issues/129)\r\n6. There are installation and configuration instructions on how to add the functionality to a specific platform",
          "createdAt": "2023-09-21T17:39:30Z",
          "updatedAt": "2023-09-21T17:43:35Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I was mauling over if it was worth discussing hash-based in update motivation at all. \r\n\r\nTo be honest that section is from when we were trying to add v6, v7, v8. There are many items I could add as it pertains to rewriting 4122 in the update motivations (bit layouts for all, implementation best practices, hashing info, new security guidelines, better formatting, etc, etc.) but IMO I don't think they are needed now. The document has been updated and the point is somewhat moot.",
          "createdAt": "2023-09-22T13:18:23Z",
          "updatedAt": "2023-09-22T13:19:16Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@kyzer-davis\r\n\r\nIt seems to me that it is still worth adding the proposed paragraph **or alternative**. This is not a matter of controversy, which you would reasonably want to avoid. The fact is that the main area of application of UUID is [data warehouse](https://en.wikipedia.org/wiki/Data_warehouse) (DWH), especially in banks. The main method for modeling DWH is [Data Vault](https://en.wikipedia.org/wiki/Data_vault_modeling). Data Vault recommends using hash keys generated from composite business keys as primary keys. Many large banks use Data Vault, but use integer keys (auto-increment) instead of hash keys, because hash keys are not really suitable as primary keys. This is a defect in the DWH modeling method. The Data Vault author cannot afford to recommend UUIDv7 until UUIDv7 is widely adopted. The proposed paragraph provides guidance in choosing a UUIDv7 version for DWH.\r\n\r\nAs **an alternative**, I might suggest adding to the [Section 6.12. DBMS and Database Considerations](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-11.html#name-dbms-and-database-considera) new last paragraph:\r\n\r\n> In data warehouses, it is recommended to use UUIDv7 generated by the DBMS whenever possible. Hash-based UUIDs are not recommended because they change their value when the hash function argument changes unexpectedly.",
          "createdAt": "2023-09-22T15:50:57Z",
          "updatedAt": "2023-09-22T16:05:52Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "v3 and v5 are stable. The new RFC won't change that fact. We shouldn't add a paragraph that puts it in doubt.",
          "createdAt": "2023-09-23T02:26:21Z",
          "updatedAt": "2023-09-23T02:26:21Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> v3 and v5 are stable. The new RFC won't change that fact. We shouldn't add a paragraph that puts it in doubt.\r\n\r\nUse v3 and v5 outside data warehouses. We can add a phrase that previously generated UUIDs of any version do not need to be recoded to UUIDv7.\r\n\r\nThe vast majority of developers put any UUID in doubts. They use auto-increment (integers). Now let's pray for auto-increment like for v3 and v5?\r\n\r\nIf you google you will see that everyone is looking forward to UUIDv7, although they have had the opportunity to use v3 and v5 for 18 years.",
          "createdAt": "2023-09-23T09:09:10Z",
          "updatedAt": "2023-09-23T09:57:37Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "You know everyone is waiting for v7, so we can neutrally introduce v7. Many people will just adopt v7. You don't need to be mean to v3/v5 at all.\r\n\r\nv7 and v3/v5 solve different problems. Implementers will pick one up based on their criteria. We don't need to lecture or steer them towards v7.\r\n\r\nPlus, you don't need to pray for auto-increment keys. Where applicable, a 32-bit auto-increment key can be way better off than v7 because it takes only 1/4 space of v7, which leads to much better index size and locality. Personally, I don't really understand why you stick to v7 so much in the DWH area. Auto-increment keys seem much better than v7 when decentrality is not the requirement.\r\n",
          "createdAt": "2023-09-23T11:00:35Z",
          "updatedAt": "2023-09-23T11:00:35Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> You don't need to be mean to v3/v5 at all.\n\nYou need to read my argument about Data Vault again.",
          "createdAt": "2023-09-23T11:15:20Z",
          "updatedAt": "2023-09-23T11:15:20Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Read it and came to the same conclusion. You don't need to be mean to v3/v5. If v3/v5 are not useful, implementers just don't use them, no matter what the RFC says.",
          "createdAt": "2023-09-23T11:19:45Z",
          "updatedAt": "2023-09-23T11:19:45Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> We don't need to lecture or steer them towards v7.\n\nThe main goal of any standard is to steer people. But the true goal of this standard is popularisation of v7 because perfect ULIDs have not support from a standard and therefore ULIDs are not so popular.",
          "createdAt": "2023-09-23T11:21:43Z",
          "updatedAt": "2023-09-23T11:22:23Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> the true goal of this standard is popularisation of v7\r\n\r\nSo the new RFC introduces v7 as a rigid standard. That's it. What else? ",
          "createdAt": "2023-09-23T11:24:17Z",
          "updatedAt": "2023-09-23T11:24:17Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> Personally, I don't really understand why you stick to v7 so much in the DWH area. Auto-increment keys seem much better than v7 when decentrality is not the requirement.\n\nI cannot express my 20 years experience in one answer. You have to believe. Auto-increment sooner or later leads to chaos.",
          "createdAt": "2023-09-23T11:25:26Z",
          "updatedAt": "2023-09-23T11:28:26Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> > the true goal of this standard is popularisation of v7\n> \n> \n> \n> So the new RFC introduces v7 as a rigid standard. That's it. What else? \n\nPopularisation! It's not enough to add v7 to the text. We need to describe its advantages and application\n",
          "createdAt": "2023-09-23T11:41:22Z",
          "updatedAt": "2023-09-23T11:41:22Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> Read it and came to the same conclusion. You don't need to be mean to v3/v5. If v3/v5 are not useful, implementers just don't use them, no matter what the RFC says.\n\nImplementers and their bosses obey standards because don't want to be fired",
          "createdAt": "2023-09-23T11:45:00Z",
          "updatedAt": "2023-09-23T11:45:00Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "An RFC is not an ad but is a technical standard. It must focus on the technical point of view. Biased favor to v7 without rigid technical grounds will harm the overall integrity of the new RFC. UUIDv7 isn't the single almighty identifier methodology for DWH or any other use cases; every identifier scheme has its own advantages, disadvantages, and use cases. An RFC must not steer everyone to v7 where v7 might not be the best option for their specific use cases. This attitude would be even more important if implementers and their bosses were to obey standards.",
          "createdAt": "2023-09-23T12:41:02Z",
          "updatedAt": "2023-09-23T12:41:02Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> An RFC is not an ad but is a technical standard. It must focus on the technical point of view. Biased favor to v7 without rigid technical grounds will harm the overall integrity of the new RFC. UUIDv7 isn't the single almighty identifier methodology for DWH or any other use cases; every identifier scheme has its own advantages, disadvantages, and use cases. An RFC must not steer everyone to v7 where v7 might not be the best option for their specific use cases. This attitude would be even more important if implementers and their bosses were to obey standards.\n\nThese are arguments like \"any shitcode has the right to exist if the developer likes it so much. It's nothing that billions are spent on correcting defects. You can't ban the recipes of healers and advertise evidence-based medicine!\"\n\nAs for the technical point of view, I repeat: hash-based UUIDs are not recommended because they change their value when the hash function argument changes unexpectedly. I have not received any justified objections to this claim.",
          "createdAt": "2023-09-23T14:39:14Z",
          "updatedAt": "2023-09-23T14:46:48Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't understand this discussion. Name-based have a completely different use case than time-based and random-based.\r\nIf name-based is useful or not completely depends on which application you are working. If you are working a lot with Data Warehouse, then it is your preferred UUID version.\r\n\r\nIf the input of a name-based UUID changes, then the output changes. Yes. That is stating the obvious.\r\n\r\nThat being said, personally I prefer UUIDv6 over UUIDv7 due to the better time resolution, plus I think including the MAC identifying the generating system is a pro not a con, especially when debugging.\r\nIf you genereate UUIDv7 in a batch script you have to include a 1ms delay to make sure that the IDs are really ordered. 1ms is a long time if you do batch processing of a bunch of data (DWH?)...\r\n",
          "createdAt": "2023-09-23T14:47:43Z",
          "updatedAt": "2023-09-23T14:47:43Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> every identifier scheme has its own advantages, disadvantages, and use cases\r\n\r\nThis statement is completely contrary to reality. UUIDv7 was created precisely to eliminate the terrible disadvantages of previous versions. Because of these disadvantages, UUIDs are not widely used as database keys. You won't find any advantage of other versions over UUIDv7. The exception is cases when hash-based UUID allows you to quickly bungle an unreliable information system. It would be correct to deprecate previous versions, but this is impossible to do, since it is necessary to support legacy systems.",
          "createdAt": "2023-09-23T15:12:06Z",
          "updatedAt": "2023-09-23T15:12:06Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@danielmarschall\r\n\r\n> If you are working a lot with Data Warehouse, then it is your preferred UUID version.\r\n\r\nIt's not my opinion only. UUIDv7 is objectively the best for Data Warehouses.\r\n\r\n> If the input of a name-based UUID changes, then the output changes. Yes. That is stating the obvious.\r\n\r\nIt's right. I was waiting for this from @LiosK \r\n\r\n> That being said, personally I prefer UUIDv6 over UUIDv7 due to the better time resolution\r\n\r\nNo. UUIDv7 with counter has better time resolution than UUIDv6. But they have both the same locality in DBMS. This means the same performance\r\n\r\n> plus I think including the MAC identifying the generating system is a pro not a con, especially when debugging.\r\n\r\nNo. Mac addresses are not unique and they pose a cyber threat\r\n\r\n> If you genereate UUIDv7 in a batch script you have to include a 1ms delay to make sure that the IDs are really ordered.\r\n\r\nNo. Absolute monotony is impossible and unnecessary. So no delays\r\n\r\n",
          "createdAt": "2023-09-23T15:29:04Z",
          "updatedAt": "2023-09-23T15:29:44Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > If the input of a name-based UUID changes, then the output changes. Yes. That is stating the obvious.\r\n> \r\n> It's right. I was waiting for this from @LiosK\r\n\r\nPerhaps, I misread this point. Yes, the hash output changes if the input changes. Hash-based versions are not recommended for use cases where the input may change. That's self-evident from the spec, and we don't need to add any paragraph. For the other use cases (including some DWH), v3/v5 is viable. It's up to implementers to choose the best solutions for their problems.\r\n\r\n> These are arguments like \"any shitcode has the right to exist if the developer likes it so much. It's nothing that billions are spent on correcting defects. You can't ban the recipes of healers and advertise evidence-based medicine!\"\r\n\r\nOther UUID versions as well as auto-increment keys are not sh*t code. They have different use cases and solve different problems.\r\n\r\nThat said, what's wrong with sh*t code? It's up to implementers. It's their freedom. An RFC is not for kindergarten kids. You don't need to lecture them.\r\n\r\nI know how much you love v7. But v7 is just one of many right tools to solve specific problems, and so are other alternatives. It shouldn't be a goal of the new RFC to build a v7 empire in the DWH world, or in other words, few people contributing to the project will agree with that direction.\r\n\r\n",
          "createdAt": "2023-09-23T23:31:59Z",
          "updatedAt": "2023-09-23T23:31:59Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> This statement is completely contrary to reality.\r\n\r\nNo. As @LiosK agrees with me, there are several use-cases for several UUID versions.\r\n\r\nBasically, I think there are two types of UUIDs (and possibly just two categories of use cases):\r\n- v1, v4, v6, v7 are like \"Push the button and you will receive a unique number\", and I think that v6+v7 are the best ones in that category and serve a lot of use cases like creation of database indexes or identifiers for objects.\r\n- v2, v3, v5 are like a function that requires input, and **where the UUID is only as unique as the input is**. Use cases can be \"[I already have an identifier (e.g. an OID) but I really need an UUID](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1725199412)\", and v3/v5 can shape that OID into an UUID.\r\n- v8 can be either case 1 or case 2, depending on the implementation\r\n\r\n> The fact is that the main area of application of UUID is [data warehouse](https://en.wikipedia.org/wiki/Data_warehouse) (DWH), especially in banks.\r\n\r\nUUIDs are used in nearly every software project in this world, not just data warehouse. I don't know if there is a statistic of the \"top 10 use cases\", but I think one of the most important are the GUIDs for Microsoft COM. Without the thousands of pre-installed COM interfaces on each system, Windows wouldn't even boot.\r\n\r\n> That being said, personally I prefer UUIDv6 over UUIDv7 due to the better time resolution, plus I think including the MAC identifying the generating system is a pro not a con, especially when debugging.\r\nIf you genereate UUIDv7 in a batch script you have to include a 1ms delay to make sure that the IDs are really ordered. 1ms is a long time if you do batch processing of a bunch of data (DWH?)...\r\n\r\nIn re my previous comment about time resolution of UUIDv7, I retract that argument because I learned about the sub-millisecond bits. Occuping 12 more time bits results in a resolution of 245 nanoseconds which is very nice.\r\n\r\nI still love machine identifiers in my UUID though, and EUI are unique. I am just assuming that every machine has a network card. I think I never saw a computer without network card before (except for my first DOS computer), and probably you can't even buy a computer without network card today, because they are already included on the mainboard.\r\n",
          "createdAt": "2023-09-24T07:48:06Z",
          "updatedAt": "2023-09-24T07:49:50Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@danielmarschall\r\n\r\n> EUI are unique\r\n\r\nNo. It turned out that some motherboards can have the same MAC addresses: https://www.networkworld.com/article/2340364/are-mac-addresses-really-unique-.html",
          "createdAt": "2023-09-24T08:22:07Z",
          "updatedAt": "2023-09-24T08:28:59Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@LiosK\r\n\r\n> Hash-based versions are not recommended for use cases where the input may change. \r\n\r\nI'm glad that you don't deny the obvious now\r\n\r\n> For the other use cases (including some DWH), v3/v5 is viable.\r\n\r\nNo. DWH is exactly the use case where any identifier (i.e. input of hash function) can change. No one is immune from changing identifiers. This is confirmed by many years of practice. Nothing is perfect and unchangeable. Billions are being spent on finding errors and making changes.\r\n\r\nBut the variability of identifiers is not at all obvious, so the requirement not to use hash-based UUIDs for DWH should be written into the RFC.\r\n\r\n> It's up to implementers to choose the best solutions for their problems... That said, what's wrong with sh*t code? It's up to implementers. It's their freedom. An RFC is not for kindergarten kids. You don't need to lecture them.\r\n\r\nNo. This is a standard, not a supermarket, where you can choose whatever you want. For example, you cannot choose the unit of length in the documentation: meter, feet or parrot.\r\n\r\nThe customer doesn't want to buy shitty code. The customer wants to insure against the arbitrariness of the contractor, and therefore demands compliance with the standard. If the standard says \"do what you want\", then such a standard is useless, and a voluminous and precise specification will be used instead. The value of UUID will be devalued, as it already was 18 years ago.\r\n\r\n> Few people contributing to the project will agree with that direction.\r\n\r\nI don't think so. And by the way, voting cannot change reality. And the authors and those who approve the RFC, not the contributors, bear responsibility for the quality of the RFC.",
          "createdAt": "2023-09-24T09:15:17Z",
          "updatedAt": "2023-09-24T09:40:58Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> DWH is exactly the use case where any identifier (i.e. input of hash function) can change.\r\n\r\nIt depends on individual DWHs. It's the DWH designer's responsibility to choose a right identifier scheme for their own DWH.\r\n\r\n> The customer wants to insure against the arbitrariness of the contractor, and therefore demands compliance with the standard.\r\n\r\nThe customer can simply say \"use UUIDv7\". The standard is just there. That's enough. I have no idea what problem you are solving.\r\n",
          "createdAt": "2023-09-24T10:24:18Z",
          "updatedAt": "2023-09-24T10:24:18Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I modified the title of this one to cover the topic of the issue. \r\n\r\nTo note, I did make some proposed changes via https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/529860f21c3b4da22210ebd35a083c7c27e4225a but these have been removed for the time being.\r\nThe idea was to call out how v3/v5, with inputs that change could cause bad performance to a database.\r\n\r\nIMO not as an author, I am not sure this is entirely needed but the commit itself covers the point (which is more or less the same as v4 in terms of impact on a database.) So it fit nicely in bullet 1 of update motivations. \r\n\r\nAgain, this time as an author, I want to re-iterate, we should not overthink/over-iterate on this. Weigh the pros/cons of having this in the doc vs not having it in the doc.",
          "createdAt": "2023-09-27T20:21:12Z",
          "updatedAt": "2023-09-27T20:21:12Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "Explanations:\r\n\r\nhttps://github.com/ietf-wg-uuidrev/rfc4122bis/issues/157#issuecomment-1737799318\r\n\r\nhttps://github.com/ietf-wg-uuidrev/rfc4122bis/issues/157#issuecomment-1737958679",
          "createdAt": "2023-10-09T08:19:11Z",
          "updatedAt": "2023-10-09T08:19:11Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "My take on this is I think it's fair point that database designers are tempted to use hash-based UUIDs because of their existence, but then later find out that this is a bad design choice because inputs they thought would not change actually do.  I've run into this myself a number of times.\r\n\r\nThat said, since we're not removing v3/v5 from the spec, it's physically possible for people to use hash-based IDs in databases - the only control we have over the process is what advice we give in the RFC.  So it boils down to the same thing: what do we want to say about this in the document?\r\n\r\nHow about adding this paragraph to the \"[DBMS and Database Considerations](https://github.com/ietf-wg-uuidrev/rfc4122bis/blob/main/draft-ietf-uuidrev-rfc4122bis.md#dbms-and-database-considerations-database_considerations)\" section:\r\n\r\n**Designers of database schema are cautioned against using hash-based UUIDs as primary keys in tables.  A common issue that has been observed in database schema design is the assumption that a particular value will never change, which then later turns out to be an incorrect assumption.  Postal codes, license or other identification numbers, and numerous other such identifiers, even those which seem or maybe even are unique and unchanging at a given point time, can then later turn out to have edge cases where they need to change, thus invalidating your database structure. In such scenarios it is noted that using any non-hash-based UUID version would have resulted in the field in question being placed somewhere (not as a primary key) that would have been easier to adapt to such changes.  The same arguments that result in the general advice to use surrogate keys instead of natural keys apply here as well.**\r\n\r\n(It would be nice, although not necessarily required, to cite a good source for this advice, something a bit more authoritative than wikipedia.)",
          "createdAt": "2023-10-09T22:08:19Z",
          "updatedAt": "2023-10-09T22:22:04Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, didn't mean to close.  Somehow I hammered the wrong button.",
          "createdAt": "2023-10-09T22:22:31Z",
          "updatedAt": "2023-10-09T22:22:31Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "I would only change the word **hash**-based for **name**-based according to https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/154.",
          "createdAt": "2023-10-10T10:45:35Z",
          "updatedAt": "2023-10-10T10:45:35Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I took @bradleypeabody's text, modified it a bit to fit the document and added it to the end of the section.\r\nSee https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/168/commits/ea92c30b98719cb0fdd77a29f6fd2a26714575c4\r\n\r\nWill check next week on any text changes. \r\nMy personal deadline for Draft-13 back to IETF is Oct 20th.",
          "createdAt": "2023-10-13T14:58:11Z",
          "updatedAt": "2023-10-13T14:58:11Z"
        }
      ]
    },
    {
      "number": 157,
      "id": "I_kwDOH6Ln3M5x1nAm",
      "title": "Additional Update Motivations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/157",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For example:\r\n\r\n> The fact that UUIDs can be used to create unique, reasonably short values in distributed systems without requiring coordination makes them a good alternative, but UUID versions 1-5<ins>, which were defined by {{RFC4122}},</ins> lack certain other desirable characteristics:\r\n\r\nIt's an obvious fact for us, but that might not be the case decades later....\r\n\r\n**EDIT**: I've got wondering that a concise text stating that the new RFC adds v6/v7/v8/Max and inherits other versions from RFC 4122 in a compatible manner would help both current and future readers understand the changes made as well as the historical context. Do you think we can sneak one into somewhere in the draft?",
      "createdAt": "2023-09-23T13:47:57Z",
      "updatedAt": "2023-09-27T20:21:53Z",
      "closedAt": "2023-09-27T20:21:53Z",
      "comments": [
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "If something changes decades later, descendants will make changes to the RFC. The section describes the motivation for the new version of the RFC, but not for centuries",
          "createdAt": "2023-09-23T16:04:12Z",
          "updatedAt": "2023-09-23T16:04:12Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's not the point. It'll be difficult for future readers to understand the section without the knowledge that v6-v8 didn't exist at the time of writing.",
          "createdAt": "2023-09-23T19:43:30Z",
          "updatedAt": "2023-09-23T19:43:30Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@LiosK\r\n\r\n> It'll be difficult for future readers to understand the section without the knowledge that v6-v8 didn't exist at the time of writing.\r\n\r\nWe can add the phrase that versions 6 and 7 were added to eliminate significant disadvantagies of the previous versions 1-5. Version 8 was added so as not to limit the creative freedom of implementers.",
          "createdAt": "2023-09-24T09:31:41Z",
          "updatedAt": "2023-09-24T09:31:41Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Again, you don't need to mean to the old versions. The problems of the old versions are perfectly expressed by the current draft.",
          "createdAt": "2023-09-24T10:33:52Z",
          "updatedAt": "2023-09-24T10:33:52Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated Title for the changelog. \r\nI added this + the other items I wanted go get into update motivations: \r\nhttps://github.com/ietf-wg-uuidrev/rfc4122bis/pull/152/commits/f85016fc2c030377620b739b984cf698bd57b12d\r\n\r\nBasically \"why did we replace 4122 instead of just update it\" in six succinct bullets.",
          "createdAt": "2023-09-25T14:13:55Z",
          "updatedAt": "2023-09-25T14:13:55Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@kyzer-davis\r\n\r\n> Updated Title for the changelog. I added this + the other items I wanted go get into update motivations: [f85016f](https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/f85016fc2c030377620b739b984cf698bd57b12d)\r\n> \r\n> Basically \"why did we replace 4122 instead of just update it\" in six succinct bullets.\r\n\r\nFrom the rationale, it seems that the huge project to replace the RFC was carried out due to some vague minor reasons. The real reasons (see [ULID](https://github.com/ulid/spec#universally-unique-lexicographically-sortable-identifier)) are hidden:\r\n\r\n> UUID can be suboptimal for many use-cases because:\r\n> \r\n> - It isn't the most character efficient way of encoding 128 bits of randomness      (this hasn't been fixed yet, see [this](https://github.com/uuid6/new-uuid-encoding-techniques-ietf-draft/issues/3))\r\n> - UUID v1/v2 is impractical in many environments, as it requires access to a unique, stable MAC address\r\n> - UUID v3/v5 requires a unique seed and produces randomly distributed IDs, which can cause fragmentation in many data structures\r\n> - UUID v4 provides no other information than randomness which can cause fragmentation in many data structures\r\n\r\n**It\u2019s not good to mislead people** that everything is OK with versions 1-5, and the problems are only in minor typos in the RFC text.\r\n\r\nI want to remind you [how this project began](https://github.com/uuid6/uuid6-ietf-draft/issues/27#issuecomment-920467995). The new RFC will become popular only thanks to its immediate predecessor and inspiration: [ULID with sequence](https://github.com/uuid6/uuid6-ietf-draft/issues/27) (i.e. counter).\r\n",
          "createdAt": "2023-09-25T18:33:27Z",
          "updatedAt": "2023-09-25T19:39:11Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@sergeyprokhorenko,\r\nTo be clear: I did not remove the original update motivations. I simply added additional bullets from an earlier interim meeting discussing the reason behind the IETF's decided to create the 4122bis item vs just adding v6-8 as an RFC that updated 4122 rather than replaces it. \r\n\r\nThe items discussing 1-5 as suboptimal and introduction of v6/v7 still exist as leading text in the update motivations section.",
          "createdAt": "2023-09-26T14:40:57Z",
          "updatedAt": "2023-09-26T14:40:57Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@kyzer-davis\r\n\r\nThank you for the clarification!\r\n\r\n> @sergeyprokhorenko, To be clear: I did not remove the original update motivations. I simply added additional bullets from an earlier interim meeting discussing the reason behind the IETF's decided to create the 4122bis item vs just adding v6-8 as an RFC that updated 4122 rather than replaces it.\r\n> \r\n> The items discussing 1-5 as suboptimal and introduction of v6/v7 still exist as leading text in the update motivations section.\r\n\r\nBut of the significant disadvantagies of versions 1-5 listed in the [ULID](https://github.com/ulid/spec#universally-unique-lexicographically-sortable-identifier), the following disadvantagies has not yet been included in the RFC:\r\n\r\n> - UUID v3/v5 requires a unique seed and produces randomly distributed IDs, which can cause fragmentation in many data structures\r\n\r\nI think by seed they mean the hash function argument, which is unexpectedly changeable in 99% of cases. The second part of this disadvantage is equivalent to the version 4 disadvantage listed in the RFC.",
          "createdAt": "2023-09-26T16:01:02Z",
          "updatedAt": "2023-09-26T16:01:02Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "NP, and thanks for the last comment, I fully understand why one would want to cover that in a bullet. Which is also the original ask in #155 (I just caught up on a moment ago.)\r\n\r\nLet me discuss real fast with Brad on some text that could be added to update motivations to specifically call out how hash-based UUIDs don't work nicely for databases so we can bookend that item (and the rest of my PR for draft-12) and move onto the IANA/SHA256 branches with #152 as my base.",
          "createdAt": "2023-09-26T17:19:09Z",
          "updatedAt": "2023-09-26T17:19:45Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "> UUID v3/v5 requires a unique seed and produces randomly distributed IDs, which can cause fragmentation in many data structures\r\n\r\nI think this would be covered by just tweaking the first bullet point to explain that UUIDs involving hashes have the same problem.\r\n\r\nCurrent text:\r\n\r\n1. Non-time-ordered UUID versions such as UUIDv4 (described in {{uuidv4}}) have poor database index locality. This means that new values created in succession are not close to each other in the index and thus require inserts to be performed at random locations. The resulting negative performance effects on common structures used for this (B-tree and its variants) can be dramatic.\r\n\r\nHow about this instead (only the first sentence changed):\r\n\r\n1. Non-time-ordered UUID versions such as UUIDv4 (described in {{uuidv4}}), as well as UUID versions 3 ({{uuidv3}}) and 5 ({{uuidv3}}) which use hash functions with even bit distribution, have poor database index locality. This means that new values created in succession are not close to each other in the index and thus require inserts to be performed at random locations. The resulting negative performance effects on common structures used for this (B-tree and its variants) can be dramatic.\r\n\r\nThis is the very first bullet point in the Update Motivations section, prominent. I'm not stuck on that being the exact change, but it seems like it covers it to me.\r\n\r\n",
          "createdAt": "2023-09-26T20:20:19Z",
          "updatedAt": "2023-09-26T20:30:03Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "Great! But the problem that\r\n\r\n> UUID v3/v5 requires a **unique** seed\r\n\r\nis not mentioned. I would add a new bullet point: \r\n\r\n> UUID versions 3 ({{uuidv3}}) and 5 ({{uuidv3}}) which use hash functions are at risk of unexpectedly changing hash function argument.\r\n\r\nbecause [hash-based versions are not recommended for use cases where the input may change](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/155#issuecomment-1732432433), and the risk may be underestimated",
          "createdAt": "2023-09-26T20:59:06Z",
          "updatedAt": "2023-09-26T21:09:56Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Name-based UUIDs do not require an unique seed.\r\n\r\nAgain, it depends on the use-case.\r\n\r\n- If the use case is to have an unique ID for a database, yes, then you need an unique seed. But then `UUIDv3(getRandomBytes())` gives the same contents as `UUIDv4()` (except for the version bits). So there is no need to use name-based UUID in that case. Use UUIDv7 instead.\r\n\r\n- If the use-case is to receive a UUID **_representation_** of an URL/OID/etc. , then UUIDv3 and UUIDv5 is the way to go, e.g. `UUIDv3(NS_OID, '2.999')` . This is NOT an \"Unique Identifier\" (so the name UUID can be confusing), it is a name-based representation.\r\n\r\n> I think by seed they mean the hash function argument, which is unexpectedly changeable in 99% of cases\r\n\r\nI do not know what the 99% are. Can you give me a real-world example?\r\n\r\nAn OID 2.999 stays OID 2.999 to all eternity, and so does its UUID representation.\r\n\r\nURL www.example.com stays URL www.example.com for all eternity, and so does its UUID representation.\r\n",
          "createdAt": "2023-09-26T21:53:55Z",
          "updatedAt": "2023-09-26T21:53:55Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@sergeyprokhorenko Sorry, I'm not trying to drag this on unnecessarily, but can you elaborate a bit more on what it is that you're concerned someone might mess up about this?   (I don't fully understand the concern because a hash function by definition gives the same output with the same input, but maybe if I understand what you think people might get wrong about this, that might clarify.)",
          "createdAt": "2023-09-26T21:54:56Z",
          "updatedAt": "2023-09-26T21:54:56Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "> and the risk may be underestimated\r\n\r\nI understand your concern, but it's not necessary. The risk is intrinsic. If you change 1 bit of the input of a cryptographic hash function, the output will be different with a very high probability. This is how hash functions work. It is more accurate to call this a guarantee rather than a risk.\r\n\r\nHowever, if you really want this to be in the new document, how about this paragraph:\r\n\r\n_Considering that one of the properties of identifiers is immutability (during the lifetime of the data to which they are attached) and that hash functions produce different results for each input, it is not recommended to employ name-based UUIDs generated with arguments that may change in the future._\r\n\r\nFor example, we know that people names can change when they get married, so it is not recommended to use people names to generate name-based UUIDs. I don't believe anyone would actually do this, it's just a basic example.\r\n",
          "createdAt": "2023-09-26T21:56:30Z",
          "updatedAt": "2023-09-26T23:50:10Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> > I think by seed they mean the hash function argument, which is unexpectedly changeable in 99% of cases\r\n\r\nThis is not necessary as I discussed in #155. Please don't cross-post the same argument in every thread.\r\n\r\n> as well as UUID versions 3 ({{uuidv3}}) and 5 ({{uuidv3}}) which use hash functions with even bit distribution,\r\n\r\nI don't think this is necessary either. This insertion blurs the point of the statement. v3/v5 have very different properties and uses cases than v1/v4, so while it is very intuitive and likely that v7 replaces v1/v4 just for the index locality issue, the same thing isn't likely to happen for v3/v5 because hash-based vs. time-ordered needs a serious design decision.\r\n",
          "createdAt": "2023-09-26T23:10:33Z",
          "updatedAt": "2023-09-26T23:10:33Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/529860f21c3b4da22210ebd35a083c7c27e4225a has been posted. \r\nI did not use the word `seed` but rather `input \"name\" data` to tie it back to the rest of the document's verbiage. \r\n\r\nI think this covers the bullet sufficiently and draws attention to what we all know:\r\nv3/v5 with input data that changes will basically be the same as v4 (in the grand scheme of a database identifier).\r\n\r\nI don't want to over iterate on this. If the text conveys this point please thumbs up so I can merge draft 12 down and move onto larger items with the remaining time I have this week.",
          "createdAt": "2023-09-27T13:44:16Z",
          "updatedAt": "2023-09-27T13:44:16Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I don't think https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/529860f21c3b4da22210ebd35a083c7c27e4225a is necessary. The whole point is perfectly clear with the original concise text, and this commit inserts some irrelevant and confusing concepts. Particularly, it's quite odd to discuss v3/v5 in the sortability context because the hash-based properties of v3/v5 require a tailored identifier design, which might not stand together with index locality (for example, imagine Git and BitCoin, as very successful applications with hash-based IDs, though not UUIDs).",
          "createdAt": "2023-09-27T14:49:31Z",
          "updatedAt": "2023-09-27T14:49:31Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> I don't think [529860f](https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/529860f21c3b4da22210ebd35a083c7c27e4225a) is necessary. The whole point is perfectly clear with the original concise text, and this commit inserts some irrelevant and confusing concepts. Particularly, it's quite odd to discuss v3/v5 in the sortability context because the hash-based properties of v3/v5 require a tailored identifier design, which might not stand together with index locality (for example, imagine Git and BitCoin, as very successful applications with hash-based IDs, though not UUIDs).\r\n\r\nBitcoin is widely known for its enormous transaction confirmation times. This is a great argument for UUIDv7",
          "createdAt": "2023-09-27T16:47:12Z",
          "updatedAt": "2023-09-27T16:47:12Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "> @sergeyprokhorenko Sorry, I'm not trying to drag this on unnecessarily, but can you elaborate a bit more on what it is that you're concerned someone might mess up about this? (I don't fully understand the concern because a hash function by definition gives the same output with the same input, but maybe if I understand what you think people might get wrong about this, that might clarify.)\r\n\r\n@bradleypeabody\r\n\r\nI'll give you an example. Let's assume that an ordinary systems analyst decided to identify regional offices by hash-based UUIDs. He decided to cocatenate the country code and the postal code as the hash function argument. This decision seemed reasonable to him (because he didn't want to make his job more difficult). For three years everything was OK, and this systems analyst even managed to quit and get a more attractive position in another company. But suddenly the postal code of one of the regional offices changed. And now there are hundreds of thousands of records in the database with two different hash-based UUIDs of the same regional office. Now the new systems analyst tasked with fixing the defect curses his predecessor.\r\n\r\nUnfortunately, any arguments of hash functions can change unexpectedly in the future. This is well known to database designers who try to use [surrogate keys](https://en.wikipedia.org/wiki/Surrogate_key#Advantages) instead of [natural (or business) keys](https://en.wikipedia.org/wiki/Natural_key#Disadvantages). Changes to natural keys are specifically recorded with timestamp in [temporal databases](https://en.wikipedia.org/wiki/Temporal_database) including [DWH](https://en.wikipedia.org/wiki/Data_warehouse) for communication with the outside world. But DWH tables are linked by surrogate keys only.",
          "createdAt": "2023-09-27T17:21:39Z",
          "updatedAt": "2023-09-27T18:04:24Z"
        },
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@sergeyprokhorenko Thanks for that explanation, totally makes sense.\r\n\r\nIn line with your points above, I think those concerns are implied when using an hash function, but you're absolutely right that historically people have screwed this up by not fully thinking through the implications and picking the wrong solution for a particular use case.\r\n\r\nIf you feel strongly that this is worth making an edit for, perhaps a simple sentence or two with a reference to a third party source that talks about the concerns in more detail would work.  E.g. adding a line like this in the v3 and v5 sections, and if appropriate v8 hash example:\r\n\r\n> **Implementors using UUIDs that utilize hash functions as above, especially when used as a database key, should carefully consider the implications of the possibility of the hash function input changing in the future.  Hash functions as used here imply a \"natural key\" (see https://en.wikipedia.org/wiki/Natural_key), whereas database maintenance often benefits from the use of \"surrogate keys\" (see https://en.wikipedia.org/wiki/Surrogate_key).**\r\n\r\nOr it's possible **there might be a better place in the document for this warning, such as the Name-based UUID Generation section.**",
          "createdAt": "2023-09-27T19:27:43Z",
          "updatedAt": "2023-09-27T19:27:43Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI, I backed out https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/529860f21c3b4da22210ebd35a083c7c27e4225a so I can get draft-12 base PR merged down and start work on the other two branches I need to get done ASAP.\r\nLet's take this v3/v5 DB discussion back to #155 as I am going to close this issue in the PR. ",
          "createdAt": "2023-09-27T20:04:57Z",
          "updatedAt": "2023-09-27T20:04:57Z"
        }
      ]
    },
    {
      "number": 159,
      "id": "I_kwDOH6Ln3M5yVfik",
      "title": "Expand v8 Time-based Example to larger timestamp",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/159",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Consensus Requested"
      ],
      "body": "              For the time-based example, here are alternatives (I am keeping 1 nano second):\r\n\r\nA. `tttttttt-tttt-Xttt-rrrr-Xrrrrrrrrrrr` : 1 nano second in 60 bits = wraps after 36 years (`2^60/(1000*1000*1000*60*60*24*365)`), and has 62 bits are left for random (i.e. chance to collide is 1/2^62)\r\n\r\nB. `tttttttt-tttt-Xttt-trrr-Xrrrrrrrrrrr` : 1 nano second in 64 bits = wraps after 584 years (`2^64/(1000*1000*1000*60*60*24*365)`), and has 58 bits are left for random (i.e. chance to collide is 1/2^58)\r\n\r\nC. `tttttttt-tttt-Xttt-ttrr-Xrrrrrrrrrrr`: 1 nano second in 68 bits = wraps after 9359 years (`2^68/(1000*1000*1000*60*60*24*365)`), and has 54 bits are left for random (i.e. chance to collide is 1/2^54)\r\n\r\nD. `tttttttt-tttt-Xttt-tttt-Xrrrrrrrrrrr` : 1 nano second in 76 bits = wraps after 2395924 years (`2^76/(1000*1000*1000*60*60*24*365)`), and has 46 bits are left for random (i.e. chance to collide is 1/2^46)\r\n\r\nMy preferrence would be >=100 years, so 64 bit.\r\n\r\n_Originally posted by @danielmarschall in https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/147#issuecomment-1739901324_\r\n\r\nReasons: The current example wraps in a few hours, few more bits make it a better example.\r\n            ",
      "createdAt": "2023-09-28T20:36:43Z",
      "updatedAt": "2023-10-05T13:37:01Z",
      "closedAt": "2023-10-05T13:37:01Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I am fine with either 60 or 64; \r\n- 60: `custom_a` and `custom_b` that is the easiest for me to modify the text. \r\n- 64: Makes sense to as I just lay down all the bits as is in order through custom a/b/c, little bit more work in editing.\r\n\r\nPersonally, if nobody objects I will go with what is easier thus:\r\n> `custom_a` and `custom_b` is filled with `0x16D6320C3D4DCC00` being:\r\n> `6D6320C3D4DCC00` fills out those 60 bits thus `6D6320C3-D4DC-8C00-8EC9-32D5F69181C0` is the new example.\r\n\r\nI will revising leading text based on whatever is chosen.",
          "createdAt": "2023-09-28T20:39:38Z",
          "updatedAt": "2023-09-28T20:44:38Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Before I leave for the day: \r\nI cannot stress how much we do not need to over-iterate on this.\r\nA few more bits to the timestamp and random for the rest. Let's not cook up a million complex scenarios for an appendix item.",
          "createdAt": "2023-09-28T20:57:33Z",
          "updatedAt": "2023-09-28T20:57:33Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> A few more bits to the timestamp and random for the rest. Let's not cook up a million complex scenarios for an appendix item.\r\n\r\nAgreed! The example should be as simple as possible. Filling `custom_c` with half random and half time-stamp is too complex, so 60 bits might be better.\r\n\r\nOn the other hand, I think >100 years is good to avoid creating a \"year 2038\" situation (i.e. a wrap-around which we might experience during our lifetime).\r\n\r\nSo, how about \"10ns in 60bits\", which would wrap around in 365 years?\r\n\r\nI am fine with either \"1ns in 60bits (36 years wrap)\" or \"10ns in 60bits (365 years wrap)\", but prefer the latter.",
          "createdAt": "2023-09-28T21:02:04Z",
          "updatedAt": "2023-09-28T21:03:30Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "I_kwDOH6Ln3M5yl-hz",
      "title": "Describe allocation logic of Namespace ID",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/161",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Action item to describe how current Namespace IDs are allocated and methods for adding a new ID following the same logic. \r\nTies into #144 to complete the topic.",
      "createdAt": "2023-10-02T19:44:24Z",
      "updatedAt": "2023-10-09T20:14:43Z",
      "closedAt": "2023-10-09T20:14:43Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, @bradleypeabody, @mcr, et all.\r\nWith the inclusion of some normative language in this appendix within #162. I think I should move this up out of the appendix and into a section. Say after or within the \"Name-Based UUID Generation\" section?\r\n\r\nAny objection to that change?",
          "createdAt": "2023-10-03T19:34:59Z",
          "updatedAt": "2023-10-03T19:38:32Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Good idea. Yes, I think IANA registration related things should be outside of appendixes.",
          "createdAt": "2023-10-03T19:45:00Z",
          "updatedAt": "2023-10-03T19:45:00Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I went ahead and moved it via https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/162/commits/bd2a5e770b23e7f29b152600684cc41f96f4bd70. \r\nI collapsed the \"a note on names\" subsection into that new section as well to keep that all in the same location.\r\nThis probably should have been a different PR but its too late now...",
          "createdAt": "2023-10-03T20:58:10Z",
          "updatedAt": "2023-10-03T20:58:10Z"
        }
      ]
    },
    {
      "number": 163,
      "id": "I_kwDOH6Ln3M5y_JZp",
      "title": "Change RFC8937 and RFC4086 to Informative References",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/163",
      "state": "CLOSED",
      "author": "jimfenton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "RFC 8937 is an informative RFC, and therefore not appropriate to be a normative reference from a standards-track RFC. This was pointed out by the Nits tool.\r\n\r\nIMO, the advice on choosing random numbers in Section 6.8 is informative, and [RFC8937] and [RFC4086] should be informative for the same reason as [RANDOM] is.\r\n\r\nOn a related topic, while [RANDOM] seems to be a very good treatment of the subject, I'm a bit concerned about it not being an archival document. What should readers do if it goes away? Find it on Internet Archive?",
      "createdAt": "2023-10-05T22:17:10Z",
      "updatedAt": "2023-10-20T13:55:31Z",
      "closedAt": "2023-10-20T13:55:31Z",
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> On a related topic, while [RANDOM] seems to be a very good treatment of the subject, I'm a bit concerned about it not being an archival document. What should readers do if it goes away? Find it on Internet Archive?\r\n\r\nI had added the RFCs as alternatives to RANDOM for this very reason. At one point it was JUST random and I wanted to provide some other citations in the event something happens.",
          "createdAt": "2023-10-06T20:37:17Z",
          "updatedAt": "2023-10-06T20:37:17Z"
        }
      ]
    },
    {
      "number": 164,
      "id": "I_kwDOH6Ln3M5y_UIn",
      "title": "Fix Timestamp of Time-Based UUIDv8 Example",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/164",
      "state": "CLOSED",
      "author": "danielmarschall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nI have found a mistake in the Appendix C.1 example:\r\n- Timestamp `1645557742000000000` has one zero too many, since we count in 10ns-steps.\r\n- I have also added `(10ns-steps)` after the timestamp, to make it clear which unit it represents.\r\n- Dividing by 10 changes the 64-bit timestamp `0x16D6320C3D4DCC00` into the desired 60-bit timestamp `0x2489E9AD2EE2E00`.\r\n \r\nCan you please include this fix in your current PR?  Thank you.\r\n\r\nWrong:\r\n\r\n```\r\n   Timestamp is Tuesday, February 22, 2022 2:22:22.000000 PM GMT-05:00\r\n   represented as 0x16D6320C3D4DCC00 or 1645557742000000000\r\n\r\n   -------------------------------------------\r\n   field     bits value\r\n   -------------------------------------------\r\n   custom_a  48   0x6D6320C3D4DC\r\n   ver        4   0x8\r\n   custom_b  12   0xC00\r\n   var        2   0b10\r\n   custom_c  62   0b00, 0xEC932D5F69181C0\r\n   -------------------------------------------\r\n   total     128\r\n   -------------------------------------------\r\n   final: 6D6320C3-D4DC-8C00-8EC9-32D5F69181C0\r\n```\r\n\r\nCorrect:\r\n\r\n```\r\n   Timestamp is Tuesday, February 22, 2022 2:22:22.000000 PM GMT-05:00\r\n   represented as 0x2489E9AD2EE2E00 or 164555774200000000 (10ns-steps).\r\n\r\n   -------------------------------------------\r\n   field     bits value\r\n   -------------------------------------------\r\n   custom_a  48   0x2489E9AD2EE2\r\n   ver        4   0x8\r\n   custom_b  12   0xE00\r\n   var        2   0b10\r\n   custom_c  62   0b00, 0xEC932D5F69181C0\r\n   -------------------------------------------\r\n   total     128\r\n   -------------------------------------------\r\n   final: 2489E9AD-2EE2-8E00-8EC9-32D5F69181C0\r\n\r\n```\r\n",
      "createdAt": "2023-10-05T23:06:43Z",
      "updatedAt": "2023-10-20T13:55:32Z",
      "closedAt": "2023-10-20T13:55:32Z",
      "comments": [
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Also, I am not sure, do you really mean 64-bit, or 60-bit?\r\n`This example UUIDv8 test vector utilizes a well-known 64 bit Unix epoch timestamp with 10ns precision,`",
          "createdAt": "2023-10-06T07:45:45Z",
          "updatedAt": "2023-10-06T07:45:45Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "yeah, that makes sense. I was thinking about it but didn't do the math myself and divide by 10.\r\nEdit: I wanted to state it started from a 64-bit timestamp. As opposed to 32 and then its trimmed down.",
          "createdAt": "2023-10-06T15:01:05Z",
          "updatedAt": "2023-10-06T15:02:59Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "I_kwDOH6Ln3M5zEd9M",
      "title": "Populating all 128 bits",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/165",
      "state": "CLOSED",
      "author": "jimfenton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "For UUID version 3 (Section 5.3) and version 5 (Section 5.5), the document says, \"is used to populate all 128 bits of the UUID layout.\" But the variant and version fields are not populated, so only 122 bits are used. For MD5 (version 3), it should tell us which bits of the MD5 output are used. For version 5, it should specify the correct number of bits.",
      "createdAt": "2023-10-06T16:20:13Z",
      "updatedAt": "2023-10-20T13:55:39Z",
      "closedAt": "2023-10-20T13:55:39Z",
      "comments": [
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think there could be a confusion because indeed all 128 bits are populated with hash bits, and after that the 6 bits version/variant are written, overwriting some of the hash bits.\r\n",
          "createdAt": "2023-10-06T19:19:40Z",
          "updatedAt": "2023-10-06T19:19:40Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, the next sentences after states that the 128 bits are then shifted by the ver/var rules.\r\n\r\nV3:\r\n> This MD5 value is then used to populate all 128 bits of the UUID layout. **The UUID version and variant then replace the respective bits as defined by [Section 4.2](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-12#version_field) and [Section 4.1](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-12#variant_field). An example of this bit substitution can be found in [Appendix B.2](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-12#uuidv3_example).**\r\n\r\nV5:\r\n> The most significant, left-most 128 bits of the SHA-1 value is then used to populate all 128 bits of the UUID layout and the remaining 32 least significant, right-most bits of SHA-1 output are discarded. **The UUID version and variant then replace the respective bits as defined by [Section 4.2](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-12#version_field) and [Section 4.1](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-12#variant_field). An example of this bit substitution and discarding excess bits can be found in [Appendix B.4](https://datatracker.ietf.org/doc/html/draft-ietf-uuidrev-rfc4122bis-12#uuidv5_example).**\r\n\r\nThis is how it is being done in current implementations; else yeah, I would have said \"generate 122 and then slot in ver/var \"...but that isn't reality today (thanks to RFC4122)\r\nAnd it matters because 122 w/6 bits added or 128 with bit overwrite can produce differing final UUIDs.",
          "createdAt": "2023-10-06T19:53:16Z",
          "updatedAt": "2023-10-06T20:23:12Z"
        }
      ]
    },
    {
      "number": 166,
      "id": "I_kwDOH6Ln3M5zFojJ",
      "title": "Further normalize Namespace verbiage",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/166",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Where \"Namespace Value\" is referenced replace with \"Namespace ID Value\"",
      "createdAt": "2023-10-06T19:54:04Z",
      "updatedAt": "2023-10-20T13:55:32Z",
      "closedAt": "2023-10-20T13:55:32Z",
      "comments": []
    },
    {
      "number": 167,
      "id": "I_kwDOH6Ln3M5zFpTR",
      "title": "Move citation of Namesapce ID up to first instance in v3/v5",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/167",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently:\r\n\r\n> UUIDv3 values are created by computing an MD5 {{RFC1321}}\r\nhash over a given namespace value concatenated with the desired name value\r\nafter both have been converted to a canonical sequence of octets, as defined by the standards or conventions of its namespace, in network byte order.\r\n\r\n[...later...]\r\n\r\n> Some common namespace values have been defined via {{namespaces}}.\r\n\r\n\r\nSimply move the `{{namespaces}}` citation up and remove this line:\r\n\r\n> UUIDv3 values are created by computing an MD5 {{RFC1321}}\r\nhash over a given namespace **({{namespaces}})** value concatenated with the desired name value\r\nafter both have been converted to a canonical sequence of octets, as defined by the standards or conventions of its namespace, in network byte order.\r\n\r\nReplicate same change for v5.\r\n",
      "createdAt": "2023-10-06T19:56:31Z",
      "updatedAt": "2023-10-20T13:55:33Z",
      "closedAt": "2023-10-20T13:55:32Z",
      "comments": []
    },
    {
      "number": 169,
      "id": "I_kwDOH6Ln3M50Hqs7",
      "title": "Some anti-UUID prejudice and dogma",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/169",
      "state": "CLOSED",
      "author": "sergeyprokhorenko",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I was just confronted with anti-UUID prejudice and dogma based on mindless copying of information technology. These prejudices and dogmas would seem ridiculous if senior IT managers were not guided by them. Therefore, I would like (before it\u2019s too late) to add the following ideas to the section [6.12. ](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-12.html#section-6.12)[DBMS and Database Considerations](https://www.ietf.org/archive/id/draft-ietf-uuidrev-rfc4122bis-12.html#name-dbms-and-database-considera):\r\n\r\n1. Generation is not the only or preferred way to create a UUID. If necessary, UUIDs must be copied. I am talking not only about copying the UUIDs of dimensions or hubs into the fact tables or link/attribute tables associated with them, but also about copying tables along with the UUIDs they contain from one schema or database to another.\r\n2. UUIDs should not be duplicated with human-readable identifiers (codes). However, it is good practice to describe objects denoted by UUIDs if those descriptions are not used as identifiers or for automatic data processing.\r\n3. If UUIDs are used in program code, then it is good practice to add comments to the program code or assign UUID values to variables. However, a more preferable option is to place the UUID along with the business logic in database tables, with the addition of fields that describe the business logic: boolen flags and multivalued conditions of WHEN (SWITCH) control structures.",
      "createdAt": "2023-10-17T20:08:52Z",
      "updatedAt": "2023-10-20T23:38:09Z",
      "closedAt": "2023-10-20T23:38:09Z",
      "comments": [
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "\r\n> 1. Generation is not the only or preferred way to create a UUID. If necessary, UUIDs must be copied. I am talking not only about copying the UUIDs of dimensions or hubs into the fact tables or link/attribute tables associated with them, but also about copying tables along with the UUIDs they contain from one schema or database to another.\r\n\r\nIt might be hard to generalize or describe. Maybe mentioning a few examples will make it clear.\r\nLike, cloning a customer must generate a new UUID for the cloned dataset. But copying the customer from staging environment to production environment, or recovering a dataset from a backup, must preserve the same UUID.\r\n\r\n> 2. UUIDs should not be duplicated with human-readable identifiers (codes). However, it is good practice to describe objects denoted by UUIDs if those descriptions are not used as identifiers or for automatic data processing.\r\n\r\nI don't understand what you mean.\r\n\r\n> 3. If UUIDs are used in program code, then it is good practice to add comments to the program code or assign UUID values to variables.\r\n\r\nAgreed. Though it should be variables **or constants**.\r\n\r\n> However, a more preferable option is to place the UUID along with the business logic in database tables, with the addition of fields that describe the business logic: boolen flags and multivalued conditions of WHEN (SWITCH) control structures.\r\n\r\nHere is an example of a hardcoded UUID in source code:\r\nhttps://github.com/ramsey/uuid/blob/4.x/src/Uuid.php#L70C35-L70C43\r\nThis is perfectly fine. Why should this UUID be taken in a database table?\r\n",
          "createdAt": "2023-10-18T21:07:46Z",
          "updatedAt": "2023-10-18T21:07:46Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@sergeyprokhorenko The WG might be open to a document with practical guides for using UUIDs, but this is really too much for the existing document.  Or maybe write a blog or a book... none of what you write can be normative anyway.",
          "createdAt": "2023-10-19T23:34:32Z",
          "updatedAt": "2023-10-19T23:34:32Z"
        },
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "I don't want to delay approval of the RFC. Therefore I want to close this issue. I hope that the real ridiculous case I described will not be repeated by anyone.",
          "createdAt": "2023-10-20T23:38:09Z",
          "updatedAt": "2023-10-20T23:38:09Z"
        }
      ]
    },
    {
      "number": 170,
      "id": "I_kwDOH6Ln3M50rztW",
      "title": "AD Review #2: IANA Subtype Modifications",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/170",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See: https://mailarchive.ietf.org/arch/msg/uuidrev/CmMLIYhIj9_HgMv4YSY-kXBaH5Y/\r\n\r\n- Remove Hex column\r\n- Define range of acceptable version subtypes (0-15) within the IETF / OSF Variant.",
      "createdAt": "2023-10-23T17:19:17Z",
      "updatedAt": "2023-10-27T20:45:12Z",
      "closedAt": "2023-10-27T20:45:12Z",
      "comments": []
    },
    {
      "number": 171,
      "id": "I_kwDOH6Ln3M50r1XQ",
      "title": "AD Review #2: Specify Values for Variant/Subtype Column",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/171",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "See: https://mailarchive.ietf.org/arch/msg/uuidrev/CmMLIYhIj9_HgMv4YSY-kXBaH5Y/\r\n\r\nCall out that variant and subtype column are freeform but likely 1 of 4 values that may show up are:\r\n- \"Apollo NCS\"\r\n- \"OSF DCE / IETF\"\r\n- \"Microsoft\"\r\n- \"Reserved for whatever final Variant ends up being\"\r\n\r\nSubtype column is free-form but may end up being only \"version\" or \"family\"",
      "createdAt": "2023-10-23T17:23:30Z",
      "updatedAt": "2023-10-27T20:45:13Z",
      "closedAt": "2023-10-27T20:45:13Z",
      "comments": []
    },
    {
      "number": 172,
      "id": "I_kwDOH6Ln3M50r12u",
      "title": "AD Review #2: Grammar change at the end of 5.1",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/172",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": " > The bullets at the end of this section don't read clearly.  It might be enough to say \"On systems ...\" for each of them.\r\nSure, that is an easy enough change. If I must modify anything for the aforementioned topics, I can sneak this in else I am not sure a whole draft-14 just for that small change is warranted.\r\n\r\nI'd rather send this with that clarification, since these other things need adjustment anyway.\r\n\r\nSee: https://mailarchive.ietf.org/arch/msg/uuidrev/CmMLIYhIj9_HgMv4YSY-kXBaH5Y/",
      "createdAt": "2023-10-23T17:24:24Z",
      "updatedAt": "2023-10-27T20:45:13Z",
      "closedAt": "2023-10-27T20:45:13Z",
      "comments": []
    },
    {
      "number": 174,
      "id": "I_kwDOH6Ln3M506ebk",
      "title": "SHA and Integer Verbiage clarifications",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/174",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "3.2, add \"2\" to SHA-2.\r\n4, add \"unsigned\" to integer.",
      "createdAt": "2023-10-25T13:52:51Z",
      "updatedAt": "2023-10-27T20:45:13Z",
      "closedAt": "2023-10-27T20:45:13Z",
      "comments": []
    },
    {
      "number": 175,
      "id": "I_kwDOH6Ln3M51KfOy",
      "title": "Disclaimer in nil/max that these do not fall into IETF variants",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/175",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Single line to couple with what is in table 1.",
      "createdAt": "2023-10-27T14:45:53Z",
      "updatedAt": "2023-10-27T20:45:14Z",
      "closedAt": "2023-10-27T20:45:14Z",
      "comments": []
    },
    {
      "number": 176,
      "id": "I_kwDOH6Ln3M51cqIQ",
      "title": "Fix v1/v6 final UUID in test vector",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/176",
      "state": "CLOSED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "```\r\nAppendix A. Test  Vectors says\r\n\r\nBoth UUIDv1 and UUIDv6 utilize the same values in clock_seq, and node.\r\nAll of which have been generated with random data. For the randomized node, the least significant bit of the first octet is set to a value of\r\n1 as perSection 6.10. Thus the starting value 0x9E6BDECED846 was changed to 0x9F6BDECED846.\r\n\r\nthen\r\n\r\nA.1. Example of a UUIDv1 Value\r\n\r\n-------------------------------------------\r\nfield      bits value\r\n-------------------------------------------\r\ntime_low   32   0xC232AB00\r\ntime_mid   16   0x9414\r\nver         4   0x1\r\ntime_high  12   0x1EC\r\nvar         2   0b10\r\nclock_seq  14   0b11, 0x3C8\r\nnode       48   0x9F6BDECED846\r\n-------------------------------------------\r\ntotal      128\r\n-------------------------------------------\r\nfinal: C232AB00-9414-11EC-B3C8-9E6BDECED846\r\n\r\nIt seems that node in the source and in the final are reversed, likely it should be:\r\n\r\nnode       48   0x9E6BDECED846\r\n\r\nand\r\n\r\nfinal: C232AB00-9414-11EC-B3C8-9F6BDECED846\r\n```",
      "createdAt": "2023-10-31T13:12:53Z",
      "updatedAt": "2023-10-31T13:23:46Z",
      "closedAt": "2023-10-31T13:23:46Z",
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOH6Ln3M4-f3Vs",
      "title": "Ci fixes",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/1",
      "state": "MERGED",
      "author": "martinthomson",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As a recent use of the template, you have picked up a few problems that can't be fixed automatically.  They are only performance problems in CI, but this should fix that up.",
      "createdAt": "2022-09-07T10:01:57Z",
      "updatedAt": "2022-09-08T11:00:09Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "925a7abe83092fa92d226fd3e3ff5a2c6a12f33e",
      "headRepository": "martinthomson/rfc4122bis",
      "headRefName": "ci-fixes",
      "headRefOid": "88e13fd7fd5be1c44d8bb64073aa7539e1d6e76e",
      "closedAt": "2022-09-08T11:00:09Z",
      "mergedAt": "2022-09-08T11:00:08Z",
      "mergedBy": "mcr",
      "mergeCommit": {
        "oid": "8d4ade67e5f4b42190b2b394a8379139a4684674"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5Bj6yI",
          "commit": {
            "abbreviatedOid": "88e13fd"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "I don't know much about GitHub workflows, but I'm sure Martin knows what's needed. Any comments, Michael? Otherwise I will just merge.",
          "createdAt": "2022-09-07T23:37:36Z",
          "updatedAt": "2022-09-07T23:37:36Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOH6Ln3M5BmLMl",
          "commit": {
            "abbreviatedOid": "88e13fd"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2022-09-08T11:00:02Z",
          "updatedAt": "2022-09-08T11:00:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 14,
      "id": "PR_kwDOH6Ln3M5Ahsvr",
      "title": "Draft 00 - Merge RFC 4122 into TOC draft-peabody-dispatch-new-uuid-format-04",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/14",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Merge RFC4122 with draft-peabody-dispatch-new-uuid-format-04.md\r\n- Change: Reference RFC1321 to RFC6151\r\n- Change: Reference RFC2141 to RFC8141\r\n- Change: Reference RFC2234 to RFC4234\r\n- Change: Converted UUIDv1 to match UUIDv6 section from Draft 04\r\n- Change: Trimmed down the ABNF representation\r\n- Change: ITU http website to https equivalent\r\n- Errata: Bad Reference to RFC1750 \\| 3641 #4\r\n- Errata: Change MD5 website to example.com \\| 3476 #6 (Also Fixes Errata: Fix uuid_create_md5_from_name() \\| 1352 #2)\r\n- Errata: Typo in code comment \\| 6665 #11\r\n- Errata: Fix BAD OID acronym \\| 6225 #9\r\n- Errata: Incorrect Parenthesis usage Section 4.3 \\| 184 #5\r\n- Errata: Lexicographically Sorting Paragraph Fix \\| 1428 #3\r\n- Errata: Fix 4.1.3 reference to the correct bits \\| 1957 #13\r\n- Errata: Fix reference to variant in octet 8 \\| 4975 #7\r\n- Errata: Further clarify 3rd/last bit of Variant for spec \\| 5560 #8\r\n- Draft 05: B.2. Example of a UUIDv7 Value two \"var\" in table https://github.com/uuid6/uuid6-ietf-draft/issues/120\r\n- Draft 05: MUST veribage in Reliability of 6.1 https://github.com/uuid6/uuid6-ietf-draft/issues/121\r\n- Draft 05: Further discourage centralized registry for distributed UUID Generation.\r\n- New: Further Clarity of exact octet and bit of var/ver in this spec\r\n- New: Block diagram, bit layout, test vectors for UUIDv4\r\n- New: Block diagram, bit layout, test vectors for UUIDv3\r\n- New: Block diagram, bit layout, test vectors for UUIDv5\r\n- New: Add MD5 Security Considerations reference, RFC6151\r\n- New: Add SHA1 Security Considerations reference, RFC6194",
      "createdAt": "2022-10-10T22:48:32Z",
      "updatedAt": "2023-01-20T18:41:15Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "8d4ade67e5f4b42190b2b394a8379139a4684674",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-00-merge-1",
      "headRefOid": "d60a1a57ff487232ca7c77671e255ec37c506010",
      "closedAt": "2022-10-10T22:52:00Z",
      "mergedAt": "2022-10-10T22:52:00Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "26efbd0c00e6021c27418fe2d83449dfa30ecf45"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 15,
      "id": "PR_kwDOH6Ln3M5A9ort",
      "title": "Draft 00 - Merge 2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/15",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Author Email Addresses\r\n- More Reference Updates\r\n- Some minor formatting changes\r\n- Fixed few test vectors for v7/v8 to match other test vectors\r\n- Modified TODOs",
      "createdAt": "2022-10-17T20:43:17Z",
      "updatedAt": "2023-01-20T18:41:13Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "26efbd0c00e6021c27418fe2d83449dfa30ecf45",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-00-merge-2",
      "headRefOid": "dea2e1b8d92597788ea9d6d3968a52400211c3fc",
      "closedAt": "2022-10-17T20:44:38Z",
      "mergedAt": "2022-10-17T20:44:38Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "61e9ef93bce62ecce9484432f93d36a8e4b35c16"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 32,
      "id": "PR_kwDOH6Ln3M5C4UJl",
      "title": "Draft 01 - Merge 1",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/32",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- #18 \r\n- #19 \r\n- #20 \r\n- #22 \r\n- #24\r\n- #25 \r\n- #27 \r\n- #29 \r\n- #30\r\n- #40\r\n- #33 \r\n- #39",
      "createdAt": "2022-11-14T22:10:28Z",
      "updatedAt": "2023-01-20T18:41:09Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "61e9ef93bce62ecce9484432f93d36a8e4b35c16",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-01",
      "headRefOid": "c9fe9709db753904246c7a1c4a8943b6c0a44ce0",
      "closedAt": "2023-01-20T17:12:28Z",
      "mergedAt": "2023-01-20T17:12:28Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "79a604bce3a13efd31e16aee50a29f90f9999eb7"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5LP2KR",
          "commit": {
            "abbreviatedOid": "0b88cbc"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-01-19T19:11:10Z",
          "updatedAt": "2023-01-19T19:13:30Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This is wrong, it says 4 or more, and we need to say exactly 4 octets.\r\n\"*\" is the wrong modifier.\r\n\"4 hexOctet\" would actually be correct.\r\nWe should use a tool... like \"abnfgen\"  https://www.quut.com/abnfgen/\r\n",
              "createdAt": "2023-01-19T19:11:10Z",
              "updatedAt": "2023-01-19T19:13:30Z"
            },
            {
              "originalPosition": 13,
              "body": "Also, this ABNF text is duplicated.\r\n",
              "createdAt": "2023-01-19T19:12:00Z",
              "updatedAt": "2023-01-19T19:13:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 34,
      "id": "PR_kwDOH6Ln3M5FQO1O",
      "title": "updated text per discussion at issue 21",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/34",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This updates the wording on the clock sequence and node fields based on #21.  @kyzer-davis let me know if this format works and can just be merged or if something else is needed.",
      "createdAt": "2022-12-12T23:44:24Z",
      "updatedAt": "2023-01-19T19:23:29Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "61e9ef93bce62ecce9484432f93d36a8e4b35c16",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "issue-21",
      "headRefOid": "142ed9cfae68b4a28c5a1bc8e98a7a44816cf065",
      "closedAt": "2023-01-19T19:23:29Z",
      "mergedAt": "2023-01-19T19:23:29Z",
      "mergedBy": "mcr",
      "mergeCommit": {
        "oid": "3735c87fe54fbebb4fb847de2dab60e98a62a3b3"
      },
      "comments": [
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "close #21 ",
          "createdAt": "2023-01-19T19:23:08Z",
          "updatedAt": "2023-01-19T19:23:08Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 35,
      "id": "PR_kwDOH6Ln3M5FQdo3",
      "title": "moved iana urn registration template as directed",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/35",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kyzer-davis here's my attempt to address #23.  Some of the text I was able to just move over from what you had there but some fields didn't have a corresponding place in the new template so I just filled it out based on what made sense to me.",
      "createdAt": "2022-12-13T00:35:10Z",
      "updatedAt": "2023-01-20T18:03:25Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "79a604bce3a13efd31e16aee50a29f90f9999eb7",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "issue-23",
      "headRefOid": "7d91e204ef906649a1e63a87ea9548a493d973f7",
      "closedAt": "2023-01-20T18:03:25Z",
      "mergedAt": "2023-01-20T18:03:25Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "2c53adc294d5db33a3b3edca2d2550f593d2a9ec"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5KjtWE",
          "commit": {
            "abbreviatedOid": "9ed7185"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Recheck the ABNF.",
          "createdAt": "2023-01-17T04:53:58Z",
          "updatedAt": "2023-01-19T19:26:19Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOH6Ln3M5LP--Y",
          "commit": {
            "abbreviatedOid": "9ed7185"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T19:24:57Z",
          "updatedAt": "2023-01-19T19:24:57Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "```suggestion\r\n  provided by the following ABNF {{RFC5234}}:\r\n```",
              "createdAt": "2023-01-19T19:24:57Z",
              "updatedAt": "2023-01-19T19:24:57Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5LQAFT",
          "commit": {
            "abbreviatedOid": "c30a465"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2023-01-19T19:27:05Z",
          "updatedAt": "2023-01-19T19:27:21Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Maybe the ABNF could be referenced to this document, rather than repeated in the template.\r\n",
              "createdAt": "2023-01-19T19:27:05Z",
              "updatedAt": "2023-01-19T19:27:21Z"
            }
          ]
        }
      ]
    },
    {
      "number": 36,
      "id": "PR_kwDOH6Ln3M5HS-eQ",
      "title": "Fix typo of MD5-LOW to SHA-LOW",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/36",
      "state": "MERGED",
      "author": "crutchcorn",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "I noticed while reading through the specification that there was a typo in the UUIDv5 table indicating an MD5-LOW encoding, when it should be SHA-LOW instead.\r\n\r\nThis PR:\r\n- Fixes this issue\r\n- Updates `sha` to `sha1`\r\n- Fixes another mention of MD5 in UUIDv5",
      "createdAt": "2023-01-13T03:47:16Z",
      "updatedAt": "2023-01-20T19:56:42Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "2c53adc294d5db33a3b3edca2d2550f593d2a9ec",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "83f5c6eca76ea6d549c32664ce8a6661e371fab0",
      "closedAt": "2023-01-20T18:28:52Z",
      "mergedAt": "2023-01-20T18:28:52Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "39bcf9e7a9b55f655a40d5c2af151aaf8815db7b"
      },
      "comments": [
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "Also fix\r\n\r\n```\r\nFor more information on MD5 security considerations see {{RFC6194}}.\r\n```\r\n\r\n",
          "createdAt": "2023-01-19T19:22:16Z",
          "updatedAt": "2023-01-19T19:22:16Z"
        },
        {
          "author": "cabo",
          "authorAssociation": "NONE",
          "body": "Why are you editing the HTML?",
          "createdAt": "2023-01-20T16:45:10Z",
          "updatedAt": "2023-01-20T16:45:10Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Why are you editing the HTML?\r\n\r\nAddressing it, I will replicate these to the markdown file on this branch.",
          "createdAt": "2023-01-20T18:13:51Z",
          "updatedAt": "2023-01-20T18:13:51Z"
        },
        {
          "author": "crutchcorn",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Apologies for the confusion regarding HTML/MD edits. This is my first contribution to any RFC ever, so I'm admittedly a bit lost \ud83d\ude05\n\nI'll correct for future contributions ",
          "createdAt": "2023-01-20T19:14:24Z",
          "updatedAt": "2023-01-20T19:14:24Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5LQBfR",
          "commit": {
            "abbreviatedOid": "067ba42"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T19:29:44Z",
          "updatedAt": "2023-01-19T19:29:45Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\n|                            sha1_low                           |\r\n```",
              "createdAt": "2023-01-19T19:29:45Z",
              "updatedAt": "2023-01-19T19:29:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5LQB3_",
          "commit": {
            "abbreviatedOid": "a4a698c"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-01-19T19:30:30Z",
          "updatedAt": "2023-01-19T19:30:30Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "```suggestion\r\n|var|                        sha1_low                           |\r\n```",
              "createdAt": "2023-01-19T19:30:30Z",
              "updatedAt": "2023-01-19T19:30:30Z"
            }
          ]
        }
      ]
    },
    {
      "number": 37,
      "id": "PR_kwDOH6Ln3M5IFVxn",
      "title": "Document suggestions, hopefully non-controversial",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/37",
      "state": "MERGED",
      "author": "jimfenton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This is a collection of small edits that it was easier to send as a pull request rather than as a text (e.g., email) submission. Most are grammatical corrections. I'm happy to discuss any that the editors or the wg might not agree with.",
      "createdAt": "2023-01-19T01:25:26Z",
      "updatedAt": "2023-01-20T18:40:29Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "39bcf9e7a9b55f655a40d5c2af151aaf8815db7b",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "fenton-edits",
      "headRefOid": "e6a100a8d41b627ac1fcb1a8efcda40e8422b107",
      "closedAt": "2023-01-20T18:40:20Z",
      "mergedAt": "2023-01-20T18:40:19Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "de99e3f070a0247fdc872f72452d200494459a4b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 54,
      "id": "PR_kwDOH6Ln3M5IPPUU",
      "title": "Draft 01 - Merge 2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/54",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Closes #41\r\n- Closes #42\r\n- Closes #45 \r\n- Closes #46 \r\n- Closes #48\r\n- Added .txt and .html files.\r\n- Removed TODO labels\r\n- Added Draft 01 Changelog",
      "createdAt": "2023-01-20T19:09:04Z",
      "updatedAt": "2023-01-23T23:29:09Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "de99e3f070a0247fdc872f72452d200494459a4b",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-01-merge-2",
      "headRefOid": "e248f379428def93985ab05a2393d569a45ec058",
      "closedAt": "2023-01-23T22:55:02Z",
      "mergedAt": "2023-01-23T22:55:02Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "40b48c5b048be16921872ff00cee720b6bec01ed"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 58,
      "id": "PR_kwDOH6Ln3M5IsNgO",
      "title": "Fix \"MD5\" mention in SHA1 section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/58",
      "state": "MERGED",
      "author": "astiob",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-01-27T16:11:53Z",
      "updatedAt": "2023-01-31T23:05:24Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "091da05ce8f38a0f952896a0031f52bb91936178",
      "headRepository": "astiob/rfc4122bis",
      "headRefName": "patch-1",
      "headRefOid": "bd92f5878e104813a6abd8827f906001790af87b",
      "closedAt": "2023-01-31T23:05:24Z",
      "mergedAt": "2023-01-31T23:05:24Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "ce92ee5e5e12849a5c279df92a9c0c6ca59f2082"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch! \r\n\r\nTagging as #59 will leave it open until I get the okay to merge in the Feb interim.\r\n\r\nThanks!",
          "createdAt": "2023-01-27T20:34:56Z",
          "updatedAt": "2023-01-27T20:34:56Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 60,
      "id": "PR_kwDOH6Ln3M5I9bYl",
      "title": "Draft 02 merge 00",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/60",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Describe Nil/Max UUID in variant table #16\r\n- Further Clarify that non-descript node IDs are the preferred method in distributed UUID Generation #49\r\n- Appendix B, consistent naming #55\r\n- Remove duplicate ABNF from IANA considerations #56\r\n- Monotonic Error Checking missing newline #57\r\n- More Security Considerations Randomness #26\r\n- SHA265 UUID Generation #50\r\n- Expand multiplexed fields within v1 and v6 bit definitions # 43\r\n- Clean up text in UUIDs that Do Not Identify the Host #61\r\n- Revise UUID Generator States section #47\r\n- Expand upon why unix epoch rollover is not a problem #44",
      "createdAt": "2023-02-01T00:14:00Z",
      "updatedAt": "2023-02-16T22:13:59Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "ce92ee5e5e12849a5c279df92a9c0c6ca59f2082",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-02-merge-00",
      "headRefOid": "76366058877e63e5d8087b436259c6714240f1d3",
      "closedAt": "2023-02-16T22:13:53Z",
      "mergedAt": "2023-02-16T22:13:53Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "9fb3a609a641cba29abe32a1e977392ad5681b54"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Added first pass at #43, hit the bit layout and definitions for v1/v6 and the test vectors.\r\nNeed to discuss what we want to do with section \"Creating UUIDv1 through UUIDv5 Value\" which is relied heavily on v1 naming scheme that I just changed...\r\n\r\nPossibly need some net-new C code examples for v1, v3, v4, v5 and remove that entirely.",
          "createdAt": "2023-02-06T16:16:08Z",
          "updatedAt": "2023-02-06T16:16:08Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated to clean up some text that didn't read correctly for #61 ",
          "createdAt": "2023-02-09T21:17:27Z",
          "updatedAt": "2023-02-09T21:17:27Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Knocked out #44 after finding the supporting comment in the old tracker.\r\n",
          "createdAt": "2023-02-09T21:53:39Z",
          "updatedAt": "2023-02-09T21:53:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 63,
      "id": "PR_kwDOH6Ln3M5MJwk5",
      "title": "Minor edits that should be uncontroversial",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/63",
      "state": "MERGED",
      "author": "jimfenton",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-15T22:55:07Z",
      "updatedAt": "2023-03-16T14:06:30Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "8cb1068f241ec26350aff4ad4a27b0847e42e9c6",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "jf-edits",
      "headRefOid": "c6d443146b711104f4a046256b5b040f37c22f88",
      "closedAt": "2023-03-16T14:05:02Z",
      "mergedAt": "2023-03-16T14:05:02Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "040c625ba2b177f2dd5947cff33b1fc2abf40e04"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5QGXZ1",
          "commit": {
            "abbreviatedOid": "c6d4431"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. I appreciate the review.",
          "createdAt": "2023-03-16T14:04:52Z",
          "updatedAt": "2023-03-16T14:04:52Z",
          "comments": []
        }
      ]
    },
    {
      "number": 71,
      "id": "PR_kwDOH6Ln3M5M9MdM",
      "title": "collapse UUID registration in URN name space",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/71",
      "state": "MERGED",
      "author": "mcr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-03-27T10:03:35Z",
      "updatedAt": "2023-04-06T13:36:33Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "2321d5c492ba2f1bb568bcbbeff5dc0dfa25e017",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "iana-suggestions",
      "headRefOid": "0f0078bf5f492e32ce73bbf29d49eed068646b5a",
      "closedAt": "2023-04-06T13:36:21Z",
      "mergedAt": "2023-04-06T13:36:21Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Also meant to comment as per my note on the mailer:\r\nI received confirmation from Gonzalo Salgueiro that the IANA template can be dropped assuming we have nothing new to add or update so that part looks good.",
          "createdAt": "2023-03-27T19:53:51Z",
          "updatedAt": "2023-03-27T19:53:51Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5RDIK6",
          "commit": {
            "abbreviatedOid": "9c0514d"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-03-27T19:51:10Z",
          "updatedAt": "2023-03-27T19:51:16Z",
          "comments": [
            {
              "originalPosition": 51,
              "body": "Replied on the mailer, we decided we DO NOT want them to have registrations for these items and there are no current registrations so there is nothing to update.",
              "createdAt": "2023-03-27T19:51:11Z",
              "updatedAt": "2023-03-27T19:51:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 76,
      "id": "PR_kwDOH6Ln3M5NyIwA",
      "title": "Draft 03",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/76",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- #67\r\n- #70\r\n- #69\r\n- #66\r\n- #65\r\n- #73\r\n- #68\r\n- #74\r\n- Misc formatting changes to address IDNITS feedback\r\n- #75",
      "createdAt": "2023-04-06T16:14:09Z",
      "updatedAt": "2023-04-11T13:53:55Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-03",
      "headRefOid": "64c64838c5fcf32f78328131ad433fc1211a5b44",
      "closedAt": "2023-04-11T13:53:55Z",
      "mergedAt": "2023-04-11T13:53:55Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "d123ba9fa37c401721b71b12ce95d99e30016ae9"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 77,
      "id": "PR_kwDOH6Ln3M5N2OBi",
      "title": "Formatting suggestions",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/77",
      "state": "CLOSED",
      "author": "mcr",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This deals with the code nit, and turns the examples into tables.\r\n",
      "createdAt": "2023-04-07T16:34:48Z",
      "updatedAt": "2023-04-11T13:53:27Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "formatting-suggestions",
      "headRefOid": "a4b4db9172f3b6794d669a0779d6e6cd82124d1a",
      "closedAt": "2023-04-11T13:53:26Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Discussed on mailer, the HTML tables are pretty ugly and break up the formatting flow for these appendix sections.\r\n\r\nMain driver to get these to tables was to fix the idnits errors; however, I was able to fix that in #76 so these can stay as ascii and thematically all the examples are the same format. Which is a bit easier on the eyes IMO.\r\n\r\nAs such, I have committed the `~~~~ code` changes under https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/76/commits/64c64838c5fcf32f78328131ad433fc1211a5b44 so I will close this PR and merge that to main.",
          "createdAt": "2023-04-11T13:53:26Z",
          "updatedAt": "2023-04-11T13:53:26Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SJTwU",
          "commit": {
            "abbreviatedOid": "a4b4db9"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Couple of small typos. Haven't rendered it to see how the tables look but assume someone has.",
          "createdAt": "2023-04-10T21:44:17Z",
          "updatedAt": "2023-04-10T21:47:48Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "```suggestion\r\nrandom_a   | 48  |    0x919108f752d1 |\r\n```",
              "createdAt": "2023-04-10T21:44:17Z",
              "updatedAt": "2023-04-10T21:47:48Z"
            },
            {
              "originalPosition": 251,
              "body": "```suggestion\r\ncustom_a  |  48   | 0x320C3D4DCC00  |\r\n```",
              "createdAt": "2023-04-10T21:45:39Z",
              "updatedAt": "2023-04-10T21:47:48Z"
            }
          ]
        }
      ]
    },
    {
      "number": 78,
      "id": "PR_kwDOH6Ln3M5N4UV4",
      "title": "typographical fixes",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/78",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Some typo fixes, hopefully zero controversy.",
      "createdAt": "2023-04-09T00:13:08Z",
      "updatedAt": "2023-04-11T13:58:55Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "d123ba9fa37c401721b71b12ce95d99e30016ae9",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230407-typographical",
      "headRefOid": "74f669629ab0fb1672e8f87a17c6cab3aac46346",
      "closedAt": "2023-04-11T13:58:54Z",
      "mergedAt": "2023-04-11T13:58:54Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "4b49bbe28476d66fea49bb4544eaba7c38dda090"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Merging #76 to main caused some merge conflicts. Will fix and merge this as well.",
          "createdAt": "2023-04-11T13:56:10Z",
          "updatedAt": "2023-04-11T13:56:10Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SJVFQ",
          "commit": {
            "abbreviatedOid": "87d8a0b"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "Looks good. As editors, you can assume consensus on editorial things like this; don't let approvals hold you up.",
          "createdAt": "2023-04-10T21:50:49Z",
          "updatedAt": "2023-04-10T21:50:49Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJVW-",
          "commit": {
            "abbreviatedOid": "87d8a0b"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Oops, meant to approve",
          "createdAt": "2023-04-10T21:52:17Z",
          "updatedAt": "2023-04-10T21:52:17Z",
          "comments": []
        }
      ]
    },
    {
      "number": 79,
      "id": "PR_kwDOH6Ln3M5N4WTP",
      "title": "clarifications",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/79",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here are some clarifications I'd like to make on various pieces of text.  These shouldn't have a significant semantic change in terms of what we are specifying, but hopefully provide more clarity on specific topics that I though should have a bit more detail.  I'll also add some review notes to give more on the motivation for each change in cases where it may not be obvious.",
      "createdAt": "2023-04-09T01:07:31Z",
      "updatedAt": "2023-04-11T14:09:38Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "4b49bbe28476d66fea49bb4544eaba7c38dda090",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230408-clarifications",
      "headRefOid": "8ec22e8e6a1457036662af7bd0268e3c980b7e13",
      "closedAt": "2023-04-11T14:09:38Z",
      "mergedAt": "2023-04-11T14:09:38Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "ab9e03fe1e0e1a7f10d973712f50b9af9f78fcca"
      },
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@jimfenton I agree with all of your edits, those have been updated.",
          "createdAt": "2023-04-10T23:55:47Z",
          "updatedAt": "2023-04-10T23:55:47Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Fixed merge conflicts, good to go, merging down.",
          "createdAt": "2023-04-11T14:09:31Z",
          "updatedAt": "2023-04-11T14:09:31Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SEKB4",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:09:00Z",
          "updatedAt": "2023-04-09T01:09:01Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I think it's important to not over-promise here - we can't actually guarantee uniqueness, but we can deliver a high probability. I think the wording should reflect that.",
              "createdAt": "2023-04-09T01:09:01Z",
              "updatedAt": "2023-04-09T03:49:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKDW",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:10:37Z",
          "updatedAt": "2023-04-09T01:10:38Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This language is from the old RFC, and I'm not sure it makes sense to leave in here.  If we're going to say that there is another document that takes precedence over this one then we should link to it and make it part of the formal spec, otherwise I think we should just take this reference to DCE standards out.",
              "createdAt": "2023-04-09T01:10:37Z",
              "updatedAt": "2023-04-09T01:10:38Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKFH",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:12:55Z",
          "updatedAt": "2023-04-09T01:12:56Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "With the bit space available it is possible to generate much more than 10 million identifiers per second so I think we should indicate that so people don't think it's somehow hard-limited to this.",
              "createdAt": "2023-04-09T01:12:55Z",
              "updatedAt": "2023-04-09T01:12:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKFm",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:13:29Z",
          "updatedAt": "2023-04-09T01:13:29Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "Since the recommendation is that applications use an internal binary representation, I think it makes mores sense to indicate that if an application has to use text, it should use this format.",
              "createdAt": "2023-04-09T01:13:29Z",
              "updatedAt": "2023-04-09T16:47:35Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKF5",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:13:52Z",
          "updatedAt": "2023-04-09T01:13:53Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Just to clarify that it's decimal",
              "createdAt": "2023-04-09T01:13:53Z",
              "updatedAt": "2023-04-09T01:13:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKGV",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:14:18Z",
          "updatedAt": "2023-04-09T01:14:18Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "We might as well include the exact number of bits here - 122 - since we mention it.",
              "createdAt": "2023-04-09T01:14:18Z",
              "updatedAt": "2023-04-09T01:14:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKGq",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:14:40Z",
          "updatedAt": "2023-04-09T01:14:40Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I think it's helpful to provide some context as to why this is here.",
              "createdAt": "2023-04-09T01:14:40Z",
              "updatedAt": "2023-04-09T01:14:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKG9",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:15:00Z",
          "updatedAt": "2023-04-09T01:15:00Z",
          "comments": [
            {
              "originalPosition": 91,
              "body": "Same thing, just so there's no question about the rationale for this.",
              "createdAt": "2023-04-09T01:15:00Z",
              "updatedAt": "2023-04-09T01:15:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKHQ",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:15:14Z",
          "updatedAt": "2023-04-09T01:15:14Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "It doesn't necessarily format as a \"bullet\"",
              "createdAt": "2023-04-09T01:15:14Z",
              "updatedAt": "2023-04-09T01:15:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKIh",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:16:19Z",
          "updatedAt": "2023-04-09T01:16:19Z",
          "comments": [
            {
              "originalPosition": 109,
              "body": "I think this communicates the point - an implementation, wherever possible, should prevent a duplicate value from being returned as part of being a correct implementation.  Or to state it another way: if you could have easily prevented returning a value but did not, that's a bug that should be fixed.",
              "createdAt": "2023-04-09T01:16:19Z",
              "updatedAt": "2023-04-09T16:49:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKJa",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:17:35Z",
          "updatedAt": "2023-04-09T01:17:36Z",
          "comments": [
            {
              "originalPosition": 118,
              "body": "I think providing the inline definition of \"monotonicity\" here is helpful, since strictly speaking from the mathematical definition this could also describe values that count down, or that count in a constant direction based on specific input.  We might as well spell out exactly what we mean here.",
              "createdAt": "2023-04-09T01:17:35Z",
              "updatedAt": "2023-04-09T01:17:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKJs",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:18:17Z",
          "updatedAt": "2023-04-09T01:18:17Z",
          "comments": [
            {
              "originalPosition": 128,
              "body": "Batch creation is an important use case but really this section applies to any code that is concerned about creating a whole bunch of UUIDs on a single node, so I think the additional wording helps with that.",
              "createdAt": "2023-04-09T01:18:17Z",
              "updatedAt": "2023-04-09T01:18:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKKo",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:19:32Z",
          "updatedAt": "2023-04-09T01:19:32Z",
          "comments": [
            {
              "originalPosition": 137,
              "body": "I think it's helpful to indicate that if the implementation gets into some sort of pickle where it cannot return a unique ID, that returning an error instead is perhaps the right behavior.",
              "createdAt": "2023-04-09T01:19:32Z",
              "updatedAt": "2023-04-09T01:19:32Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKLG",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:20:06Z",
          "updatedAt": "2023-04-09T01:20:06Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "I know we say MAY in the next paragraph but when I read this again it seemed to communicate that this was an expected part of the implementation, so I think adding this helps.",
              "createdAt": "2023-04-09T01:20:06Z",
              "updatedAt": "2023-04-09T01:20:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKL2",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:21:13Z",
          "updatedAt": "2023-04-09T01:21:13Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Do we really want to suggest to people that they use the namespace variant?  If a system has let's say a known insecure random number generator, then sure that is going to affect the quality of the output, but I'm not sure that's a strong enough concern to suggest the namespace variant.",
              "createdAt": "2023-04-09T01:21:13Z",
              "updatedAt": "2023-04-09T01:21:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKME",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:21:53Z",
          "updatedAt": "2023-04-09T01:21:53Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "Same logic as earlier - we can't guarantee uniqueness in all cases, we're basically saying it's good enough for practical purposes.",
              "createdAt": "2023-04-09T01:21:53Z",
              "updatedAt": "2023-04-09T01:21:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKNl",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:23:21Z",
          "updatedAt": "2023-04-09T01:23:22Z",
          "comments": [
            {
              "originalPosition": 178,
              "body": "I think this helps give more guidance on the opacity concern.  My rationale here is that people writing UUID libraries and such will have to make a decision about how much parsing capability to include, and I don't want people to feel compelled to provide a bunch of detailed parsing, when one of the whole drives of these new UUIDs is that they are more useful as opaque values.  So with this wording I think it's more clear and will ease the implementation burden.",
              "createdAt": "2023-04-09T01:23:21Z",
              "updatedAt": "2023-04-09T01:23:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJWAt",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T21:55:42Z",
          "updatedAt": "2023-04-10T21:55:42Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "I've been wondering why they call this a \"nil UUID\" rather than a \"null UUID\" (which makes more sense to me), but I think that ship has already sailed.",
              "createdAt": "2023-04-10T21:55:42Z",
              "updatedAt": "2023-04-10T21:55:42Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJW_j",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Minor suggestions, otherwise ready to go.",
          "createdAt": "2023-04-10T21:59:51Z",
          "updatedAt": "2023-04-10T22:02:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Serial comma:\r\n```suggestion\r\nto implement services using UUIDs, as URNs {{RFC8141}}, or otherwise.\r\n```",
              "createdAt": "2023-04-10T21:59:52Z",
              "updatedAt": "2023-04-10T22:02:04Z"
            },
            {
              "originalPosition": 32,
              "body": "\"up to...or more\" doesn't really make sense:\r\n```suggestion\r\nhigh allocation rates of 10 million per second per machine or more if\r\n```",
              "createdAt": "2023-04-10T22:00:46Z",
              "updatedAt": "2023-04-10T22:02:04Z"
            },
            {
              "originalPosition": 91,
              "body": "```suggestion\r\nA Max UUID value can be used as a sentinel value in situations where a 128-bit UUID is required but a concept such as \"end of UUID list\" needs to be expressed, and is reserved for such use as needed for implementation-specific situations.\r\n```",
              "createdAt": "2023-04-10T22:01:34Z",
              "updatedAt": "2023-04-10T22:02:04Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SNykj",
          "commit": {
            "abbreviatedOid": "cdf2f49"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-11T14:05:44Z",
          "updatedAt": "2023-04-11T14:05:45Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "This was text from 4122: https://www.rfc-editor.org/rfc/rfc4122#section-6\r\n\r\nIf we want to have a larger discussion about this text I am fine with opening an issue and shooting something to the mailer. ",
              "createdAt": "2023-04-11T14:05:44Z",
              "updatedAt": "2023-04-11T14:05:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 80,
      "id": "PR_kwDOH6Ln3M5N4XAS",
      "title": "some SHOULD/MUST adjustments",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/80",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "These are a few SHOULD/MUST adjustments that I think help improve the accuracy.  I won't die over these but would be good to merge if others agree.",
      "createdAt": "2023-04-09T01:31:23Z",
      "updatedAt": "2023-04-11T14:11:23Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230408-should-must-ify",
      "headRefOid": "b0170a733c86c6b1a8f56b89d13739fa5fbc7e27",
      "closedAt": "2023-04-11T14:11:23Z",
      "mergedAt": "2023-04-11T14:11:23Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "1a742f443fde44309790fa95b7d93e3c752db5a7"
      },
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@jimfenton Thanks for the feedback, I've fixed the issues you brought up.",
          "createdAt": "2023-04-10T23:45:04Z",
          "updatedAt": "2023-04-10T23:45:04Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SEKUD",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:32:25Z",
          "updatedAt": "2023-04-09T01:32:25Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Since all of the time UUIDs only use either Gregorian or Unix timestamp, and v8 is the only option where you can do something else, it should be fine to convert this to a MUST.",
              "createdAt": "2023-04-09T01:32:25Z",
              "updatedAt": "2023-04-09T01:32:25Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKV6",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:34:59Z",
          "updatedAt": "2023-04-09T01:35:00Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "My concern on this one is that stalling the clock or erroring are not necessarily the only viable solutions to this problem.  But I'm on the fence on this one.  I think I also added separately in another PR a \"MUST NOT\" sentence that says the thing that it really cannot do is return a knowingly duplicated value, which I think is the key point to stress here.",
              "createdAt": "2023-04-09T01:34:59Z",
              "updatedAt": "2023-04-09T01:35:00Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKWe",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:35:57Z",
          "updatedAt": "2023-04-09T01:35:58Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This entire thing is a suggestion, so I'm not sure it makes sense to use MUST here, it's sort of like saying \"this is just advice and only way to solve the problem, but if you're listing, you MUST do it this way...\" - I think a SHOULD makes more sense.",
              "createdAt": "2023-04-09T01:35:57Z",
              "updatedAt": "2023-04-09T01:35:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SEKXS",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T01:37:04Z",
          "updatedAt": "2023-04-09T01:37:04Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "While I like the notion that careless implementations are incorrect \ud83d\ude04, I'm not sure that saying people MUST take here works here.  Probably better to just take it out.",
              "createdAt": "2023-04-09T01:37:04Z",
              "updatedAt": "2023-04-09T01:37:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJYA3",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "A couple of suggestions here. Please avoid language like \"Care SHOULD/MUST be taken\" (e.g., line 1208) because it's not possible to verify whether care was taken or not, only whether the thing was done. Use the more straightforward imperative; it's also something that can be verified.",
          "createdAt": "2023-04-10T22:05:17Z",
          "updatedAt": "2023-04-10T22:14:14Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "```suggestion\r\n: Select a counter bit-length that can properly handle\r\n```",
              "createdAt": "2023-04-10T22:05:17Z",
              "updatedAt": "2023-04-10T22:14:14Z"
            },
            {
              "originalPosition": 23,
              "body": "The text is saying here that there are two ways to solve the problem. If the second choice is used and the counter isn't incremented, the problem isn't necessarily solved. I prefer the MUST.",
              "createdAt": "2023-04-10T22:10:36Z",
              "updatedAt": "2023-04-10T22:14:14Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJbHj",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T22:20:49Z",
          "updatedAt": "2023-04-10T22:20:49Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Okay cool, I'm all good with striking this change then and leaving it how it was (MUST).",
              "createdAt": "2023-04-10T22:20:49Z",
              "updatedAt": "2023-04-10T22:20:49Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJncC",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "greatestape",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T23:35:26Z",
          "updatedAt": "2023-04-10T23:35:26Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Should this be in passive voice like the text above it? Like \"Implementations using a fixed-length counter method SHOULD use a counter bit-length that can properly handle the level of timestamp precision in use.\"\r\n\r\n(Sorry, I'm just lurking and cheering you all on! I'm excited for uuidv7!)",
              "createdAt": "2023-04-10T23:35:26Z",
              "updatedAt": "2023-04-10T23:48:22Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJoYn",
          "commit": {
            "abbreviatedOid": "0c249db"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-10T23:42:45Z",
          "updatedAt": "2023-04-10T23:42:46Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "@greatestape thanks for the suggestion, I think Jim's suggested edit handles it though, I'll proceed with that.",
              "createdAt": "2023-04-10T23:42:45Z",
              "updatedAt": "2023-04-10T23:42:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 81,
      "id": "PR_kwDOH6Ln3M5N5FJW",
      "title": "add two more methods to the monotonic section",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/81",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After reading through everything again, while the monotonic/counter section works as it stands now, I think it would greatly benefit from two other specific suggested methods for achieving monotonicity.\r\n\r\nThe first I think is beneficial because it is trivial to implement (just keep generating random values until you get one that is greater than the last), and implementors prioritizing simplicity would benefit from it.\r\n\r\nAnd the second brings back a concept that I originally proposed in the initial draft for UUID v7 (using bits in the UUID that immediately follow the timestamp to encode more timestamp precision in a way that is time ordered), but later removed because it was often misunderstood.  However, I think the key benefit to this approach (just using the additional precision available in the system clock for what it is meant for) still exists and makes sense, and having it here as an optional feature so implementations are not required to understand and use it if they don't need to - I believe that tradeoff makes a lot of sense.  I tried to keep it super simple by just giving an example of how to use it, and people can infer the underlying math/theory or not as needed.",
      "createdAt": "2023-04-09T17:55:16Z",
      "updatedAt": "2023-04-11T14:17:45Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "b7b43690b138760c7a3d47e2e72f4da7fdaef8eb",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230408-timestamp-stuff",
      "headRefOid": "2711ac4300090ca52218c23ffc70987bfc3406c9",
      "closedAt": "2023-04-11T14:17:45Z",
      "mergedAt": "2023-04-11T14:17:45Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "9927b324d497741f9ff16446da46e8b4ce3184c7"
      },
      "comments": [
        {
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "body": "@jimfenton Thanks for the feedback, I did the edits you suggested and split up Method 4 into a few paragraphs and added a normative description as you suggest.  Let me know if there's anything else you think I should adjust immediately and otherwise I agree it would be good to get more feedback from others and go from there.",
          "createdAt": "2023-04-11T01:14:30Z",
          "updatedAt": "2023-04-11T01:14:30Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Verified Method 3 and 4 render properly with author-tools in HTML/TXT formats. Merging down.",
          "createdAt": "2023-04-11T14:17:40Z",
          "updatedAt": "2023-04-11T14:17:40Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5SEnj0",
          "commit": {
            "abbreviatedOid": "e347984"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-04-09T18:16:42Z",
          "updatedAt": "2023-04-09T18:16:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "This is the same edit from here https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/79#discussion_r1161177270",
              "createdAt": "2023-04-09T18:16:42Z",
              "updatedAt": "2023-04-09T18:16:43Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5SJa4R",
          "commit": {
            "abbreviatedOid": "e347984"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "CHANGES_REQUESTED",
          "body": "Mostly editorial fixes suggested; I think we need more input on this. They both need to be expressed in normative language\r\n\r\nMethod 4 mixes the normative requirements with an example. Suggest pulling the example into one or more separate paragraphs so the reader can distinguish between what they are required to do and the example of how to do it.",
          "createdAt": "2023-04-10T22:19:32Z",
          "updatedAt": "2023-04-10T22:25:01Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "```suggestion\r\n  of implementation. One downside to this approach is the fact that\r\n```",
              "createdAt": "2023-04-10T22:19:32Z",
              "updatedAt": "2023-04-10T22:25:01Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n  generation will become increasingly slow for a given timestamp value as\r\n```",
              "createdAt": "2023-04-10T22:20:02Z",
              "updatedAt": "2023-04-10T22:25:01Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n  more attempts are required to produce monotonic output, and the fact that\r\n```",
              "createdAt": "2023-04-10T22:20:32Z",
              "updatedAt": "2023-04-10T22:25:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 82,
      "id": "PR_kwDOH6Ln3M5OYskQ",
      "title": "Removed extra \"seconds\" word",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/82",
      "state": "MERGED",
      "author": "oittaa",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-04-15T13:05:53Z",
      "updatedAt": "2023-05-10T18:06:45Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "e54464db613a65b7f30d53035ecb3ccb48dbd492",
      "headRepository": "oittaa/rfc4122bis",
      "headRefName": "patch-1",
      "headRefOid": "ddc3f1d0c0a66706e98997be41a1ce1063c791b6",
      "closedAt": "2023-05-10T18:06:44Z",
      "mergedAt": "2023-05-10T18:06:44Z",
      "mergedBy": "mcr",
      "mergeCommit": {
        "oid": "ab9e948e6f73c494fc099d0aad38ff09bacda867"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 84,
      "id": "PR_kwDOH6Ln3M5QgtwF",
      "title": "Punctuation and minor style fixes",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/84",
      "state": "MERGED",
      "author": "petere",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly add and remove some commas, some titlecase fixes, and random odd bits.",
      "createdAt": "2023-05-15T12:56:30Z",
      "updatedAt": "2023-05-15T13:31:57Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "ab9e948e6f73c494fc099d0aad38ff09bacda867",
      "headRepository": "petere/rfc4122bis",
      "headRefName": "style-fixes",
      "headRefOid": "ac65eb8bc43871656fcaf86983f0b754651a8a87",
      "closedAt": "2023-05-15T13:31:57Z",
      "mergedAt": "2023-05-15T13:31:56Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @petere! ",
          "createdAt": "2023-05-15T13:31:45Z",
          "updatedAt": "2023-05-15T13:31:45Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 88,
      "id": "PR_kwDOH6Ln3M5Qzn8I",
      "title": "Remove extra words",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/88",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-18T13:20:46Z",
      "updatedAt": "2023-05-23T14:38:45Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "6624c2c7b1e177ad1df92f26e93a99e3fe7a42cc",
      "closedAt": "2023-05-23T14:38:45Z",
      "mergedAt": "2023-05-23T14:38:45Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "0f776572716418d4cb3a2bc886cb5914f01077f1"
      },
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "https://github.com/ietf-wg-uuidrev/rfc4122bis/commit/ddc3f1d0c0a66706e98997be41a1ce1063c791b6 edited a different file, didn't it?",
          "createdAt": "2023-05-18T13:22:24Z",
          "updatedAt": "2023-05-18T13:22:24Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 90,
      "id": "PR_kwDOH6Ln3M5Q7jLv",
      "title": "Change rounding mode of Method 4 Section 6.2",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/90",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Changes the rounding mode demonstrated in Replace Left-Most Random Bits with Increased Clock Precision (Method 4) from ties-to-nearest to round-down-toward-zero.\r\n\r\nhttps://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86#issuecomment-1548940686",
      "createdAt": "2023-05-20T00:41:38Z",
      "updatedAt": "2023-05-23T14:47:31Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": null,
      "headRefName": "rounding",
      "headRefOid": "1f411ba21fd84c31498f0ce30a13d303a97cb99d",
      "closedAt": "2023-05-23T14:47:31Z",
      "mergedAt": "2023-05-23T14:47:30Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "c08c9da7a7567c49a7a3f5e493f5a48e9588d6fc"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 91,
      "id": "PR_kwDOH6Ln3M5Q7qE0",
      "title": "Add verbal description of v7 generation to 5.7. UUID Version 7",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/91",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Whether to limit the size of Method 4 clock precision is still under discussion in https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86, but aside from that point, I believe we should update the 5.7. UUID Version 7 section to make it consistent with Method 4.\r\n\r\nThe UUIDv7 structure is currently hard to understand because in my opinion it lacks a verbal description of the generation algorithm other than the field definitions below the layout figure, while other versions include some textual descriptions in their respective sections.\r\n\r\nAs a starting point, I have summarized my understanding as follows and created this PR.\r\n\r\n> UUIDv7 values are created by allocating a Unix timestamp in milliseconds in the most significant 48 bits and filling the remaining 74 bits, jointly, excluding the required version and variant bits, with a combination of the following subfields, in this order from the most significant bits to the least:\r\n>\r\n> 1. An OPTIONAL submillisecond timestamp fraction to utilize extra clock precision as per Section 6.2 (Method 4).\r\n> 2. An OPTIONAL carefully seeded counter to guarantee additional monotonicity as per Section 6.2 (Method 1 or 2).\r\n> 3. Random data for each new UUIDv7 generated to provide uniqueness as per Section 6.8 for any remaining space.\r\n\r\nAs @bradleypeabody pointed out in https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86#issuecomment-1553990440, there are some disagreements around here, so discussion and consensus are definitely needed.\r\n",
      "createdAt": "2023-05-20T02:50:27Z",
      "updatedAt": "2023-05-23T14:52:05Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": null,
      "headRefName": "describe_v7",
      "headRefOid": "c0d445d569493d3ec99fa650948bc935de7b9e9b",
      "closedAt": "2023-05-23T14:52:05Z",
      "mergedAt": "2023-05-23T14:52:05Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "12dbda1bb565ac1c514112b02051f3a567b4b21c"
      },
      "comments": [
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Note: Once the size of Method 4 extra timestamp is limited to 12 bits as per https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/86:\r\n\r\n- Insert the threshold like: \"1. An OPTIONAL submillisecond timestamp fraction <ins>(12 bits at maximum) </ins>to utilize extra clock precision as per Section 6.2 (Method 4).\"\r\n- Revert the `rand_b` field description because it won't accommodate extra clock precision: \"The final 62 bits of pseudo-random data to provide uniqueness as per Section 6.8 and/or an optional counter to guarantee additional monotonicity as per Section 6.2.\"\r\n\r\nNote: Method 4 must be renamed to Method 3 once https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/92 is accepted.",
          "createdAt": "2023-05-21T01:48:03Z",
          "updatedAt": "2023-05-21T01:48:03Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 92,
      "id": "PR_kwDOH6Ln3M5Q8sAc",
      "title": "Remove Re-randomize Until Monotonic (Method 3) from Monotonicity and Counters",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/92",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/87",
      "createdAt": "2023-05-21T01:21:31Z",
      "updatedAt": "2023-05-23T14:54:55Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": null,
      "headRefName": "rem_method_3",
      "headRefOid": "34d47354712c12ee8a018cb34eded00338119937",
      "closedAt": "2023-05-23T14:54:54Z",
      "mergedAt": "2023-05-23T14:54:54Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "b224cb8e76ce3bd0259eaa16f5c90ed820e36462"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 93,
      "id": "PR_kwDOH6Ln3M5Q96yr",
      "title": "Remove extra \"a\"",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/93",
      "state": "MERGED",
      "author": "DianaNites",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-05-22T01:51:26Z",
      "updatedAt": "2023-05-23T14:55:20Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f74f4a13bb1b860e3fe9bb4c708b50e40f922c1d",
      "headRepository": "DianaNites/rfc4122bis",
      "headRefName": "patch-1",
      "headRefOid": "83b5eadcba76fd75396bd09ddf07b4f4c09170e2",
      "closedAt": "2023-05-23T14:55:19Z",
      "mergedAt": "2023-05-23T14:55:19Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "e2b5021f4fad65cd1de30bc4ae0425f687695230"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5VkuUU",
          "commit": {
            "abbreviatedOid": "83b5ead"
          },
          "author": "cbandy",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2023-05-22T02:44:00Z",
          "updatedAt": "2023-05-22T02:44:00Z",
          "comments": []
        }
      ]
    },
    {
      "number": 94,
      "id": "PR_kwDOH6Ln3M5RKnc6",
      "title": "WGLC Midterm Merge",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/94",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Fix ambiguous text around UUIDv6 clock sequence #89\r\n- Move endianness statement from layout to format section #85\r\n- Further modified abstract to separate URN topic from UUID definition #83\r\n- Provided three more UUID format examples #83\r\n- Added text further clarifying version construct is for the variant in this doc #83\r\n- Provided further clarification for local/global bit vs multicast bit #83",
      "createdAt": "2023-05-23T16:37:26Z",
      "updatedAt": "2023-05-23T16:39:28Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "e2b5021f4fad65cd1de30bc4ae0425f687695230",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "wglc-midterm",
      "headRefOid": "b930708ead92fa13a6372f69bc1669532549224c",
      "closedAt": "2023-05-23T16:39:23Z",
      "mergedAt": "2023-05-23T16:39:23Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "91de9d156d5e40f76089ae2898fce9ddfd1b63fa"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 96,
      "id": "PR_kwDOH6Ln3M5RPA1o",
      "title": "Align Method 3 text with the 12 bits limitation",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/96",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Would propose small changes to Method 3 (the old Method 4) to align with the 12 bits limitation.\r\n\r\n#86",
      "createdAt": "2023-05-24T11:09:37Z",
      "updatedAt": "2023-06-04T08:18:17Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "aaa7ac9a90c9a541ed06747ed1ec075ce036e1bd",
      "headRepository": null,
      "headRefName": "cleanup_method3",
      "headRefOid": "e40267ba59d0f86ef599ac67ce5aa4a9b73a54d0",
      "closedAt": "2023-05-31T17:30:13Z",
      "mergedAt": "2023-05-31T17:30:13Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "4da59acdb289ba82281ad7c93cec96ce4ba274ca"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 97,
      "id": "PR_kwDOH6Ln3M5RPEZ7",
      "title": "Make Version/version casing consistent across 5. UUID Layouts",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/97",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Fix inconsistent casing of \"UUID Version X\" and \"UUID version X\" in Section 5. UUID Layouts. Though I am not sure if \"version\" is better than \"Version\" or not, at least the lowercase \"version\" improves consistency across the document.",
      "createdAt": "2023-05-24T11:19:36Z",
      "updatedAt": "2023-06-04T08:18:18Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "aaa7ac9a90c9a541ed06747ed1ec075ce036e1bd",
      "headRepository": null,
      "headRefName": "consistent_casing",
      "headRefOid": "ffa95bcf498cf70be901ec2720bf977de95c55b0",
      "closedAt": "2023-05-31T17:30:41Z",
      "mergedAt": "2023-05-31T17:30:41Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "2622a764820d0e5b98b7519b4e168b8f44be2ef6"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 98,
      "id": "PR_kwDOH6Ln3M5R0P0y",
      "title": "changelog + max/omni changes",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/98",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For #95 item 3",
      "createdAt": "2023-05-31T17:51:31Z",
      "updatedAt": "2023-05-31T17:52:24Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "2622a764820d0e5b98b7519b4e168b8f44be2ef6",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "max-omni",
      "headRefOid": "497365b39da48361cae843afa5c76c02cb758119",
      "closedAt": "2023-05-31T17:52:21Z",
      "mergedAt": "2023-05-31T17:52:21Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "00adb7bdfcf674d824ceaadc00dcc04a917469e5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 100,
      "id": "PR_kwDOH6Ln3M5SCMSO",
      "title": "Cite MS COM GUID as Little-Endian",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/100",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-02T20:27:16Z",
      "updatedAt": "2023-06-02T20:27:22Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "00adb7bdfcf674d824ceaadc00dcc04a917469e5",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "wglc-endian",
      "headRefOid": "b968306ba430fc62f9d4d820422305f19c828762",
      "closedAt": "2023-06-02T20:27:22Z",
      "mergedAt": "2023-06-02T20:27:22Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "6899be343f3c56ed5b7d5dcf24c19f3c836fd53f"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 102,
      "id": "PR_kwDOH6Ln3M5SHaje",
      "title": "Fix typos and missing verbs",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/102",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Not fully confident though about the correction to \"There many other ways to define a UUID format some select methods are detailed below.\"",
      "createdAt": "2023-06-04T10:19:17Z",
      "updatedAt": "2023-06-07T23:39:10Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "71475662721b02eb2ae89e07f8c1826783addffb",
      "headRepository": null,
      "headRefName": "missing_verbs",
      "headRefOid": "9d69ece2b0d1727b0d76d85c20a98f39d0961c77",
      "closedAt": "2023-06-05T19:11:46Z",
      "mergedAt": "2023-06-05T19:11:46Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "be1f7cff77ec5b6ff67fd7511b960ead083d0b04"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 103,
      "id": "PR_kwDOH6Ln3M5SIHrJ",
      "title": "Tweak v7 description to de-emphasize optional components",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/103",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Closes #101 ",
      "createdAt": "2023-06-04T17:38:06Z",
      "updatedAt": "2023-06-07T23:39:08Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "71475662721b02eb2ae89e07f8c1826783addffb",
      "headRepository": null,
      "headRefName": "tweak_v7_description",
      "headRefOid": "b1731a8ffced6e34d86d5898cd172765ab6cc78c",
      "closedAt": "2023-06-05T19:13:03Z",
      "mergedAt": "2023-06-05T19:13:03Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "f0fe826502e6722a657385063b34a399310323a2"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 106,
      "id": "PR_kwDOH6Ln3M5SOz9Y",
      "title": "WGLC: Paul's Feedback",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/106",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Closes #104 \r\n- Closes #105 \r\n\r\nWill merge once I have confirmation from the Chairs to change Paul's email.",
      "createdAt": "2023-06-05T19:29:22Z",
      "updatedAt": "2023-06-06T14:37:54Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f0fe826502e6722a657385063b34a399310323a2",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "wglc-paul",
      "headRefOid": "9fd81bfa5724a49e0dc105ff79d4da17b6807838",
      "closedAt": "2023-06-06T14:37:26Z",
      "mergedAt": "2023-06-06T14:37:26Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "818b2887fc0693ec094f85573830d877d5f6be35"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Has there been contact with Michael Mealling, who is listed as an author? I haven't seen him on the mailing list. I think the RFC Editor wants to contact all of the listed authors prior to publication, and we should make sure he's on board with this.\r\n\r\nNothing from Michael that I could find in my inbox.\r\n\r\nEdit: merging to get a draft sent up by EOB. We can take this convo to email if needed.",
          "createdAt": "2023-06-06T14:27:30Z",
          "updatedAt": "2023-06-06T14:37:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5XPO8B",
          "commit": {
            "abbreviatedOid": "c864e71"
          },
          "author": "jimfenton",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Change of Paul Leach's contact information is fine; it was at his request, after all.\r\n\r\nHas there been contact with Michael Mealling, who is listed as an author? I haven't seen him on the mailing list. I think the RFC Editor wants to contact all of the listed authors prior to publication, and we should make sure he's on board with this.\r\n\r\nSince you asked for an approval, I have a small wording suggestion, which you are free to ignore.",
          "createdAt": "2023-06-05T22:18:31Z",
          "updatedAt": "2023-06-05T22:29:47Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "```suggestion\r\nThere are many other ways to define a UUID format; some examples are detailed below.\r\n```",
              "createdAt": "2023-06-05T22:18:31Z",
              "updatedAt": "2023-06-05T22:29:47Z"
            }
          ]
        }
      ]
    },
    {
      "number": 108,
      "id": "PR_kwDOH6Ln3M5Sdu9D",
      "title": "Remove unnecessary \"32 bit\" in UUIDv7 example",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/108",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This was perhaps the cause of confusion #99",
      "createdAt": "2023-06-08T00:03:11Z",
      "updatedAt": "2023-06-09T13:03:09Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "324b7d2301d3851d33d63bf9a1c5dea8c51073d8",
      "headRepository": null,
      "headRefName": "rem_32bit",
      "headRefOid": "dffac1823493657e27d25cd556183b9901a9046c",
      "closedAt": "2023-06-09T13:03:09Z",
      "mergedAt": "2023-06-09T13:03:08Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "9ec371e52be95b294a7f3a7d23b932893d566d74"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 109,
      "id": "PR_kwDOH6Ln3M5Sd48u",
      "title": "Fix grammar and punctuations",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/109",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-08T00:54:56Z",
      "updatedAt": "2023-06-09T13:03:50Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "324b7d2301d3851d33d63bf9a1c5dea8c51073d8",
      "headRepository": null,
      "headRefName": "grammatical",
      "headRefOid": "3f02fb5c748a44be4719e8ff1a954a1a3980025c",
      "closedAt": "2023-06-09T13:03:50Z",
      "mergedAt": "2023-06-09T13:03:50Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "78e917b04b3386c62102b4de0e93afe2e8ac31e8"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 110,
      "id": "PR_kwDOH6Ln3M5SeZfO",
      "title": "Change \"fixed millisecond\" -> \"millisecond by default\" relating to v7\u2026",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/110",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 in Sub-second Precision and Accuracy section\r\n\r\nNow UUIDv7 may have sub-millisecond precition because of Method 3.",
      "createdAt": "2023-06-08T04:04:19Z",
      "updatedAt": "2023-06-09T13:04:22Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "324b7d2301d3851d33d63bf9a1c5dea8c51073d8",
      "headRepository": null,
      "headRefName": "v7_consistency",
      "headRefOid": "3cab0364f42955cee9d5703b9f809efdd5ed701c",
      "closedAt": "2023-06-09T13:04:22Z",
      "mergedAt": "2023-06-09T13:04:22Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "81ddd1ae08ada06326bf8175aa02102649efd0b1"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 111,
      "id": "PR_kwDOH6Ln3M5SfhH_",
      "title": "Omit UUIDv6 in UUIDs that Do Not Identify the Host",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/111",
      "state": "CLOSED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Could be controversial, but I think we can omit UUIDv6 from the UUIDs that Do Not Identify the Host section. The spec is clear without the name of UUIDv6 here that UUIDv6 MAY follow this section, but this section remains mostly for backward compatibility and is not a primary path for UUIDv6 creation. If read alone, this section could read that UUIDv6 implementations MUST set the unicast/multicast bit to one if an IEEE 802 address is not available. This could be a source of confusion for readers.\r\n",
      "createdAt": "2023-06-08T08:33:04Z",
      "updatedAt": "2023-06-09T13:39:26Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "324b7d2301d3851d33d63bf9a1c5dea8c51073d8",
      "headRepository": null,
      "headRefName": "v6_old_node_behavior",
      "headRefOid": "067d3e1d66fb1997212e4e6b5d780c7d864c2cd8",
      "closedAt": "2023-06-09T13:39:25Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "My logic in merging RFC4122 items in with v6/7/8/max was that since UUIDv6 is UUIDv1 with some bit swappage and some discouragements; where I mention UUIDv1 I should also mention UUIDv6 since both are technically equivalent if you want them to be (after swapping timestamp bits.)\r\n\r\nEdit: So I think this one should remain. ",
          "createdAt": "2023-06-09T13:07:21Z",
          "updatedAt": "2023-06-09T13:08:02Z"
        },
        {
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Sounds good. That's fair.",
          "createdAt": "2023-06-09T13:39:25Z",
          "updatedAt": "2023-06-09T13:39:25Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 112,
      "id": "PR_kwDOH6Ln3M5Sn4Xy",
      "title": "WGLC Final Merge",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/112",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Revert Max UUID Naming #107\r\n- Author Changes\r\n",
      "createdAt": "2023-06-09T13:15:14Z",
      "updatedAt": "2023-06-09T13:15:48Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "81ddd1ae08ada06326bf8175aa02102649efd0b1",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "wglc-final",
      "headRefOid": "c27e3f9c80d977ee4199b6f5eb4885cd257a1764",
      "closedAt": "2023-06-09T13:15:48Z",
      "mergedAt": "2023-06-09T13:15:48Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "0f30082e19e241a551d971e0f86523f276f79e18"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 113,
      "id": "PR_kwDOH6Ln3M5UR_yr",
      "title": "Fix typos",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/113",
      "state": "MERGED",
      "author": "jwilk",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-06-29T22:00:58Z",
      "updatedAt": "2023-07-17T19:47:31Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "92c4a8631fd7d12b582200f263f71ca1b60e8591",
      "headRepository": null,
      "headRefName": "spelling",
      "headRefOid": "23e180aadf818fd3d26ecf7709d66f652d65cf3b",
      "closedAt": "2023-07-17T19:47:31Z",
      "mergedAt": "2023-07-17T19:47:31Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "1676e1051d59ce05a6768d53905e15a39772d563"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "The draft has been submitted to the IESG. I will keep this pending in the event I get it back to make changes. \r\nHopefully the IETF editors will also catch these!",
          "createdAt": "2023-07-03T13:41:32Z",
          "updatedAt": "2023-07-03T13:41:32Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 118,
      "id": "PR_kwDOH6Ln3M5VWukp",
      "title": "Fix errata  6225 (again); GitHub issue #117",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/118",
      "state": "MERGED",
      "author": "danielmarschall",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "In 2020, I reported [errata 6225 for RFC4122](https://www.rfc-editor.org/errata/eid6225)\r\n\r\nThe errata is mentioned in the changelog of \"draft-00\", so I guess it was fixed. Thank you for changing this.\r\n\r\nHowever, there is another reference where it says \"ISO OID\", in Appendix A.  It should be called \"Object Identifier (OID)\".\r\n\r\nI also mentioned in Errata 6225, that I think it would be important to define how the OID should be defined, so I think it should mention in parentheses \"In dot-notation without leading dot\" (e.g. 2.999).\r\n",
      "createdAt": "2023-07-12T21:37:50Z",
      "updatedAt": "2023-07-17T19:48:13Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "92c4a8631fd7d12b582200f263f71ca1b60e8591",
      "headRepository": null,
      "headRefName": "patch-1",
      "headRefOid": "066a75f50cc0217cff1b06c4594306fd4bb95a20",
      "closedAt": "2023-07-17T19:48:13Z",
      "mergedAt": "2023-07-17T19:48:13Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "2043d5055e4038c302da2c7a38ab1833c6b29677"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 119,
      "id": "PR_kwDOH6Ln3M5VnUVZ",
      "title": "\"SHOULD\" fixes based on AD review and other input",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/119",
      "state": "MERGED",
      "author": "bradleypeabody",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Here are changes to address the \"SHOULD\" concerns based on the review done discussion in #114 ",
      "createdAt": "2023-07-16T20:18:17Z",
      "updatedAt": "2023-07-24T19:40:15Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "92c4a8631fd7d12b582200f263f71ca1b60e8591",
      "headRepository": "bradleypeabody/rfc4122bis",
      "headRefName": "20230716-should-fixes",
      "headRefOid": "6633fb0cc7122f7a867e4a15a56c2f0b6463e92b",
      "closedAt": "2023-07-24T19:40:15Z",
      "mergedAt": "2023-07-24T19:40:15Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "972b2dac28a445af24451935ce980a90bcaea88b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5bTV5w",
          "commit": {
            "abbreviatedOid": "03383c9"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-16T20:24:13Z",
          "updatedAt": "2023-07-16T20:24:14Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "@LiosK I saw your comment on #114, I think this works to keep it MUST NOT but specifically say \"due to counter rollover\", so it excludes other edge cases such as the clock rolling back. I think that aligns with the intention of the text anyway, which is all about counters.\r\n",
              "createdAt": "2023-07-16T20:24:13Z",
              "updatedAt": "2023-07-24T19:37:54Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5bTV8E",
          "commit": {
            "abbreviatedOid": "03383c9"
          },
          "author": "bradleypeabody",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-16T20:25:42Z",
          "updatedAt": "2023-07-16T20:25:42Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "I think stating the intended exception here (no CSPRNG available) makes sense and clearly justifies the use of SHOULD.",
              "createdAt": "2023-07-16T20:25:42Z",
              "updatedAt": "2023-07-24T19:38:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5bTtL3",
          "commit": {
            "abbreviatedOid": "03383c9"
          },
          "author": "cbandy",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-17T03:50:43Z",
          "updatedAt": "2023-07-17T03:50:43Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "Are only two possible actions allowed here, error or stalling? If not, I recommend removing the word \"either\" here.\r\n\r\nParaphrasing: If too many, maybe error or maybe stall; DO NOT duplicate.",
              "createdAt": "2023-07-17T03:50:43Z",
              "updatedAt": "2023-07-17T03:50:44Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5bjfbe",
          "commit": {
            "abbreviatedOid": "03383c9"
          },
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-07-18T23:33:14Z",
          "updatedAt": "2023-07-18T23:33:14Z",
          "comments": [
            {
              "originalPosition": 98,
              "body": "How about: \"General guidance is that the counter SHOULD be at least 12 bits but no longer than 42 bits for UUIDv7.\"? This guidance isn't really effective without the v7 context, and with that context BCP 14 verbiage makes sense.\r\n",
              "createdAt": "2023-07-18T23:33:14Z",
              "updatedAt": "2023-07-18T23:33:14Z"
            }
          ]
        }
      ]
    },
    {
      "number": 124,
      "id": "PR_kwDOH6Ln3M5W1rIi",
      "title": "DNSDIR Feedback",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/124",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Late addition of IETF reference for CSPRNG guidance #123\r\n- DNSDIR Review: Typos! #122\r\n- DNSDIR Review: DNS Considerations Update #121",
      "createdAt": "2023-07-31T19:54:38Z",
      "updatedAt": "2023-08-04T13:20:15Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "1735d9f553f487542d0b0b9f441753123f6e7a5d",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "DNSDIR",
      "headRefOid": "947245b0184bf22fe85afdec6ba1fda448d887b9",
      "closedAt": "2023-08-04T13:20:14Z",
      "mergedAt": "2023-08-04T13:20:14Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "69bebededd43ed570394ca50910d415c734da7a7"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 128,
      "id": "PR_kwDOH6Ln3M5W8Uos",
      "title": "Improve consistency of layout field definitions",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/128",
      "state": "MERGED",
      "author": "tgross35",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Add '0b' binary prefix where fitting\r\n- Add decimal values in addition to binary where it makes sense\r\n- Add \"occupies bits...\" where needed to make more consistent\r\n- Match capitalization of \"octet\" and terminal punctuation\r\n\r\nFixes #125",
      "createdAt": "2023-08-01T19:35:03Z",
      "updatedAt": "2023-08-10T21:12:43Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "69bebededd43ed570394ca50910d415c734da7a7",
      "headRepository": "tgross35/rfc4122bis",
      "headRefName": "patch-1",
      "headRefOid": "fef579956440d525bc62ff3de04926ab792b711c",
      "closedAt": "2023-08-04T13:21:53Z",
      "mergedAt": "2023-08-04T13:21:53Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "c6fe516b84b9d688e12481b4cff590736be40596"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I see a few other places where we can add `0b`, let me get those in another commit.",
          "createdAt": "2023-08-01T19:49:19Z",
          "updatedAt": "2023-08-01T19:49:19Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, I should have hit all of the 0b items, a few 0x items I saw along the way.\r\n\r\nI went ahead and added `Occupies bits ... octets ...` text to every bit layout descriptor in v1-v8 since it was bugging me that now only a few of them did not have this text.\r\n\r\nI will leave this open this week so others can double check the edits. \r\nSpecifically I ask: check the bits/octets referenced are correct. They look correct to me but little things like this can lead to erratas filed later.",
          "createdAt": "2023-08-01T20:25:26Z",
          "updatedAt": "2023-08-01T20:40:52Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is the term \"variant 10x\" correct, or should it be \"variant 0b10x\"?",
          "createdAt": "2023-08-01T23:45:37Z",
          "updatedAt": "2023-08-01T23:45:37Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> Is the term \"variant 10x\" correct, or should it be \"variant 0b10x\"?\r\n\r\nI wrote it that way in one pass but didn't like the way it read since the `x` is in there. I decided to leave it as 10x vs 0b01x which IMO looks a bit uglier.",
          "createdAt": "2023-08-02T18:27:31Z",
          "updatedAt": "2023-08-02T18:27:31Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Update: GENART review also confirmed this consistency with the underlying field definitions should be done.\r\nI will merge it down tomorrow if there are no objections.",
          "createdAt": "2023-08-03T13:03:54Z",
          "updatedAt": "2023-08-03T13:03:54Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 131,
      "id": "PR_kwDOH6Ln3M5X7Wkv",
      "title": "WLGC ARTART Review",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/131",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Items to close #130 \r\nAlso normalized some r'\\d+-bit' uses to r'\\d+ bit'",
      "createdAt": "2023-08-14T22:13:30Z",
      "updatedAt": "2023-08-23T13:55:02Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "23b5da2fc6c573b63ba485322872a8e2cd28c336",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "wglc-artart",
      "headRefOid": "26f38c94afda735b42ab290b5afc84a12306634d",
      "closedAt": "2023-08-23T13:55:02Z",
      "mergedAt": "2023-08-23T13:55:02Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "07e6b20a574ca6d1a950a0ad81c9d421dadcfb90"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5eOoWN",
          "commit": {
            "abbreviatedOid": "838dbb2"
          },
          "author": "LiosK",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-16T15:27:37Z",
          "updatedAt": "2023-08-16T15:27:37Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Lowercase \"version\" is generally used in the document?",
              "createdAt": "2023-08-16T15:27:37Z",
              "updatedAt": "2023-08-16T15:27:37Z"
            }
          ]
        }
      ]
    },
    {
      "number": 138,
      "id": "PR_kwDOH6Ln3M5ZEOYy",
      "title": "Draft 11",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/138",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- #137\r\n- #134\r\n- #136\r\n- #135\r\n- #139",
      "createdAt": "2023-08-29T19:11:37Z",
      "updatedAt": "2023-09-05T15:23:32Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "dd5b0982219f5475ebc7325a4ed0d7534b81104b",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "dns-rereview",
      "headRefOid": "e33e137c0738dc59b495003526ffc015e9bc3a0e",
      "closedAt": "2023-09-05T15:23:28Z",
      "mergedAt": "2023-09-05T15:23:28Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "765b8326ed3a317992fd3c05e23cd12a57a83f17"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5fb2KP",
          "commit": {
            "abbreviatedOid": "93ee3ba"
          },
          "author": "chrylis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-29T19:24:48Z",
          "updatedAt": "2023-08-29T19:25:45Z",
          "comments": [
            {
              "originalPosition": 89,
              "body": "s/need/needs/, and should \"use\" be \"reference\" or otherwise more specific?",
              "createdAt": "2023-08-29T19:24:48Z",
              "updatedAt": "2023-08-29T19:25:45Z"
            },
            {
              "originalPosition": 108,
              "body": "is \"Hashspace\" a proper noun (not capitalized below)?",
              "createdAt": "2023-08-29T19:25:25Z",
              "updatedAt": "2023-08-29T19:25:45Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5fcmo8",
          "commit": {
            "abbreviatedOid": "93ee3ba"
          },
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-29T21:51:07Z",
          "updatedAt": "2023-08-29T21:51:07Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "s/name-space/namespace/ too?",
              "createdAt": "2023-08-29T21:51:07Z",
              "updatedAt": "2023-08-29T21:51:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5fiIZS",
          "commit": {
            "abbreviatedOid": "93ee3ba"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-08-30T13:59:11Z",
          "updatedAt": "2023-08-30T13:59:12Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "I didn't even see the \"name-space\" let me fix that and lowercase the hashspace.",
              "createdAt": "2023-08-30T13:59:12Z",
              "updatedAt": "2023-08-30T13:59:12Z"
            }
          ]
        }
      ]
    },
    {
      "number": 148,
      "id": "PR_kwDOH6Ln3M5ahOBH",
      "title": "Typo?",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/148",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "UUIDv8 namespace UUID -> UUIDv8 name-based UUID",
      "createdAt": "2023-09-18T00:44:42Z",
      "updatedAt": "2023-09-20T17:59:49Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "8c35afe407715bab27bcdc44c15612bdd7dcc173",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "d1c896fe1421adb2323b386ee4758c15f153f4fd",
      "closedAt": "2023-09-20T17:59:49Z",
      "mergedAt": "2023-09-20T17:59:49Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "f94b0512ae8550f94b42f4ff65c91d2f38d1d794"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 152,
      "id": "PR_kwDOH6Ln3M5a0ROU",
      "title": "Draft 12",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/152",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Closing #141\r\n- Closing #142\r\n- Closing #145\r\n- Closing #140\r\n- Closing #146\r\n\r\nEdit: Will clean up the tracker to focus on the bigger discussions.",
      "createdAt": "2023-09-20T19:34:07Z",
      "updatedAt": "2023-09-27T20:21:49Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f94b0512ae8550f94b42f4ff65c91d2f38d1d794",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-12",
      "headRefOid": "cbf058aa13123caa25f655af7f8161e9f4381a12",
      "closedAt": "2023-09-27T20:21:49Z",
      "mergedAt": "2023-09-27T20:21:49Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "c3264f73fa29ed475f7b478c1aff15d6c0f32689"
      },
      "comments": [
        {
          "author": "sergeyprokhorenko",
          "authorAssociation": "NONE",
          "body": "@kyzer-davis\r\n\r\n**Please read [this](https://github.com/ietf-wg-uuidrev/rfc4122bis/issues/157#issuecomment-1734267152)**",
          "createdAt": "2023-09-25T19:34:39Z",
          "updatedAt": "2023-09-27T18:07:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 156,
      "id": "PR_kwDOH6Ln3M5bCoiI",
      "title": "Count v6 in as IEEE 802 users?",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/156",
      "state": "MERGED",
      "author": "LiosK",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Count v6 in as IEEE 802 users and imply the dependency is OPTIONAL",
      "createdAt": "2023-09-23T13:26:23Z",
      "updatedAt": "2023-09-27T13:44:53Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f94b0512ae8550f94b42f4ff65c91d2f38d1d794",
      "headRepository": null,
      "headRefName": "main",
      "headRefOid": "8cb1692eb66894fe8afdd585c5aa240c8ee800aa",
      "closedAt": "2023-09-27T13:44:53Z",
      "mergedAt": "2023-09-27T13:44:52Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "f34f7363cb54cd1d3c7308c93e25c791577fa2c5"
      },
      "comments": [
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "Good catch, can you change it to `although two formats may leverage optional` then I can merge it?",
          "createdAt": "2023-09-25T14:27:52Z",
          "updatedAt": "2023-09-25T14:27:52Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 158,
      "id": "PR_kwDOH6Ln3M5bdrYR",
      "title": "Hash-Based UUID Changes",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/158",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-09-28T16:27:37Z",
      "updatedAt": "2023-10-05T13:34:34Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "c3264f73fa29ed475f7b478c1aff15d6c0f32689",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "hash-based-uuids",
      "headRefOid": "815fa114be66689a659b37881a6568f62fc28784",
      "closedAt": "2023-10-05T13:34:34Z",
      "mergedAt": "2023-10-05T13:34:33Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "9c8340f0573a446ee1c4b7318ebeea75ecbf06b4"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 160,
      "id": "PR_kwDOH6Ln3M5bshy7",
      "title": "Change v8 Timestamp Resolution",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/160",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-02T17:42:51Z",
      "updatedAt": "2023-10-05T13:36:03Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "9c8340f0573a446ee1c4b7318ebeea75ecbf06b4",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "change-v8-example",
      "headRefOid": "7cd4acc7f10a40dc7e7af385b1d6c998e57065cf",
      "closedAt": "2023-10-05T13:36:03Z",
      "mergedAt": "2023-10-05T13:36:03Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "f6d0326a7252f58b13b3c63d4c107e8da1e7fb0e"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 162,
      "id": "PR_kwDOH6Ln3M5btYY3",
      "title": "IANA Registry and Registration",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/162",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "mcr",
        "jimfenton"
      ],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-02T20:07:38Z",
      "updatedAt": "2023-10-09T20:14:41Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f6d0326a7252f58b13b3c63d4c107e8da1e7fb0e",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "iana-registration",
      "headRefOid": "2f4a1762d58aee9436badf03468bcbb9dec21c16",
      "closedAt": "2023-10-09T20:14:41Z",
      "mergedAt": "2023-10-09T20:14:41Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "ca55a2a0defa236f4058b04bf0a2d1b728764bc8"
      },
      "comments": [
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Indeed it would be very interesting to learn about the origin of the Namespace IDs. I wonder, is it possible that 6ba7b813 does not exist because a bunch of UUIDs were generated, and the CPU just had a tiny delay between the third and the fourth UUID? So, maybe they were never numbered by hand?\r\n\r\n6ba7b810-9dad-11d1-80b4-00c04fd430c8 = 1998-02-04 22:13:53'1511824 GMT\r\n6ba7b811-9dad-11d1-80b4-00c04fd430c8 = 1998-02-04 22:13:53'1511825 GMT\r\n6ba7b812-9dad-11d1-80b4-00c04fd430c8 = 1998-02-04 22:13:53'1511826 GMT\r\n6ba7b814-9dad-11d1-80b4-00c04fd430c8 = 1998-02-04 22:13:53'1511828 GMT\r\n\r\n---\r\n\r\nI don't think it is a good idea to have this counting upwards numbering scheme. Why don't we simplify it and just allow all UUIDs as Namespace IDs?\r\n\r\nContra:\r\n- It doesn't look aesthetically \"nice\" when the UUIDs are not numbered nicely.\r\n\r\nPro:\r\n- The document would be much simpler if we just say that any UUID can be used as a Namespace ID **(IANA can still register and publish them, of course! I do like the idea of a registry very much)**\r\n- People can already use an arbitrary Namespace ID even if it is not yet registered at IANA (or is in the registration process). If we have a strict numbering, then people need to wait until IANA has confirmed that they get the requested number, otherwise if they begin implementing and don't wait for the confirmation, then there is a risk that two people (waiting for the IANA registration procedure to finish) end up using the same number.\r\n- Maybe today someone is already using an arbitrary namespace ID in a well-known application, and they later decide that they want (or should?) publish their namespace ID to IANA, but then IANA would reject it because it does not fit the numbering scheme. But the namespace is already in use, so what to do?\r\n- UUIDv1 is not meant to be created or edited by hand. Machine ID \"00c04fd430c8\" was probably a DELL machine someone (Paul Leach?) used. I think you should not create a UUID with Node ID 00c04fd430c8 because you don't own the machine, and you should not write a number (e.g. 6ba7b8xx) that does not represent the timestamp of now. It feels like you are breaking your own standard by creating UUIDv1 with a (now) false EUI48 and a (now) false time.\r\n\r\nWhat do you think?",
          "createdAt": "2023-10-03T03:04:44Z",
          "updatedAt": "2023-10-03T03:09:18Z"
        },
        {
          "author": "fabiolimace",
          "authorAssociation": "NONE",
          "body": "1998-02-04 22:13:53'1511824 GMT is the date of this document: https://datatracker.ietf.org/doc/html/draft-leach-uuids-guids-01",
          "createdAt": "2023-10-03T15:09:44Z",
          "updatedAt": "2023-10-03T15:09:44Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, some good points. But I audited many UUID implementations and I did not see many namespace IDs other than what the original had. There was a discussion post here by me on adding some others for IOT/Database etc, but it didn't get much feedback either. \r\n\r\nI don't think it needs to be overthought and a simple auto-increment can do the job. \r\n\r\nAs noted above, I did find one library using `6ba7b813` but I was unable to surmise it's description so I said \"don't use this one\" and start at a different number instead: https://github.com/gitpan/UUID-Object/blob/master/t/11_as.t#L53-L64\r\nI figure `6ba7b815` is the safest and easiest choice based on what we know.\r\n\r\nEdit: I also wanted to avoid what happened with Hashspace ID. Specifically the IESG comments about them being somewhat unrecognizable since they are random.",
          "createdAt": "2023-10-03T17:20:49Z",
          "updatedAt": "2023-10-03T17:54:48Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kyzer-davis \r\nI am a bit confused about the sentence \"_New Namespace IDs MUST be documented as per {{IANA}} and {{iana3}}._\".\r\nDoes this mean when I am using custom namespaces for UUIDv3 and UUIDv5, I am forced to register the namespace to IANA, otherwise the UUID would be \"illegal\" ? \r\nI have a few use-cases where I do have a custom namespace ID (this was the hash of \"invoice number\" from an ERP system), but it is very vendor-specific, so it is nothing that should be submitted to IANA.\r\n(Of course, nobody can prevent that I am using the namespace ID. However, I am trying to make my code as \"correct\" as possible by following standards)",
          "createdAt": "2023-10-03T17:28:17Z",
          "updatedAt": "2023-10-03T17:29:52Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, yeah the logic was that these NS IDs should be well documented since everybody'd in a namespace generating v3/v5 should have an idea of the correct input for the namespace so that they can all generate the same output. \r\nAssuming you want interoperability in that sense. \r\n\r\nIf its just a vendor/implementation specific thing, do it, but don't register it with IANA. \r\nI can put a line around this last statement but I thought it was covered by the statement up in IANA section:\r\n> Vendor-specific, application-specific, and deployment-specific values are unable to be registered.\r\n\r\nMaybe change the NS ID section to this so its all in one spot.\r\n> New Namespace IDs MUST be documented as per {{IANA}} and {{iana3}} if they are to be globally available. Implementations MAY continue to use vendor-specific, application-specific, and deployment-specific Namespace ID values but interoperability is not guaranteed.",
          "createdAt": "2023-10-03T17:36:14Z",
          "updatedAt": "2023-10-03T17:58:27Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kyzer-davis Thanks for clarification. I probably missed that detail.\r\n\r\nOk, so do I correctly understand that there are the \"standardized\" namespace IDs (which are numbered and registered at IANA) and the \"custom/vendor-specific\" namespace IDs? This makes sense and I think that's good. But then it would be very important that vendors MUST NOT use the numbering scheme from IANA, otherwise we end up having multiple \"6ba7b815\" namespaces. If vendors use UUID1/4/6/7 for their custom namespaces, there is no collission.\r\nDo you think this should be mentioned?",
          "createdAt": "2023-10-03T17:41:48Z",
          "updatedAt": "2023-10-03T17:43:16Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, yeah, it is worth mentioning that an implementation should avoid using that space and pick something else like UUIDv4 (or UUIDv8) for a custom, implementation specific namespace ID else they should register it using the auto-increment logic (and some spec defining its usage and whatnot).\r\nEdit: Text added in https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/162/commits/0555e967a82a39ed05c6f45c7f043f810eee2a71",
          "createdAt": "2023-10-03T17:44:10Z",
          "updatedAt": "2023-10-03T17:51:09Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kyzer-davis Thanks for that change! But why do you limit it to UUIDv4 and UUIDv8 ?  UUIDv1 (as long as node ID 00c04fd430c8 is not used), UUIDv6 and especially UUIDv7 are very important.\r\nUUIDv8 on the other hand is rather not good for a namespace ID, since it can collide easily, e.g. if people use `00000000-0000-8000-8000-000000000000` as namespace.",
          "createdAt": "2023-10-03T17:59:17Z",
          "updatedAt": "2023-10-03T17:59:17Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, I put `RECOMMENDED` which is just some steering verbiage.\r\nOne can do what you want if you don't care about interoperability with other libraries and the particular NS ID, this is just something to cover the \"well then what else should I use\" question vs leaving it blank/open-ended. I could add other options but sometimes too many choices is just as problematic as too few. \r\n\r\n> [3](https://www.rfc-editor.org/rfc/rfc2119#section-3). SHOULD   This word, or the adjective \"RECOMMENDED\", mean that there\r\n   may exist valid reasons in particular circumstances to ignore a\r\n   particular item, but the full implications must be understood and\r\n   carefully weighed before choosing a different course.\r\n\r\nI would argue that v8 is probably the best use case for some custom application NS ID value since \"custom vendor-specific implementation use case\" is exactly why v8 exists in the first place. So calling it out there made sense to me.",
          "createdAt": "2023-10-03T18:11:59Z",
          "updatedAt": "2023-10-03T18:12:36Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kyzer-davis \r\nSorry, but using UUIDv8 as Namespace ID in order to form a UUIDv3/5 is non-sense to me. :-) The payload-to-be-hashed is vendor-specific, and therefore the Namespace ID must be as unique as possible to avoid that the final UUIDv3/5 collides with other vendors's UUIDv3/5.\r\n\r\nSo, either use UUIDv8 **_directly_** (e.g. to include some custom numbers in it) and risk that there is a collission.\r\n\r\nOr use UUIDv3/UUIDv5 with a **_unique namespace ID_**. But if you use a auto-inc-namespace like `00000000-0000-8000-8000-000000000000` then you are very likely to collide with other UUIDv3/UUIDv5 if the payload matches too.\r\nIf the namespace ID is unique, then the collission probability is guaranteed 1/2^122. If UUIDv8 is used as namespace, then the resulting UUIDv3/5 collission probability is much lower than 1/2^122. \r\n\r\n---\r\n\r\n_**Proposal for a different wording (it does not forbid UUIDv8 , because people can do what they want)**_\r\n\r\n~~Proposal A (my personal preference):~~\r\n\r\n~~_These custom Namespace IDs MUST NOT use the logic above and instead use any other UUID version. If UUIDv1 is chosen, then the node id MUST NOT be \"00c04fd430c8\"._~~\r\n\r\n~~Proposal B (this makes advertisment for UUIDv7):~~\r\n\r\n~~_These custom Namespace IDs MUST NOT use the logic above and instead are RECOMMENDED to use UUIDv4 or UUIDv7 values as identifiers._~~\r\n\r\n---\r\n\r\n**_Edit_**: For both proposals, we need to be careful that we are talking about the Namespace IDs, not the final identifier. So these proposals would be clearer:\r\n\r\nProposal A (my personal preference):\r\n\r\n_These custom Namespace IDs MUST NOT use the logic above and instead use any other UUID version **as Namespace ID**. If UUIDv1 is chosen, then the node id MUST NOT be \"00c04fd430c8\"._\r\n\r\nProposal B (this makes advertisment for UUIDv7):\r\n\r\n_These custom Namespace IDs MUST NOT use the logic above and instead are RECOMMENDED to use UUIDv4 or UUIDv7 values as **Namespace identifiers**._\r\n",
          "createdAt": "2023-10-03T18:24:51Z",
          "updatedAt": "2023-10-03T18:47:30Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall, the main point you are calling out is \"custom, implementation specific namespace IDs\". If you want maximum interoperability on a global scale I would of course suggest registering that NS ID globally so everybody is on the same page with their v3/v5 algos.\r\nElse use whatever: v8, v4, v7. I don't think it really matters and I can change the text but the root of the argument is:\r\nYour using a custom NS ID in your application, within your confined context. Interoperability and collision on a global scale does not sound like a need (See section 6.6 and 6.7)\r\n\r\nA v8 NS ID fits that bill. A random UUIDv4 could work too. Sure, allocate a UUIDv7 for it. I can recommend all three. However, omitting the UUID version used for vendor-specific stuff seems weird to me when this is directly relevant to vendor-specific stuff.\r\n\r\nI also saw your edit: Correct this is for the Namespace ID not the final name-based UUID.",
          "createdAt": "2023-10-03T19:03:19Z",
          "updatedAt": "2023-10-03T19:03:44Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@kyzer-davis Indeed, I would be glad if you could edit the text.\r\n\r\nI understand what you are saying.\r\n\r\nI just want to clarify: I am **_not_** talking about my personal use-case. All I try to do is to help people reading the RFC to understand that it is crucial that Namespace IDs must be unique in any case. A unique Namespace ID prevents that UUIDv3/5 of different vendors collide. (In the case the UUIDs \"meet\" each other in some collection/domain/database/etc.)\r\n\r\nThe other topic you mention is interoperability. Yes, it is true that interoperability (i.e. two applications desire to output the same UUID for a given thing) is not guaranteed if people do not register the namespace ID and/or don't write a specification.\r\n",
          "createdAt": "2023-10-03T19:14:14Z",
          "updatedAt": "2023-10-03T19:25:16Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "@danielmarschall got it, check the commit I just posted: \r\nhttps://github.com/ietf-wg-uuidrev/rfc4122bis/pull/162/commits/f92530b2abb0f5ac5aa57922926d2de58716d4b2",
          "createdAt": "2023-10-03T19:28:35Z",
          "updatedAt": "2023-10-03T19:28:35Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good! Thank you.",
          "createdAt": "2023-10-03T19:30:19Z",
          "updatedAt": "2023-10-03T19:30:19Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "I also posted a Question over to #161 if anybody wants to comment on that over there.",
          "createdAt": "2023-10-03T19:36:03Z",
          "updatedAt": "2023-10-03T19:36:03Z"
        },
        {
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Daniel Marschall ***@***.***> wrote:\n    > Does this mean when I am using custom namespaces for UUIDv3 and UUIDv5,\n    > I am forced to register the namespace to IANA, otherwise the UUID would\n    > be \"illegal\" ?\n\nThat is not the intention.\n\nRather, if you are making a v8 namespace that you intend to use for\ninteroperation with others, then you should consider registering a pointer to\nyour stable document.\n\n",
          "createdAt": "2023-10-04T15:01:46Z",
          "updatedAt": "2023-10-04T15:01:46Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "At the request of the chairs, I have posted draft-12 without the IANA changes in this PR.\r\nThus I have moved this proposed text to draft-13 and it is a topic for the interim meeting as there are still some discussion points and text formatting to iron out. ",
          "createdAt": "2023-10-05T14:13:17Z",
          "updatedAt": "2023-10-05T14:13:17Z"
        },
        {
          "author": "danielmarschall",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I think you mean draft-13 prep, not draft-14 prep?",
          "createdAt": "2023-10-05T14:40:30Z",
          "updatedAt": "2023-10-05T14:40:30Z"
        },
        {
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think you mean draft-13 prep, not draft-14 prep?\r\n\r\nYeah, I have no idea how that got to 14.\r\nI double-checked my command line history and everything... I cannot explain it.\r\nI can amend the last commit message if needed but figured it wasn't that big a deal.\r\n\r\nHistory for those curious, it had to have append when I did the `--amend` command...\r\n```bash\r\n  490  cd rfc4122bis/\r\n  491  git branch -f iana-registratoin origin/iana-registration\r\n  492  git checkout iana-registration\r\n  493  git diff\r\n  494  git add .\r\n  495  git commit \"draft-13 prep\"\r\n  496  git commit -m \"draft-13 prep\"\r\n  497  git config --global user.name \"Kyzer Davis\"\r\n  498  git config --global user.email kydavis@cisco.com\r\n  499  git commit --amend --reset-author\r\n  500  git push origin iana-registration\r\n  ```",
          "createdAt": "2023-10-05T19:44:27Z",
          "updatedAt": "2023-10-05T19:44:42Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOH6Ln3M5ij3CS",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "ben221199",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I made a quick scan through your proposed changes and made comments on the things I found important in my eyes. Not every comment is a request to change, but at least subject to some debate.",
          "createdAt": "2023-10-02T21:47:37Z",
          "updatedAt": "2023-10-02T22:13:55Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Policy choice is debatable, I think.",
              "createdAt": "2023-10-02T21:47:38Z",
              "updatedAt": "2023-10-02T22:13:55Z"
            },
            {
              "originalPosition": 26,
              "body": "`Min` => `Nil`",
              "createdAt": "2023-10-02T21:48:12Z",
              "updatedAt": "2023-10-02T22:13:55Z"
            },
            {
              "originalPosition": 28,
              "body": "Because the version space is very small (0 to 15 are 16 possibilities), I think I prefer requiring RFCs for that part.",
              "createdAt": "2023-10-02T21:50:05Z",
              "updatedAt": "2023-10-02T22:13:55Z"
            },
            {
              "originalPosition": 40,
              "body": "I would not use the `Variant` column in this way. I think we should go with an 8-bit map (e.g. `0xxxxxxx` for Apollo NCS) and have a column that shows an integer range (e.g. `0 - 127` for Apollo NCS).",
              "createdAt": "2023-10-02T21:55:19Z",
              "updatedAt": "2023-10-02T22:13:55Z"
            },
            {
              "originalPosition": 52,
              "body": "I would suggest the subtype to be lowercase, e.g. `version`.",
              "createdAt": "2023-10-02T21:56:12Z",
              "updatedAt": "2023-10-02T22:13:55Z"
            },
            {
              "originalPosition": 62,
              "body": "Don't list unspecified items.",
              "createdAt": "2023-10-02T21:56:27Z",
              "updatedAt": "2023-10-02T22:13:55Z"
            },
            {
              "originalPosition": 72,
              "body": "I don't know if I see those two different type of UUIDs in the same table. In my mind we have 2 different tables for it. Open for discussion?",
              "createdAt": "2023-10-02T21:57:58Z",
              "updatedAt": "2023-10-02T22:13:55Z"
            },
            {
              "originalPosition": 119,
              "body": "Maybe we can ask Paul Leach more about this origin if this is not done yet. It seems we don't know exactly how they were created and we also don't know what happened with `6ba7b813`. If we know, we can come up with a better way to generate Special UUIDs and eventually even break the current limit.",
              "createdAt": "2023-10-02T22:10:53Z",
              "updatedAt": "2023-10-02T22:13:55Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5isG1u",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T17:10:23Z",
          "updatedAt": "2023-10-03T17:10:23Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I was leaning that way at first but UUIDv2 is a non-RFC and some types like the MS one, or even the 111 var and whatever subtype could be claimed by another standard body. \r\nThus I relaxed it since UUIDs, on a grand scale, are not just in the IETF space.\r\nEdit: there are also ITU/ISO docs around UUIDs which could in theory do something in the space. \r\nSpecification seems logical here over RFC.",
              "createdAt": "2023-10-03T17:10:23Z",
              "updatedAt": "2023-10-03T18:18:07Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5isIiC",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T17:14:49Z",
          "updatedAt": "2023-10-03T17:14:49Z",
          "comments": [
            {
              "originalPosition": 119,
              "body": "Yeah, I just put what I know and detailed how it is currently. There is nothing I could find in my research on the topic of `6ba7b813` and I saw at least one library using it in some code. So I said \"best let sleeping dogs lie\"..\r\n\r\nI think there has to be some guidance if we are registering such a value but again, I don't think we need to overthink it. \r\n\r\nEdit: Updated a bit in https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/162/commits/0555e967a82a39ed05c6f45c7f043f810eee2a71",
              "createdAt": "2023-10-03T17:14:49Z",
              "updatedAt": "2023-10-03T17:52:18Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5isMm-",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T17:22:10Z",
          "updatedAt": "2023-10-03T17:22:10Z",
          "comments": [
            {
              "originalPosition": 72,
              "body": "I figured they can be fine with as long as there is a column descriptor stating the usage. \r\nI can split it into a second section easy enough but I felt nil/max make sense lumped in this way.",
              "createdAt": "2023-10-03T17:22:10Z",
              "updatedAt": "2023-10-03T17:22:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5isM6Z",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T17:22:58Z",
          "updatedAt": "2023-10-03T17:22:58Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I was unable to find any info on if this was good or bad. I planned on bringing it up in the interim.",
              "createdAt": "2023-10-03T17:22:58Z",
              "updatedAt": "2023-10-03T17:22:58Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5isNrd",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T17:25:04Z",
          "updatedAt": "2023-10-03T17:25:04Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Are you talking about the column header of `Subtype` change to `Version`? \r\nOr the row items in the column being changed from `Version` to `version`?\r\n\r\nI specifically used \"Subtype\" in the column headers since \"version\" is a construct of this UUID RFC and other subtyping mechanisms exist (in a historical sense at least.)",
              "createdAt": "2023-10-03T17:25:04Z",
              "updatedAt": "2023-10-03T17:30:39Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5isSfZ",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T17:37:34Z",
          "updatedAt": "2023-10-03T17:37:35Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Sure, easy enough change although nothing technically out there in real world uses more than 4 var bits at the moment right? \r\nIt can be modified later, I was just going off of what we have in the table of _this_ document. ",
              "createdAt": "2023-10-03T17:37:34Z",
              "updatedAt": "2023-10-03T17:59:11Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5itKSf",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "ben221199",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T19:48:53Z",
          "updatedAt": "2023-10-03T19:48:53Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Family is 8-bit on the same byte-location. If we parse the variant also like a 8-bit, it is easy to convert it to an family integer: `if(variant<0x80){ family = variant & 0b1111111; }`. It also gives us the possibility to assign numbers (or number ranges) to a variant, which is not working for variable-size bit maps.",
              "createdAt": "2023-10-03T19:48:53Z",
              "updatedAt": "2023-10-03T19:48:53Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5itKj5",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "ben221199",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T19:49:40Z",
          "updatedAt": "2023-10-03T19:49:40Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I meant the column value `version`. The word `Subtype` as column header is good enough.",
              "createdAt": "2023-10-03T19:49:40Z",
              "updatedAt": "2023-10-03T19:49:40Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5itLSa",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "ben221199",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T19:51:47Z",
          "updatedAt": "2023-10-03T19:51:48Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "In case of DNS, not all 65536 possibilities for record types are `Unspecified`, so seems bad practice to me to list them.",
              "createdAt": "2023-10-03T19:51:48Z",
              "updatedAt": "2023-10-03T19:51:48Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5itel1",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T20:38:42Z",
          "updatedAt": "2023-10-03T20:38:42Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Edit: Modified the table in https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/162/commits/e64464efff3f53ba81f6db27b93ca0717c93c033\r\nShould I drop v0? Seems folks forget that's technically a possible version although unused/unspecified.",
              "createdAt": "2023-10-03T20:38:42Z",
              "updatedAt": "2023-10-03T20:59:19Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5itfgR",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "kyzer-davis",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T20:41:17Z",
          "updatedAt": "2023-10-03T20:41:17Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Hmm, okay I see where you are going. \r\nI am going to leave it for the moment based on what we have in this doc. \r\nWe can flyways update the IANA registration later down the line in the historical RFC when we flesh out family. \r\nA side topic, I don't want to derail the thread so I am going to resolve this one for the moment.",
              "createdAt": "2023-10-03T20:41:17Z",
              "updatedAt": "2023-10-03T20:41:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5it1OH",
          "commit": {
            "abbreviatedOid": "a75e3cc"
          },
          "author": "ben221199",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-03T21:46:05Z",
          "updatedAt": "2023-10-03T21:46:05Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I know it is possible and I once came across someone who implemented a v0 version. In my opinion, I would set that one on `Reserved` instead of `Unspecified`.",
              "createdAt": "2023-10-03T21:46:05Z",
              "updatedAt": "2023-10-03T21:46:05Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5jEoG9",
          "commit": {
            "abbreviatedOid": "1246cf4"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-06T15:39:10Z",
          "updatedAt": "2023-10-06T15:39:10Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "```suggestion\r\n\r\nItems may be added to this table using Specification Required policy {{RFC8126}}\r\n\r\n```",
              "createdAt": "2023-10-06T15:39:10Z",
              "updatedAt": "2023-10-06T15:39:10Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5jEoTU",
          "commit": {
            "abbreviatedOid": "0010a40"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-06T15:39:36Z",
          "updatedAt": "2023-10-06T15:39:36Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "```suggestion\r\n| Namespace | Namespace ID                         |  Document |\r\n```",
              "createdAt": "2023-10-06T15:39:36Z",
              "updatedAt": "2023-10-06T15:39:36Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOH6Ln3M5jEud-",
          "commit": {
            "abbreviatedOid": "907ac48"
          },
          "author": "mcr",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2023-10-06T15:52:08Z",
          "updatedAt": "2023-10-06T15:52:08Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "```suggestion\r\n\r\nThis table may be extended by the Standards Action policy {{RFC8126}}.\r\n\r\n```",
              "createdAt": "2023-10-06T15:52:08Z",
              "updatedAt": "2023-10-06T15:52:08Z"
            }
          ]
        }
      ]
    },
    {
      "number": 168,
      "id": "PR_kwDOH6Ln3M5cS-xp",
      "title": "Draft 13 - Misc",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/168",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2023-10-09T20:31:01Z",
      "updatedAt": "2023-10-20T13:55:30Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "ca55a2a0defa236f4058b04bf0a2d1b728764bc8",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-13",
      "headRefOid": "ea92c30b98719cb0fdd77a29f6fd2a26714575c4",
      "closedAt": "2023-10-20T13:55:30Z",
      "mergedAt": "2023-10-20T13:55:30Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "5d43ce3a5081f82ea197ca40283008c1884c2826"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 173,
      "id": "PR_kwDOH6Ln3M5dpD_b",
      "title": "Draft 14",
      "url": "https://github.com/ietf-wg-uuidrev/rfc4122bis/pull/173",
      "state": "MERGED",
      "author": "kyzer-davis",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "IANA items from the AD Review",
      "createdAt": "2023-10-24T13:35:29Z",
      "updatedAt": "2023-10-27T20:45:11Z",
      "baseRepository": "ietf-wg-uuidrev/rfc4122bis",
      "baseRefName": "main",
      "baseRefOid": "f244d39acda6d0ecf09a23c84eec7e0febcb6d7e",
      "headRepository": "ietf-wg-uuidrev/rfc4122bis",
      "headRefName": "draft-14",
      "headRefOid": "4a515cb3bf74953b5e3169f281a90004bbba6961",
      "closedAt": "2023-10-27T20:45:11Z",
      "mergedAt": "2023-10-27T20:45:11Z",
      "mergedBy": "kyzer-davis",
      "mergeCommit": {
        "oid": "93332820df9152ef03eac17aa55190d2379630fd"
      },
      "comments": [],
      "reviews": []
    }
  ]
}